"""
Enterprise Budget & Forecasting Platform
A comprehensive financial planning solution for enterprise organizations
Designed to replace Workday Adaptive Planning

Version: 2.0
"""

import streamlit as st
import pandas as pd
import numpy as np
import random
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import io
import os
import json
import re
import zipfile
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta
from decimal import Decimal
import calendar
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass
from enum import Enum

# Optional dependencies
try:
    import psycopg2
    from psycopg2.extras import Json, RealDictCursor
    PSYCOPG2_AVAILABLE = True
except ImportError:
    PSYCOPG2_AVAILABLE = False

try:
    import pyxlsb
    PYXLSB_AVAILABLE = True
except ImportError:
    PYXLSB_AVAILABLE = False

try:
    from reportlab.lib.pagesizes import letter, landscape
    from reportlab.lib import colors as rl_colors
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image, PageBreak
    from reportlab.pdfgen import canvas
    from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False

try:
    from pptx import Presentation
    from pptx.util import Inches, Pt
    from pptx.dml.color import RGBColor
    from pptx.enum.text import PP_ALIGN, MSO_ANCHOR
    from pptx.enum.shapes import MSO_SHAPE
    PPTX_AVAILABLE = True
except ImportError:
    PPTX_AVAILABLE = False


# =============================================================================
# PDF TIMESHEET GENERATOR (Stub - removed to reduce widget count)
# =============================================================================

def generate_timesheet_pdf(timesheet_data: dict, line_items: list = None) -> io.BytesIO:
    """Generate a PDF timesheet using reportlab"""
    try:
        from reportlab.lib.pagesizes import letter, landscape
        from reportlab.lib import colors
        from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
        from reportlab.lib.units import inch
        from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
        from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
        
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=landscape(letter), 
                               leftMargin=0.5*inch, rightMargin=0.5*inch,
                               topMargin=0.5*inch, bottomMargin=0.5*inch)
        
        elements = []
        styles = getSampleStyleSheet()
        
        # Title style
        title_style = ParagraphStyle('Title', parent=styles['Heading1'], 
                                     fontSize=16, textColor=colors.HexColor('#1e40af'),
                                     alignment=TA_CENTER)
        
        # Header
        elements.append(Paragraph("EnergySolutions Employee Timesheet", title_style))
        elements.append(Spacer(1, 12))
        
        # Employee info table
        emp_name = timesheet_data.get('Employee_Name', 'Unknown')
        emp_id = timesheet_data.get('Employee_ID', 'N/A')
        emp_class = timesheet_data.get('Employee_Class', 'N/A')
        period_end = timesheet_data.get('Period_Ending', 'N/A')
        if hasattr(period_end, 'strftime'):
            period_end = period_end.strftime('%B %d, %Y')
        
        info_data = [
            ['Employee:', emp_name, 'Period Ending:', str(period_end)],
            ['Employee ID:', str(emp_id), 'Schedule:', timesheet_data.get('Schedule', 'ES-SF')],
            ['Class:', str(emp_class), 'Revision:', str(timesheet_data.get('Revision', 1))],
        ]
        
        info_table = Table(info_data, colWidths=[1.2*inch, 2.5*inch, 1.2*inch, 2.5*inch])
        info_table.setStyle(TableStyle([
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (2, 0), (2, -1), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ]))
        elements.append(info_table)
        elements.append(Spacer(1, 20))
        
        # Hours summary
        regular = timesheet_data.get('Regular_Hours', 0)
        overtime = timesheet_data.get('Overtime_Hours', 0)
        total = timesheet_data.get('Total_Hours', regular + overtime)
        
        hours_data = [
            ['Regular Hours', 'Overtime Hours', 'Total Hours'],
            [f"{regular:.2f}", f"{overtime:.2f}", f"{total:.2f}"]
        ]
        
        hours_table = Table(hours_data, colWidths=[2*inch, 2*inch, 2*inch])
        hours_table.setStyle(TableStyle([
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTNAME', (0, 1), (-1, 1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 11),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#e5e7eb')),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ('TOPPADDING', (0, 0), (-1, -1), 8),
        ]))
        elements.append(hours_table)
        elements.append(Spacer(1, 30))
        
        # Approval section
        status = timesheet_data.get('Status', 'Pending')
        approver = timesheet_data.get('Approver', 'N/A')
        approval_date = timesheet_data.get('Approval_Date', None)
        if approval_date and hasattr(approval_date, 'strftime'):
            approval_date = approval_date.strftime('%B %d, %Y')
        else:
            approval_date = 'Pending'
        
        approval_data = [
            ['Status:', status, 'Approver:', str(approver)],
            ['Approval Date:', str(approval_date), '', ''],
        ]
        
        approval_table = Table(approval_data, colWidths=[1.2*inch, 2*inch, 1.2*inch, 2*inch])
        approval_table.setStyle(TableStyle([
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (2, 0), (2, -1), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ]))
        elements.append(approval_table)
        elements.append(Spacer(1, 30))
        
        # Signature line
        sig_style = ParagraphStyle('Signature', parent=styles['Normal'], fontSize=10)
        elements.append(Paragraph("_" * 50, sig_style))
        elements.append(Paragraph("Employee Signature / Date", sig_style))
        elements.append(Spacer(1, 20))
        elements.append(Paragraph("_" * 50, sig_style))
        elements.append(Paragraph("Supervisor Signature / Date", sig_style))
        
        # Disclaimer
        elements.append(Spacer(1, 30))
        disclaimer_style = ParagraphStyle('Disclaimer', parent=styles['Normal'], 
                                          fontSize=8, textColor=colors.grey)
        elements.append(Paragraph(
            "By signing this timesheet, you certify that the hours charged are accurate and in accordance "
            "with EnergySolutions Time and Labor Charging Policy.", disclaimer_style))
        
        doc.build(elements)
        buffer.seek(0)
        return buffer
        
    except ImportError:
        # Fallback: create a simple text-based PDF-like file
        buffer = io.BytesIO()
        # Create minimal valid PDF
        pdf_content = f"""%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>
endobj
4 0 obj
<< /Length 300 >>
stream
BT
/F1 16 Tf
50 750 Td
(EnergySolutions Timesheet) Tj
/F1 12 Tf
0 -30 Td
(Employee: {timesheet_data.get('Employee_Name', 'N/A')}) Tj
0 -20 Td
(Employee ID: {timesheet_data.get('Employee_ID', 'N/A')}) Tj
0 -20 Td
(Period: {timesheet_data.get('Period_Ending', 'N/A')}) Tj
0 -20 Td
(Regular Hours: {timesheet_data.get('Regular_Hours', 0):.2f}) Tj
0 -20 Td
(Overtime Hours: {timesheet_data.get('Overtime_Hours', 0):.2f}) Tj
0 -20 Td
(Total Hours: {timesheet_data.get('Total_Hours', 0):.2f}) Tj
0 -20 Td
(Status: {timesheet_data.get('Status', 'Pending')}) Tj
ET
endstream
endobj
5 0 obj
<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>
endobj
xref
0 6
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000000115 00000 n 
0000000266 00000 n 
0000000618 00000 n 
trailer
<< /Size 6 /Root 1 0 R >>
startxref
695
%%EOF"""
        buffer.write(pdf_content.encode('latin-1'))
        buffer.seek(0)
        return buffer

def read_xlsx_raw(file_obj_or_path) -> pd.DataFrame:
    """
    Read xlsx file by parsing XML directly to avoid openpyxl formatting issues.
    Works with both file paths and file-like objects (uploaded files).
    """
    try:
        # Handle both file paths and file objects
        if hasattr(file_obj_or_path, 'read'):
            # It's a file-like object
            file_bytes = file_obj_or_path.read()
            file_obj_or_path.seek(0)  # Reset for potential re-read
            z = zipfile.ZipFile(io.BytesIO(file_bytes), 'r')
        else:
            z = zipfile.ZipFile(file_obj_or_path, 'r')
        
        with z:
            # Read shared strings
            strings = []
            try:
                with z.open('xl/sharedStrings.xml') as f:
                    tree = ET.parse(f)
                    root = tree.getroot()
                    ns = {'ns': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'}
                    for si in root.findall('.//ns:si', ns):
                        text_parts = []
                        for t in si.findall('.//ns:t', ns):
                            if t.text:
                                text_parts.append(t.text)
                        strings.append(''.join(text_parts) if text_parts else '')
            except:
                pass
            
            # Read sheet data
            with z.open('xl/worksheets/sheet1.xml') as f:
                tree = ET.parse(f)
                root = tree.getroot()
                ns = {'ns': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'}
                
                rows_data = []
                for row in root.findall('.//ns:row', ns):
                    row_data = {}
                    for cell in row.findall('.//ns:c', ns):
                        cell_ref = cell.get('r')  # e.g., "A1"
                        cell_type = cell.get('t')  # 's' for shared string
                        value_elem = cell.find('ns:v', ns)
                        
                        if value_elem is not None and value_elem.text:
                            if cell_type == 's':
                                # Shared string - look up in strings list
                                idx = int(value_elem.text)
                                value = strings[idx] if idx < len(strings) else ''
                            else:
                                value = value_elem.text
                            
                            # Extract column letter from cell ref
                            col = ''.join(c for c in cell_ref if c.isalpha())
                            row_data[col] = value
                    
                    if row_data:
                        rows_data.append(row_data)
                
                # Convert to DataFrame
                if rows_data:
                    # Get all columns
                    all_cols = []
                    for row in rows_data:
                        for col in row.keys():
                            if col not in all_cols:
                                all_cols.append(col)
                    all_cols.sort(key=lambda x: (len(x), x))  # Sort A, B, C, ..., AA, AB
                    
                    # Build DataFrame
                    df_data = []
                    for row in rows_data:
                        df_data.append([row.get(col, '') for col in all_cols])
                    
                    df = pd.DataFrame(df_data)
                    # Use first row as header
                    if len(df) > 0:
                        df.columns = df.iloc[0]
                        df = df[1:].reset_index(drop=True)
                    return df
        
        return pd.DataFrame()
    except Exception as e:
        st.error(f"Error reading Excel file: {e}")
        return pd.DataFrame()


def lookup_department(dept_num: str) -> dict:
    """
    Look up department details from org_departments table.
    Returns dict with Legal Entity, Organization, Division, Business Unit, etc.
    """
    if 'org_departments' not in st.session_state or st.session_state.org_departments.empty:
        return {}
    
    df = st.session_state.org_departments
    dept_num_str = str(dept_num).strip()
    
    # Try to find by Es Department column (the department number)
    match = None
    if 'Es Department' in df.columns:
        match = df[df['Es Department'].astype(str).str.strip() == dept_num_str]
    
    # Also try Department column if Es Department didn't work
    if (match is None or match.empty) and 'Department' in df.columns:
        # Department column has format like "11100  LWP", so try to match the number part
        match = df[df['Department'].astype(str).str.contains(dept_num_str, regex=False)]
    
    if match is not None and not match.empty:
        row = match.iloc[0]
        return {
            'Legal_Entity': str(row.get('Legal Entity', '')),
            'Legal_Entity_Name': str(row.get('Legal Entity Name', '')),
            'Organization': str(row.get('Organization', '')),
            'Division': str(row.get('Es Division', '')),
            'Business_Unit': str(row.get('Es Business Unit', '')),
            'Department': str(row.get('Es Department', '')),
            'Department_Description': str(row.get('Department Description', '')),
            'Department_Full': str(row.get('Department', '')),
            'Direct_vs_SGA': str(row.get('Directvssga', '')),
            'FPA_Responsible': str(row.get('Fpa Responsible', '')),
            'Email': str(row.get('Email', '')),
        }
    
    return {}


def lookup_account(acct_num: str) -> dict:
    """
    Look up account details from org_accounts table.
    Returns dict with Account Name, Category, Type, Levels, etc.
    """
    if 'org_accounts' not in st.session_state or st.session_state.org_accounts.empty:
        return {}
    
    df = st.session_state.org_accounts
    acct_num_str = str(acct_num).strip()
    
    # Try to find by Gl Account Num column
    match = None
    if 'Gl Account Num' in df.columns:
        match = df[df['Gl Account Num'].astype(str).str.strip() == acct_num_str]
    
    if match is not None and not match.empty:
        row = match.iloc[0]
        return {
            'Account_Num': str(row.get('Gl Account Num', '')),
            'Account_Name': str(row.get('Name', '')),
            'Account_Name_Full': str(row.get('Account Name Hyphenated', '')),
            'Account_Category': str(row.get('Account Category', '')),
            'Account_Type': str(row.get('Account Type', '')),
            'Level1': str(row.get('Level1', '')),
            'Level2': str(row.get('Level2', '')),
            'Level3': str(row.get('Level3', '')),
            'Fixed': str(row.get('Fixed', '')),
            'Variable': str(row.get('Variable', '')),
            'Account_Sub_Category': str(row.get('Account Sub Category', '')),
        }
    
    return {}


def get_department_options() -> list:
    """Get list of department options for selectbox from org_departments."""
    if 'org_departments' not in st.session_state or st.session_state.org_departments.empty:
        return []
    
    df = st.session_state.org_departments
    
    # Use the Department column (formatted like "11100  LWP")
    if 'Department' in df.columns:
        return sorted(df['Department'].dropna().unique().tolist())
    elif 'Es Department' in df.columns:
        return sorted(df['Es Department'].dropna().unique().tolist())
    
    return []


def get_account_options() -> list:
    """Get list of account options for selectbox from org_accounts."""
    if 'org_accounts' not in st.session_state or st.session_state.org_accounts.empty:
        return []
    
    df = st.session_state.org_accounts
    
    # Use the Account Name Hyphenated column (formatted like "50010 - Salaries")
    if 'Account Name Hyphenated' in df.columns:
        return sorted(df['Account Name Hyphenated'].dropna().unique().tolist())
    elif 'Gl Account Num' in df.columns:
        return sorted(df['Gl Account Num'].dropna().unique().tolist())
    
    return []


# WORKFLOW & APPROVAL SYSTEM
# =============================================================================

class WorkflowStatus(Enum):
    """Workflow status states"""
    DRAFT = "draft"
    PENDING_REVIEW = "pending_review"
    IN_REVIEW = "in_review"
    PENDING_APPROVAL = "pending_approval"
    APPROVED = "approved"
    REJECTED = "rejected"
    REVISION_REQUESTED = "revision_requested"
    LOCKED = "locked"
    ARCHIVED = "archived"


class ApprovalAction(Enum):
    """Actions that can be taken on an approval"""
    SUBMIT = "submit"
    APPROVE = "approve"
    REJECT = "reject"
    REQUEST_REVISION = "request_revision"
    DELEGATE = "delegate"
    RECALL = "recall"
    COMMENT = "comment"
    LOCK = "lock"
    UNLOCK = "unlock"


@dataclass
class WorkflowStep:
    """Definition of a workflow step"""
    step_id: int
    step_name: str
    approver_role: str  # e.g., 'dept_manager', 'finance_manager', 'cfo', 'ceo'
    approver_email: Optional[str] = None
    approver_name: Optional[str] = None
    is_required: bool = True
    can_delegate: bool = True
    timeout_days: int = 7
    threshold_amount: Optional[float] = None  # Only require this step if amount exceeds threshold
    order: int = 0


@dataclass
class ApprovalRecord:
    """Record of an approval action"""
    record_id: str
    workflow_id: str
    step_id: int
    action: ApprovalAction
    actor_email: str
    actor_name: str
    timestamp: datetime
    comments: str = ""
    delegate_to: Optional[str] = None


class WorkflowEngine:
    """
    Workflow and approval management system
    
    Features:
    - Multi-step approval workflows
    - Role-based routing
    - Threshold-based approvals
    - Delegation support
    - Email notifications
    - Audit trail
    - Due date tracking
    - Comments and notes
    """
    
    # Predefined workflow templates
    WORKFLOW_TEMPLATES = {
        'budget_approval': {
            'name': 'Budget Approval',
            'description': 'Standard budget approval workflow',
            'steps': [
                {'step_id': 1, 'step_name': 'Manager Review', 'approver_role': 'dept_manager', 'timeout_days': 5},
                {'step_id': 2, 'step_name': 'Finance Review', 'approver_role': 'finance_manager', 'timeout_days': 5},
                {'step_id': 3, 'step_name': 'CFO Approval', 'approver_role': 'cfo', 'timeout_days': 7, 'threshold_amount': 100000},
                {'step_id': 4, 'step_name': 'CEO Approval', 'approver_role': 'ceo', 'timeout_days': 7, 'threshold_amount': 500000},
            ]
        },
        'forecast_submission': {
            'name': 'Forecast Submission',
            'description': 'Monthly forecast submission workflow',
            'steps': [
                {'step_id': 1, 'step_name': 'Manager Submission', 'approver_role': 'dept_manager', 'timeout_days': 3},
                {'step_id': 2, 'step_name': 'Finance Consolidation', 'approver_role': 'finance_manager', 'timeout_days': 3},
            ]
        },
        'variance_review': {
            'name': 'Variance Review',
            'description': 'Monthly variance explanation workflow',
            'steps': [
                {'step_id': 1, 'step_name': 'Provide Explanation', 'approver_role': 'dept_manager', 'timeout_days': 2},
                {'step_id': 2, 'step_name': 'Finance Review', 'approver_role': 'finance_analyst', 'timeout_days': 2},
                {'step_id': 3, 'step_name': 'Finance Approval', 'approver_role': 'finance_manager', 'timeout_days': 3},
            ]
        },
        'headcount_request': {
            'name': 'Headcount Request',
            'description': 'New position approval workflow',
            'steps': [
                {'step_id': 1, 'step_name': 'Manager Request', 'approver_role': 'dept_manager', 'timeout_days': 3},
                {'step_id': 2, 'step_name': 'HR Review', 'approver_role': 'hr_manager', 'timeout_days': 3},
                {'step_id': 3, 'step_name': 'Finance Review', 'approver_role': 'finance_manager', 'timeout_days': 3},
                {'step_id': 4, 'step_name': 'VP Approval', 'approver_role': 'vp', 'timeout_days': 5},
            ]
        },
        'capex_approval': {
            'name': 'CapEx Approval',
            'description': 'Capital expenditure approval workflow',
            'steps': [
                {'step_id': 1, 'step_name': 'Manager Request', 'approver_role': 'dept_manager', 'timeout_days': 3},
                {'step_id': 2, 'step_name': 'Finance Review', 'approver_role': 'finance_manager', 'timeout_days': 5},
                {'step_id': 3, 'step_name': 'CFO Approval', 'approver_role': 'cfo', 'timeout_days': 7},
                {'step_id': 4, 'step_name': 'CEO Approval', 'approver_role': 'ceo', 'timeout_days': 7, 'threshold_amount': 250000},
                {'step_id': 5, 'step_name': 'Board Approval', 'approver_role': 'board', 'timeout_days': 14, 'threshold_amount': 1000000},
            ]
        },
    }
    
    # Role hierarchy for automatic routing
    ROLE_HIERARCHY = {
        'contributor': 0,
        'dept_manager': 1,
        'senior_manager': 2,
        'director': 3,
        'vp': 4,
        'svp': 5,
        'finance_analyst': 2,
        'finance_manager': 3,
        'finance_director': 4,
        'controller': 5,
        'cfo': 6,
        'coo': 6,
        'ceo': 7,
        'board': 8,
        'hr_manager': 3,
        'hr_director': 4,
    }
    
    def __init__(self):
        self.workflows: Dict[str, dict] = {}
        self.workflow_instances: Dict[str, dict] = {}
        self.approval_history: List[ApprovalRecord] = []
        self.user_roles: Dict[str, str] = {}  # email -> role mapping
        self.delegates: Dict[str, str] = {}  # delegator -> delegate mapping
    
    def create_workflow(self, workflow_id: str, template_name: str,
                        entity_id: str = None, cost_center_id: str = None,
                        version_id: str = None, amount: float = None,
                        submitter_email: str = None, submitter_name: str = None,
                        metadata: dict = None) -> dict:
        """
        Create a new workflow instance from a template
        
        Args:
            workflow_id: Unique identifier for this workflow instance
            template_name: Name of the workflow template to use
            entity_id: Entity this workflow is for
            cost_center_id: Cost center this workflow is for
            version_id: Budget version this workflow is for
            amount: Total amount (for threshold-based routing)
            submitter_email: Email of the person submitting
            submitter_name: Name of the submitter
            metadata: Additional data to attach to the workflow
        """
        template = self.WORKFLOW_TEMPLATES.get(template_name)
        if not template:
            raise ValueError(f"Unknown workflow template: {template_name}")
        
        # Filter steps based on threshold
        active_steps = []
        for step in template['steps']:
            threshold = step.get('threshold_amount')
            if threshold is None or (amount and amount >= threshold):
                active_steps.append(WorkflowStep(
                    step_id=step['step_id'],
                    step_name=step['step_name'],
                    approver_role=step['approver_role'],
                    timeout_days=step.get('timeout_days', 7),
                    threshold_amount=threshold,
                    order=step['step_id']
                ))
        
        workflow_instance = {
            'workflow_id': workflow_id,
            'template_name': template_name,
            'template_display_name': template['name'],
            'entity_id': entity_id,
            'cost_center_id': cost_center_id,
            'version_id': version_id,
            'amount': amount,
            'status': WorkflowStatus.DRAFT.value,
            'current_step': 0,
            'total_steps': len(active_steps),
            'steps': [vars(s) for s in active_steps],
            'submitter_email': submitter_email,
            'submitter_name': submitter_name,
            'created_at': datetime.now().isoformat(),
            'updated_at': datetime.now().isoformat(),
            'due_date': None,
            'completed_at': None,
            'metadata': metadata or {},
            'comments': [],
        }
        
        self.workflow_instances[workflow_id] = workflow_instance
        return workflow_instance
    
    def submit_for_approval(self, workflow_id: str, 
                            submitter_email: str, submitter_name: str,
                            comments: str = "") -> dict:
        """Submit a workflow for approval"""
        workflow = self.workflow_instances.get(workflow_id)
        if not workflow:
            raise ValueError(f"Workflow not found: {workflow_id}")
        
        if workflow['status'] not in [WorkflowStatus.DRAFT.value, WorkflowStatus.REVISION_REQUESTED.value]:
            raise ValueError(f"Cannot submit workflow in status: {workflow['status']}")
        
        workflow['status'] = WorkflowStatus.PENDING_APPROVAL.value
        workflow['current_step'] = 1
        workflow['updated_at'] = datetime.now().isoformat()
        
        # Calculate due date based on first step timeout
        if workflow['steps']:
            timeout_days = workflow['steps'][0].get('timeout_days', 7)
            workflow['due_date'] = (datetime.now() + timedelta(days=timeout_days)).isoformat()
        
        # Record the action
        self._record_action(workflow_id, 0, ApprovalAction.SUBMIT,
                           submitter_email, submitter_name, comments)
        
        # Add comment if provided
        if comments:
            workflow['comments'].append({
                'author': submitter_name,
                'email': submitter_email,
                'timestamp': datetime.now().isoformat(),
                'text': comments,
                'action': 'submit'
            })
        
        return workflow
    
    def approve(self, workflow_id: str, approver_email: str, 
                approver_name: str, comments: str = "") -> dict:
        """Approve the current step of a workflow"""
        workflow = self.workflow_instances.get(workflow_id)
        if not workflow:
            raise ValueError(f"Workflow not found: {workflow_id}")
        
        if workflow['status'] != WorkflowStatus.PENDING_APPROVAL.value:
            raise ValueError(f"Cannot approve workflow in status: {workflow['status']}")
        
        current_step = workflow['current_step']
        
        # Record the approval
        self._record_action(workflow_id, current_step, ApprovalAction.APPROVE,
                           approver_email, approver_name, comments)
        
        # Add comment
        if comments:
            workflow['comments'].append({
                'author': approver_name,
                'email': approver_email,
                'timestamp': datetime.now().isoformat(),
                'text': comments,
                'action': 'approve',
                'step': current_step
            })
        
        # Move to next step or complete
        if current_step >= workflow['total_steps']:
            workflow['status'] = WorkflowStatus.APPROVED.value
            workflow['completed_at'] = datetime.now().isoformat()
            workflow['due_date'] = None
        else:
            workflow['current_step'] = current_step + 1
            # Update due date for next step
            next_step = workflow['steps'][current_step] if current_step < len(workflow['steps']) else None
            if next_step:
                timeout_days = next_step.get('timeout_days', 7)
                workflow['due_date'] = (datetime.now() + timedelta(days=timeout_days)).isoformat()
        
        workflow['updated_at'] = datetime.now().isoformat()
        return workflow
    
    def reject(self, workflow_id: str, rejector_email: str,
               rejector_name: str, comments: str = "") -> dict:
        """Reject a workflow"""
        workflow = self.workflow_instances.get(workflow_id)
        if not workflow:
            raise ValueError(f"Workflow not found: {workflow_id}")
        
        workflow['status'] = WorkflowStatus.REJECTED.value
        workflow['updated_at'] = datetime.now().isoformat()
        workflow['completed_at'] = datetime.now().isoformat()
        
        self._record_action(workflow_id, workflow['current_step'], ApprovalAction.REJECT,
                           rejector_email, rejector_name, comments)
        
        workflow['comments'].append({
            'author': rejector_name,
            'email': rejector_email,
            'timestamp': datetime.now().isoformat(),
            'text': comments or "Rejected",
            'action': 'reject',
            'step': workflow['current_step']
        })
        
        return workflow
    
    def request_revision(self, workflow_id: str, reviewer_email: str,
                         reviewer_name: str, comments: str) -> dict:
        """Request revisions to a workflow"""
        workflow = self.workflow_instances.get(workflow_id)
        if not workflow:
            raise ValueError(f"Workflow not found: {workflow_id}")
        
        workflow['status'] = WorkflowStatus.REVISION_REQUESTED.value
        workflow['current_step'] = 0
        workflow['updated_at'] = datetime.now().isoformat()
        
        self._record_action(workflow_id, workflow['current_step'], 
                           ApprovalAction.REQUEST_REVISION,
                           reviewer_email, reviewer_name, comments)
        
        workflow['comments'].append({
            'author': reviewer_name,
            'email': reviewer_email,
            'timestamp': datetime.now().isoformat(),
            'text': comments,
            'action': 'request_revision',
            'step': workflow['current_step']
        })
        
        return workflow
    
    def delegate(self, workflow_id: str, delegator_email: str,
                 delegate_email: str, delegate_name: str,
                 comments: str = "") -> dict:
        """Delegate approval authority to another person"""
        workflow = self.workflow_instances.get(workflow_id)
        if not workflow:
            raise ValueError(f"Workflow not found: {workflow_id}")
        
        # Update current step with delegate info
        current_idx = workflow['current_step'] - 1
        if 0 <= current_idx < len(workflow['steps']):
            workflow['steps'][current_idx]['delegated_to'] = delegate_email
            workflow['steps'][current_idx]['delegated_name'] = delegate_name
        
        self._record_action(workflow_id, workflow['current_step'], ApprovalAction.DELEGATE,
                           delegator_email, f"Delegated to {delegate_name}", comments,
                           delegate_to=delegate_email)
        
        workflow['comments'].append({
            'author': delegator_email,
            'timestamp': datetime.now().isoformat(),
            'text': f"Delegated to {delegate_name} ({delegate_email}). {comments}",
            'action': 'delegate',
            'step': workflow['current_step']
        })
        
        workflow['updated_at'] = datetime.now().isoformat()
        return workflow
    
    def recall(self, workflow_id: str, submitter_email: str,
               submitter_name: str, comments: str = "") -> dict:
        """Recall a submitted workflow back to draft"""
        workflow = self.workflow_instances.get(workflow_id)
        if not workflow:
            raise ValueError(f"Workflow not found: {workflow_id}")
        
        if workflow['submitter_email'] != submitter_email:
            raise ValueError("Only the submitter can recall a workflow")
        
        if workflow['status'] not in [WorkflowStatus.PENDING_APPROVAL.value, 
                                       WorkflowStatus.PENDING_REVIEW.value]:
            raise ValueError(f"Cannot recall workflow in status: {workflow['status']}")
        
        workflow['status'] = WorkflowStatus.DRAFT.value
        workflow['current_step'] = 0
        workflow['updated_at'] = datetime.now().isoformat()
        
        self._record_action(workflow_id, 0, ApprovalAction.RECALL,
                           submitter_email, submitter_name, comments)
        
        return workflow
    
    def add_comment(self, workflow_id: str, author_email: str,
                    author_name: str, comment_text: str) -> dict:
        """Add a comment to a workflow"""
        workflow = self.workflow_instances.get(workflow_id)
        if not workflow:
            raise ValueError(f"Workflow not found: {workflow_id}")
        
        workflow['comments'].append({
            'author': author_name,
            'email': author_email,
            'timestamp': datetime.now().isoformat(),
            'text': comment_text,
            'action': 'comment',
            'step': workflow['current_step']
        })
        
        self._record_action(workflow_id, workflow['current_step'], ApprovalAction.COMMENT,
                           author_email, author_name, comment_text)
        
        workflow['updated_at'] = datetime.now().isoformat()
        return workflow
    
    def lock_workflow(self, workflow_id: str, locker_email: str,
                      locker_name: str) -> dict:
        """Lock an approved workflow to prevent changes"""
        workflow = self.workflow_instances.get(workflow_id)
        if not workflow:
            raise ValueError(f"Workflow not found: {workflow_id}")
        
        if workflow['status'] != WorkflowStatus.APPROVED.value:
            raise ValueError("Can only lock approved workflows")
        
        workflow['status'] = WorkflowStatus.LOCKED.value
        workflow['updated_at'] = datetime.now().isoformat()
        workflow['locked_by'] = locker_email
        workflow['locked_at'] = datetime.now().isoformat()
        
        self._record_action(workflow_id, workflow['current_step'], ApprovalAction.LOCK,
                           locker_email, locker_name, "Workflow locked")
        
        return workflow
    
    def _record_action(self, workflow_id: str, step_id: int, action: ApprovalAction,
                       actor_email: str, actor_name: str, comments: str = "",
                       delegate_to: str = None):
        """Record an action in the audit trail"""
        record = ApprovalRecord(
            record_id=f"{workflow_id}_{len(self.approval_history)}",
            workflow_id=workflow_id,
            step_id=step_id,
            action=action,
            actor_email=actor_email,
            actor_name=actor_name,
            timestamp=datetime.now(),
            comments=comments,
            delegate_to=delegate_to
        )
        self.approval_history.append(record)
    
    def get_pending_approvals(self, approver_email: str = None,
                              approver_role: str = None) -> List[dict]:
        """Get all pending approvals for a user or role"""
        pending = []
        
        for wf_id, workflow in self.workflow_instances.items():
            if workflow['status'] != WorkflowStatus.PENDING_APPROVAL.value:
                continue
            
            current_idx = workflow['current_step'] - 1
            if current_idx < 0 or current_idx >= len(workflow['steps']):
                continue
            
            current_step = workflow['steps'][current_idx]
            
            # Check if this user should approve
            should_include = False
            
            if approver_role and current_step.get('approver_role') == approver_role:
                should_include = True
            
            if approver_email:
                if current_step.get('approver_email') == approver_email:
                    should_include = True
                if current_step.get('delegated_to') == approver_email:
                    should_include = True
            
            if should_include or (not approver_email and not approver_role):
                pending.append({
                    **workflow,
                    'current_step_info': current_step,
                    'is_overdue': self._is_overdue(workflow)
                })
        
        return pending
    
    def get_my_submissions(self, submitter_email: str) -> List[dict]:
        """Get all workflows submitted by a user"""
        return [wf for wf in self.workflow_instances.values() 
                if wf.get('submitter_email') == submitter_email]
    
    def get_workflow_history(self, workflow_id: str) -> List[ApprovalRecord]:
        """Get the approval history for a workflow"""
        return [r for r in self.approval_history if r.workflow_id == workflow_id]
    
    def _is_overdue(self, workflow: dict) -> bool:
        """Check if a workflow is past its due date"""
        if not workflow.get('due_date'):
            return False
        due_date = datetime.fromisoformat(workflow['due_date'])
        return datetime.now() > due_date
    
    def get_workflow_stats(self) -> dict:
        """Get summary statistics for all workflows"""
        stats = {
            'total': len(self.workflow_instances),
            'by_status': {},
            'overdue': 0,
            'avg_cycle_time_days': 0,
        }
        
        cycle_times = []
        
        for workflow in self.workflow_instances.values():
            status = workflow['status']
            stats['by_status'][status] = stats['by_status'].get(status, 0) + 1
            
            if self._is_overdue(workflow):
                stats['overdue'] += 1
            
            if workflow.get('completed_at') and workflow.get('created_at'):
                created = datetime.fromisoformat(workflow['created_at'])
                completed = datetime.fromisoformat(workflow['completed_at'])
                cycle_times.append((completed - created).days)
        
        if cycle_times:
            stats['avg_cycle_time_days'] = sum(cycle_times) / len(cycle_times)
        
        return stats


# =============================================================================
# AI ASSISTANT - Multi-Provider Support
# =============================================================================

class AIAssistant:
    """
    AI Assistant with support for multiple providers:
    - Incorta Nexus
    - Google Gemini
    - Azure OpenAI
    - Anthropic Claude
    - OpenAI ChatGPT
    """
    
    PROVIDERS = {
        'aixplain': {
            'name': 'AIxplain Financial AI',
            'models': ['695fce4c27b4e3580e43d126'],
            'default_model': '695fce4c27b4e3580e43d126',
            'api_base': 'https://aixplain.cloud.incorta.com/api/v1'
        },
        'openai': {
            'name': 'OpenAI ChatGPT',
            'models': ['gpt-4o', 'gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo'],
            'default_model': 'gpt-4o',
            'api_base': 'https://api.openai.com/v1'
        },
        'anthropic': {
            'name': 'Anthropic Claude',
            'models': ['claude-3-opus-20240229', 'claude-3-sonnet-20240229', 'claude-3-haiku-20240307'],
            'default_model': 'claude-3-sonnet-20240229',
            'api_base': 'https://api.anthropic.com/v1'
        },
        'azure': {
            'name': 'Azure OpenAI',
            'models': ['gpt-4o', 'gpt-4', 'gpt-35-turbo'],
            'default_model': 'gpt-4o',
            'api_base': None  # Set by user
        },
        'gemini': {
            'name': 'Google Gemini',
            'models': ['gemini-1.5-pro', 'gemini-1.5-flash', 'gemini-pro'],
            'default_model': 'gemini-1.5-pro',
            'api_base': 'https://generativelanguage.googleapis.com/v1'
        },
        'incorta': {
            'name': 'Incorta Nexus',
            'models': ['nexus'],
            'default_model': 'nexus',
            'api_base': None  # Set by Incorta instance URL
        }
    }
    
    SYSTEM_PROMPT = """You are an AI assistant for EnergySolutions' Enterprise Planning Platform. 
You help with financial planning, budgeting, forecasting, and analysis for a nuclear services company.

You have expertise in:
- Budget planning and variance analysis
- Capital expenditure (CapEx) planning
- Workforce and resource planning
- Cash flow management
- Contract management (Cost Plus, FFP, T&M contracts)
- Financial KPIs and metrics
- DOE and nuclear industry terminology

When analyzing data, be specific with numbers and provide actionable insights.
Format financial figures appropriately (e.g., $1.5M, 12.5%).
Reference specific cost centers, facilities, or contracts when relevant.

Current facilities include: Clive, Bear Creek, Memphis, Barnwell, Erwin, Hittman, LWP, Kewaunee, TMI-2.
Divisions: D&D, WM, Corporate, Nuclear Services, ESFS."""

    def __init__(self):
        self.provider = None
        self.api_key = None
        self.model = None
        self.conversation_history = []
        self.azure_endpoint = None
        self.azure_deployment = None
        self.incorta_url = None
        self.incorta_tenant = None
        self._initialized = False
    
    def configure(self, provider: str, api_key: str, model: str = None,
                  azure_endpoint: str = None, azure_deployment: str = None,
                  incorta_url: str = None, incorta_tenant: str = None) -> dict:
        """Configure the AI assistant with provider and credentials"""
        if provider not in self.PROVIDERS:
            return {'success': False, 'message': f'Unknown provider: {provider}'}
        
        self.provider = provider
        self.api_key = api_key
        self.model = model or self.PROVIDERS[provider]['default_model']
        self.azure_endpoint = azure_endpoint
        self.azure_deployment = azure_deployment
        self.incorta_url = incorta_url
        self.incorta_tenant = incorta_tenant
        self._initialized = True
        
        return {'success': True, 'message': f'Configured {self.PROVIDERS[provider]["name"]}'}
    
    def is_configured(self) -> bool:
        return self._initialized and self.api_key is not None
    
    def clear_history(self):
        """Clear conversation history"""
        self.conversation_history = []
    
    def _call_openai(self, user_message: str, context: str = None) -> dict:
        """Call OpenAI API"""
        try:
            import requests
            
            messages = [{"role": "system", "content": self.SYSTEM_PROMPT}]
            
            if context:
                messages.append({"role": "system", "content": f"Current data context:\n{context}"})
            
            for msg in self.conversation_history[-10:]:  # Last 10 messages
                messages.append(msg)
            
            messages.append({"role": "user", "content": user_message})
            
            response = requests.post(
                f"{self.PROVIDERS['openai']['api_base']}/chat/completions",
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": self.model,
                    "messages": messages,
                    "temperature": 0.7,
                    "max_tokens": 2000
                },
                timeout=60
            )
            
            if response.status_code == 200:
                data = response.json()
                assistant_message = data['choices'][0]['message']['content']
                
                self.conversation_history.append({"role": "user", "content": user_message})
                self.conversation_history.append({"role": "assistant", "content": assistant_message})
                
                return {'success': True, 'response': assistant_message}
            else:
                return {'success': False, 'response': f"API Error: {response.status_code} - {response.text[:200]}"}
                
        except Exception as e:
            return {'success': False, 'response': f"Error: {str(e)}"}
    
    def _call_anthropic(self, user_message: str, context: str = None) -> dict:
        """Call Anthropic Claude API"""
        try:
            import requests
            
            system_content = self.SYSTEM_PROMPT
            if context:
                system_content += f"\n\nCurrent data context:\n{context}"
            
            messages = []
            for msg in self.conversation_history[-10:]:
                messages.append(msg)
            
            messages.append({"role": "user", "content": user_message})
            
            response = requests.post(
                f"{self.PROVIDERS['anthropic']['api_base']}/messages",
                headers={
                    "x-api-key": self.api_key,
                    "anthropic-version": "2023-06-01",
                    "Content-Type": "application/json"
                },
                json={
                    "model": self.model,
                    "max_tokens": 2000,
                    "system": system_content,
                    "messages": messages
                },
                timeout=60
            )
            
            if response.status_code == 200:
                data = response.json()
                assistant_message = data['content'][0]['text']
                
                self.conversation_history.append({"role": "user", "content": user_message})
                self.conversation_history.append({"role": "assistant", "content": assistant_message})
                
                return {'success': True, 'response': assistant_message}
            else:
                return {'success': False, 'response': f"API Error: {response.status_code} - {response.text[:200]}"}
                
        except Exception as e:
            return {'success': False, 'response': f"Error: {str(e)}"}
    
    def _call_azure(self, user_message: str, context: str = None) -> dict:
        """Call Azure OpenAI API"""
        try:
            import requests
            
            if not self.azure_endpoint or not self.azure_deployment:
                return {'success': False, 'response': 'Azure endpoint and deployment name required'}
            
            messages = [{"role": "system", "content": self.SYSTEM_PROMPT}]
            
            if context:
                messages.append({"role": "system", "content": f"Current data context:\n{context}"})
            
            for msg in self.conversation_history[-10:]:
                messages.append(msg)
            
            messages.append({"role": "user", "content": user_message})
            
            url = f"{self.azure_endpoint}/openai/deployments/{self.azure_deployment}/chat/completions?api-version=2024-02-15-preview"
            
            response = requests.post(
                url,
                headers={
                    "api-key": self.api_key,
                    "Content-Type": "application/json"
                },
                json={
                    "messages": messages,
                    "temperature": 0.7,
                    "max_tokens": 2000
                },
                timeout=60
            )
            
            if response.status_code == 200:
                data = response.json()
                assistant_message = data['choices'][0]['message']['content']
                
                self.conversation_history.append({"role": "user", "content": user_message})
                self.conversation_history.append({"role": "assistant", "content": assistant_message})
                
                return {'success': True, 'response': assistant_message}
            else:
                return {'success': False, 'response': f"API Error: {response.status_code} - {response.text[:200]}"}
                
        except Exception as e:
            return {'success': False, 'response': f"Error: {str(e)}"}
    
    def _call_gemini(self, user_message: str, context: str = None) -> dict:
        """Call Google Gemini API"""
        try:
            import requests
            
            full_prompt = self.SYSTEM_PROMPT
            if context:
                full_prompt += f"\n\nCurrent data context:\n{context}"
            
            # Add conversation history
            for msg in self.conversation_history[-10:]:
                role = "User" if msg['role'] == 'user' else "Assistant"
                full_prompt += f"\n\n{role}: {msg['content']}"
            
            full_prompt += f"\n\nUser: {user_message}\n\nAssistant:"
            
            url = f"{self.PROVIDERS['gemini']['api_base']}/models/{self.model}:generateContent?key={self.api_key}"
            
            response = requests.post(
                url,
                headers={"Content-Type": "application/json"},
                json={
                    "contents": [{"parts": [{"text": full_prompt}]}],
                    "generationConfig": {
                        "temperature": 0.7,
                        "maxOutputTokens": 2000
                    }
                },
                timeout=60
            )
            
            if response.status_code == 200:
                data = response.json()
                assistant_message = data['candidates'][0]['content']['parts'][0]['text']
                
                self.conversation_history.append({"role": "user", "content": user_message})
                self.conversation_history.append({"role": "assistant", "content": assistant_message})
                
                return {'success': True, 'response': assistant_message}
            else:
                return {'success': False, 'response': f"API Error: {response.status_code} - {response.text[:200]}"}
                
        except Exception as e:
            return {'success': False, 'response': f"Error: {str(e)}"}
    
    def _call_incorta(self, user_message: str, context: str = None) -> dict:
        """Call Incorta Nexus API"""
        try:
            import requests
            
            if not self.incorta_url or not self.incorta_tenant:
                return {'success': False, 'response': 'Incorta URL and tenant required'}
            
            full_prompt = user_message
            if context:
                full_prompt = f"Context:\n{context}\n\nQuestion: {user_message}"
            
            # Incorta Nexus endpoint
            url = f"{self.incorta_url}/incorta/api/v1/{self.incorta_tenant}/nexus/chat"
            
            response = requests.post(
                url,
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                },
                json={
                    "query": full_prompt,
                    "conversation_id": None,  # New conversation each time, or track
                    "include_sources": True
                },
                timeout=60
            )
            
            if response.status_code == 200:
                data = response.json()
                assistant_message = data.get('response', data.get('answer', str(data)))
                
                self.conversation_history.append({"role": "user", "content": user_message})
                self.conversation_history.append({"role": "assistant", "content": assistant_message})
                
                return {'success': True, 'response': assistant_message, 'sources': data.get('sources', [])}
            else:
                return {'success': False, 'response': f"API Error: {response.status_code} - {response.text[:200]}"}
                
        except Exception as e:
            return {'success': False, 'response': f"Error: {str(e)}"}
    
    def _call_aixplain(self, user_message: str, context: str = None) -> dict:
        """Call AIxplain Financial AI API"""
        try:
            import requests
            import time
            
            # Build the full prompt with context
            full_prompt = self.SYSTEM_PROMPT + "\n\n"
            if context:
                full_prompt += f"Current Financial Data Context:\n{context}\n\n"
            full_prompt += f"User Question: {user_message}"
            
            # AIxplain API endpoint
            base_url = self.PROVIDERS['aixplain']['api_base']
            url = f"{base_url}/execute/{self.model}"
            
            headers = {
                "x-api-key": self.api_key,
                "Content-Type": "application/json"
            }
            
            # Initial request
            try:
                response = requests.post(
                    url,
                    headers=headers,
                    json={
                        "data": full_prompt
                    },
                    timeout=30
                )
            except requests.exceptions.ConnectionError as e:
                return {'success': False, 'response': f"Cannot connect to AIxplain API. The domain may be blocked or unreachable. Error: {str(e)[:200]}"}
            
            if response.status_code in [200, 201]:
                data = response.json()
                
                # Check for async pattern - if we get a request_id, poll for results
                if 'requestId' in data or 'request_id' in data:
                    request_id = data.get('requestId') or data.get('request_id')
                    poll_url = f"{base_url}/poll/{request_id}"
                    
                    # Poll for completion (max 60 seconds)
                    for attempt in range(30):
                        time.sleep(2)
                        try:
                            poll_response = requests.get(poll_url, headers=headers, timeout=15)
                        except:
                            continue
                        
                        if poll_response.status_code == 200:
                            poll_data = poll_response.json()
                            
                            # Check if completed
                            if poll_data.get('completed', False):
                                assistant_message = self._extract_ai_response(poll_data)
                                self.conversation_history.append({"role": "user", "content": user_message})
                                self.conversation_history.append({"role": "assistant", "content": assistant_message})
                                return {'success': True, 'response': assistant_message}
                            
                            # Check for error
                            if poll_data.get('error'):
                                return {'success': False, 'response': f"AI Error: {poll_data.get('error')}"}
                    
                    return {'success': False, 'response': 'AI request timed out. Try a shorter question or check your API configuration.'}
                
                # Synchronous response
                assistant_message = self._extract_ai_response(data)
                self.conversation_history.append({"role": "user", "content": user_message})
                self.conversation_history.append({"role": "assistant", "content": assistant_message})
                return {'success': True, 'response': assistant_message}
                
            elif response.status_code == 403:
                return {'success': False, 'response': 'API access denied. Check your API key or network restrictions.'}
            elif response.status_code == 401:
                return {'success': False, 'response': 'Invalid API key. Please check your AIxplain API key.'}
            else:
                return {'success': False, 'response': f"API Error {response.status_code}: {response.text[:300]}"}
                
        except requests.exceptions.Timeout:
            return {'success': False, 'response': 'Request timed out. The AI service may be slow or unavailable.'}
        except Exception as e:
            return {'success': False, 'response': f"Error: {str(e)}"}
    
    def _extract_ai_response(self, data: dict) -> str:
        """Extract the AI response from various API response formats"""
        # Common response fields to check
        response_fields = ['data', 'output', 'result', 'response', 'text', 'message', 'content', 'answer', 'completion']
        
        for field in response_fields:
            if field in data:
                value = data[field]
                # Make sure it's a string and not the API key
                if isinstance(value, str) and len(value) > 0:
                    # Filter out anything that looks like an API key (64 hex chars)
                    if len(value) == 64 and all(c in '0123456789abcdef' for c in value.lower()):
                        continue
                    return value
                elif isinstance(value, dict):
                    # Recursively check nested dict
                    nested = self._extract_ai_response(value)
                    if nested and not nested.startswith("Could not extract"):
                        return nested
        
        # Check for nested 'choices' (OpenAI-style)
        if 'choices' in data and len(data['choices']) > 0:
            choice = data['choices'][0]
            if 'message' in choice:
                return choice['message'].get('content', str(choice['message']))
            elif 'text' in choice:
                return choice['text']
        
        # Return debug info if we can't find the response
        return f"Could not extract AI response. Raw data keys: {list(data.keys())}"
    
    def chat(self, user_message: str, context: str = None) -> dict:
        """Send a message to the configured AI provider"""
        if not self.is_configured():
            return {'success': False, 'response': 'AI Assistant not configured. Please set up API credentials.'}
        
        if self.provider == 'aixplain':
            return self._call_aixplain(user_message, context)
        elif self.provider == 'openai':
            return self._call_openai(user_message, context)
        elif self.provider == 'anthropic':
            return self._call_anthropic(user_message, context)
        elif self.provider == 'azure':
            return self._call_azure(user_message, context)
        elif self.provider == 'gemini':
            return self._call_gemini(user_message, context)
        elif self.provider == 'incorta':
            return self._call_incorta(user_message, context)
        else:
            return {'success': False, 'response': f'Unknown provider: {self.provider}'}
    
    def get_data_summary(self, session_state) -> str:
        """Generate a comprehensive summary of current data for AI context"""
        summary_parts = []
        
        # Budget data summary
        if hasattr(session_state, 'budget_data') and not session_state.budget_data.empty:
            df = session_state.budget_data
            total_budget = df['Budget'].sum() if 'Budget' in df.columns else 0
            total_actual = df['Actual'].sum() if 'Actual' in df.columns else 0
            total_forecast = df['Forecast'].sum() if 'Forecast' in df.columns else 0
            variance = total_actual - total_budget
            variance_pct = (variance / total_budget * 100) if total_budget > 0 else 0
            
            summary_parts.append(f"""
BUDGET DATA:
- Total Budget: ${total_budget/1e6:.1f}M
- Total Actual: ${total_actual/1e6:.1f}M  
- Total Forecast: ${total_forecast/1e6:.1f}M
- Overall Variance: ${variance/1e6:.1f}M ({variance_pct:+.1f}%)""")
            
            # Variance by category if available
            if 'Account_Category' in df.columns:
                cat_summary = df.groupby('Account_Category').agg({
                    'Budget': 'sum',
                    'Actual': 'sum'
                }).reset_index()
                cat_summary['Variance'] = cat_summary['Actual'] - cat_summary['Budget']
                cat_summary['Var_Pct'] = (cat_summary['Variance'] / cat_summary['Budget'] * 100).round(1)
                
                summary_parts.append("\nVariance by Category:")
                for _, row in cat_summary.iterrows():
                    summary_parts.append(f"  - {row['Account_Category']}: ${row['Variance']/1e6:.2f}M ({row['Var_Pct']:+.1f}%)")
        
        # CapEx summary
        if hasattr(session_state, 'capex_projects') and not session_state.capex_projects.empty:
            df = session_state.capex_projects
            total_budget = df['Budget_2025'].sum() if 'Budget_2025' in df.columns else 0
            total_spent = df['Spent_To_Date'].sum() if 'Spent_To_Date' in df.columns else 0
            total_remaining = df['Remaining'].sum() if 'Remaining' in df.columns else 0
            
            summary_parts.append(f"""
CAPEX PROJECTS:
- Total Projects: {len(df)}
- Total Budget: ${total_budget/1e6:.1f}M
- Spent to Date: ${total_spent/1e6:.1f}M ({total_spent/total_budget*100:.0f}%)
- Remaining: ${total_remaining/1e6:.1f}M""")
            
            if 'Status' in df.columns:
                status_counts = df['Status'].value_counts().to_dict()
                summary_parts.append(f"- Status: {', '.join([f'{k}: {v}' for k,v in status_counts.items()])}")
        
        # Contract summary
        if hasattr(session_state, 'contract_data') and not session_state.contract_data.empty:
            df = session_state.contract_data
            total_value = df['Contract_Value'].sum() if 'Contract_Value' in df.columns else 0
            cost_to_date = df['Cost_To_Date'].sum() if 'Cost_To_Date' in df.columns else 0
            revenue_to_date = df['Revenue_To_Date'].sum() if 'Revenue_To_Date' in df.columns else 0
            
            summary_parts.append(f"""
CONTRACTS:
- Total Contracts: {len(df)}
- Total Contract Value: ${total_value/1e6:.1f}M
- Cost to Date: ${cost_to_date/1e6:.1f}M
- Revenue to Date: ${revenue_to_date/1e6:.1f}M
- Margin: {((revenue_to_date - cost_to_date)/revenue_to_date*100):.1f}%""")
            
            if 'Contract_Type' in df.columns:
                type_summary = df.groupby('Contract_Type')['Contract_Value'].sum()
                summary_parts.append(f"- By Type: {', '.join([f'{k}: ${v/1e6:.1f}M' for k,v in type_summary.items()])}")
        
        # Cash flow summary
        if hasattr(session_state, 'cash_flow_data') and not session_state.cash_flow_data.empty:
            df = session_state.cash_flow_data
            starting = df['Beginning_Balance'].iloc[0] if 'Beginning_Balance' in df.columns else 0
            ending = df['Ending_Balance'].iloc[-1] if 'Ending_Balance' in df.columns else 0
            min_balance = df['Ending_Balance'].min() if 'Ending_Balance' in df.columns else 0
            
            summary_parts.append(f"""
CASH FLOW (13-Week Forecast):
- Starting Balance: ${starting/1e6:.1f}M
- Projected Ending: ${ending/1e6:.1f}M
- Minimum Balance: ${min_balance/1e6:.1f}M
- Net Change: ${(ending-starting)/1e6:.1f}M""")
        
        # Resource summary
        if hasattr(session_state, 'resource_data') and not session_state.resource_data.empty:
            df = session_state.resource_data
            headcount = len(df)
            avg_util = df['Utilization_Actual'].mean() if 'Utilization_Actual' in df.columns else 0
            billable_hrs = df['Billable_Hours'].sum() if 'Billable_Hours' in df.columns else 0
            
            summary_parts.append(f"""
RESOURCES:
- Total Headcount: {headcount}
- Average Utilization: {avg_util*100:.1f}%
- Billable Hours This Month: {billable_hrs:,.0f}""")
        
        if not summary_parts:
            return "No financial data loaded. Please load sample data to enable AI analysis."
        
        return "\n".join(summary_parts)


# =============================================================================
# YEAR-OVER-YEAR COMPARISON UTILITIES
# =============================================================================

class YearOverYearAnalysis:
    """Utilities for Year-over-Year comparisons"""
    
    @staticmethod
    def generate_historical_data(current_data: pd.DataFrame, years_back: int = 3,
                                 growth_rate: float = 0.05, variance: float = 0.1) -> Dict[int, pd.DataFrame]:
        """
        Generate simulated historical data based on current data
        
        Args:
            current_data: Current year DataFrame
            years_back: Number of years of history to generate
            growth_rate: Average YoY growth rate
            variance: Random variance factor
        
        Returns:
            Dictionary of {year: DataFrame}
        """
        historical = {}
        current_year = datetime.now().year
        
        base_df = current_data.copy()
        
        for i in range(1, years_back + 1):
            year = current_year - i
            year_df = base_df.copy()
            
            # Apply reverse growth + random variance
            factor = (1 - growth_rate) ** i
            noise = np.random.uniform(1 - variance, 1 + variance, len(year_df))
            
            # Apply to numeric columns
            numeric_cols = year_df.select_dtypes(include=[np.number]).columns
            for col in numeric_cols:
                if 'id' not in col.lower() and 'year' not in col.lower():
                    year_df[col] = year_df[col] * factor * noise
            
            historical[year] = year_df
        
        historical[current_year] = current_data
        return historical
    
    @staticmethod
    def calculate_yoy_variance(current: float, prior: float) -> Dict[str, float]:
        """Calculate YoY variance metrics"""
        if prior == 0:
            return {'dollar_variance': current, 'pct_variance': 0, 'prior': 0, 'current': current}
        
        dollar_var = current - prior
        pct_var = (dollar_var / abs(prior)) * 100
        
        return {
            'dollar_variance': dollar_var,
            'pct_variance': pct_var,
            'prior': prior,
            'current': current
        }
    
    @staticmethod
    def create_yoy_comparison_df(data_by_year: Dict[int, pd.DataFrame], 
                                  value_column: str,
                                  group_by: str = None) -> pd.DataFrame:
        """
        Create a YoY comparison DataFrame
        
        Args:
            data_by_year: Dictionary of {year: DataFrame}
            value_column: Column to compare
            group_by: Optional column to group by
        
        Returns:
            DataFrame with years as columns
        """
        years = sorted(data_by_year.keys())
        
        if group_by:
            result_data = []
            
            # Get all unique groups
            all_groups = set()
            for year, df in data_by_year.items():
                if group_by in df.columns:
                    all_groups.update(df[group_by].unique())
            
            for group in all_groups:
                row = {group_by: group}
                for year in years:
                    df = data_by_year[year]
                    if group_by in df.columns and value_column in df.columns:
                        value = df[df[group_by] == group][value_column].sum()
                        row[str(year)] = value
                    else:
                        row[str(year)] = 0
                result_data.append(row)
            
            result = pd.DataFrame(result_data)
        else:
            result_data = {}
            for year in years:
                df = data_by_year[year]
                if value_column in df.columns:
                    result_data[str(year)] = [df[value_column].sum()]
                else:
                    result_data[str(year)] = [0]
            result = pd.DataFrame(result_data)
        
        # Add variance columns
        if len(years) >= 2:
            current_year = str(years[-1])
            prior_year = str(years[-2])
            
            result['YoY_$_Var'] = result[current_year] - result[prior_year]
            result['YoY_%_Var'] = np.where(
                result[prior_year] != 0,
                (result['YoY_$_Var'] / result[prior_year].abs()) * 100,
                0
            ).round(1)
        
        return result


# =============================================================================
# PAGE CONFIGURATION
# =============================================================================

st.set_page_config(
    page_title="Enterprise Budget & Forecasting Platform",
    page_icon="",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for enterprise look
st.markdown("""
<style>
    /* Main header styling */
    .main-header {
        font-size: 2.5rem;
        font-weight: 700;
        color: #1e3a5f;
        margin-bottom: 0.5rem;
    }
    .sub-header {
        font-size: 1.1rem;
        color: #6b7280;
        margin-bottom: 2rem;
    }
    
    /* KPI Cards */
    .kpi-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 12px;
        padding: 1.5rem;
        color: white;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .kpi-value {
        font-size: 2rem;
        font-weight: 700;
    }
    .kpi-label {
        font-size: 0.875rem;
        opacity: 0.9;
    }
    .kpi-delta-positive {
        color: #10b981;
        font-size: 0.875rem;
    }
    .kpi-delta-negative {
        color: #ef4444;
        font-size: 0.875rem;
    }
    
    /* Variance indicators */
    .variance-favorable {
        color: #10b981;
        font-weight: 600;
    }
    .variance-unfavorable {
        color: #ef4444;
        font-weight: 600;
    }
    
    /* Status badges */
    .status-draft {
        background-color: #fef3c7;
        color: #92400e;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        font-size: 0.75rem;
        font-weight: 600;
    }
    .status-approved {
        background-color: #d1fae5;
        color: #065f46;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        font-size: 0.75rem;
        font-weight: 600;
    }
    .status-locked {
        background-color: #e5e7eb;
        color: #374151;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        font-size: 0.75rem;
        font-weight: 600;
    }
    
    /* Table styling */
    .dataframe {
        font-size: 0.875rem;
    }
    
    /* Sidebar styling */
    .css-1d391kg {
        background-color: #f8fafc;
    }
    
    /* Hide Streamlit branding */
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    
    /* Card container */
    .metric-container {
        background-color: #ffffff;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    /* Section headers */
    .section-header {
        font-size: 1.1rem;
        font-weight: 600;
        color: #1f2937;
        border-bottom: 2px solid #3b82f6;
        padding-bottom: 0.5rem;
        margin-bottom: 1rem;
    }
</style>
""", unsafe_allow_html=True)

# =============================================================================
# CONSTANTS
# =============================================================================

MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
QUARTERS = {'Q1': ['Jan', 'Feb', 'Mar'], 'Q2': ['Apr', 'May', 'Jun'], 
            'Q3': ['Jul', 'Aug', 'Sep'], 'Q4': ['Oct', 'Nov', 'Dec']}

VERSION_TYPES = ['Budget', 'Forecast', 'Actual', 'Plan', 'Stretch']
VERSION_STATUSES = ['Working', 'Draft', 'In Review', 'Submitted', 'Locked', 'Approved']
SCENARIO_TYPES = ['Base', 'Best Case', 'Worst Case', 'Stretch', 'Conservative']

ACCOUNT_TYPES = ['Revenue', 'Cost of Sales', 'Operating Expense', 'Other Income', 
                 'Other Expense', 'Tax', 'Asset', 'Liability', 'Equity']

EXPENSE_CATEGORIES = [
    'Salaries & Wages', 'Benefits', 'Bonus & Incentives', 'Contractors',
    'Travel & Entertainment', 'Professional Services', 'Software & Subscriptions',
    'Marketing & Advertising', 'Facilities & Rent', 'Utilities', 'Insurance',
    'Depreciation', 'Amortization', 'Interest', 'Other Operating', 'Intercompany'
]

REVENUE_TYPES = ['New Business', 'Expansion', 'Renewal', 'Services', 'Other']

# Color schemes
COLORS = {
    'primary': '#1e3a5f',
    'secondary': '#3b82f6',
    'success': '#10b981',
    'warning': '#f59e0b',
    'danger': '#ef4444',
    'info': '#6366f1',
    'light': '#f3f4f6',
    'dark': '#1f2937'
}

# =============================================================================
# SESSION STATE INITIALIZATION
# =============================================================================

def init_session_state():
    """Initialize all session state variables"""
    defaults = {
        # Database
        'db_config': {'enabled': False, 'host': 'localhost', 'port': 5432, 
                      'database': 'budget_forecast_db', 'user': '', 'password': ''},
        'db_connected': False,
        
        # Current user (for workflow/approvals)
        'current_user': {
            'email': 'demo.user@company.com',
            'name': 'Demo User',
            'role': 'finance_manager',
            'department': 'Finance',
            'can_approve': True
        },
        
        # Organization structure
        'entities': {},
        'cost_centers': {},
        'chart_of_accounts': {},
        'org_departments': pd.DataFrame(),  # Department lookup table from ES_Departments.xlsx
        'org_accounts': pd.DataFrame(),  # Account lookup table from ES_Accounts.xlsx
        
        # Budget data
        'budget_versions': {},
        'current_version': None,
        'budget_data': pd.DataFrame(),
        'budget_data_enhanced': pd.DataFrame(),
        'actuals_data': pd.DataFrame(),
        'saved_budget_versions': {},  # Saved budget versions from Direct Entry and Templates
        'corporate_budget_versions': {
            'FY2025-Corporate-Budget': {
                'name': 'FY2025 Corporate Budget',
                'fiscal_year': 2025,
                'status': 'Approved',
                'description': 'Standard corporate budget version for FY2025',
                'created_date': datetime.now().isoformat(),
                'created_by': 'System',
                'contributors': {},
                'total_budget': 0
            }
        },  # Corporate rollup versions that aggregate department budgets
        
        # Direct Entry dialog flags
        'de_show_load_dialog': False,
        'de_show_save_dialog': False,
        'de_save_dialog_opened': False,
        
        # Workforce planning
        'headcount_plan': pd.DataFrame(),
        'positions': {},
        'compensation_assumptions': {},
        
        # Revenue planning
        'revenue_plan': pd.DataFrame(),
        'customers': {},
        'products': {},
        
        # Contract Management
        'contract_data': pd.DataFrame(),
        'contracts': {},
        
        # Cash Flow
        'cash_flow_data': pd.DataFrame(),
        
        # CapEx Management
        'capex_projects': pd.DataFrame(),
        'capex_plan': pd.DataFrame(),
        'capital_assets': {},
        'capex_config': {
            'facilities': ['Kewaunee', 'Hittman', 'TMI-2', 'Bear Creek', 'LWP', 'Clive', 
                          'MHF Logistics', 'IT', 'Reactor D&D', 'Casks', 'Memphis', 'ESNS',
                          'ESWO', 'Erwin', 'Barnwell', 'MHF Packaging', 'ESFS', 'Facilities'],
            'divisions': ['D&D', 'WM', 'Corporate', 'Nuclear Services', 'ESFS'],
            'statuses': ['New', 'New - Special Purpose', 'Existing', 'Completed', 'On Hold', 'Cancelled'],
            'priorities': ['1 - High', '2 - Medium', '3 - Low'],
            'capex_classes': ['Compliance Required', 'Growth', '2024 Carry over', 
                             'Approved but not started', 'Other'],
            'payment_methods': ['Cash', 'Capital Lease', 'Non-Cash', 'NDT'],
            'types': ['Capital Expenditure', 'Capital Lease', 'Non-Cash'],
            'reasons': ['Facility/Maintenance/Replacement', 'Customer Funded', 'Growth',
                       'Special Needs', 'PCs/End-User Devices', 'Compliance']
        },
        
        # Drivers & KPIs
        'planning_drivers': {},
        'driver_values': pd.DataFrame(),
        'kpi_definitions': {},
        'kpi_targets': {},
        
        # Templates
        'templates': {},
        
        # Workflows & Approvals
        'workflow_engine': None,
        'pending_approvals': [],
        'my_submissions': [],
        
        # AI Assistant
        'ai_assistant': None,
        'ai_config': {
            'provider': None,
            'api_key': None,
            'model': None
        },
        'ai_chat_history': [],
        
        # Historical Data (Year-over-Year)
        'historical_data': {
            'budget': {},
            'capex': {},
            'contracts': {},
            'cashflow': {},
            'headcount': {}
        },
        'planning_year': datetime.now().year + 1,
        
        # UI State
        'selected_entity': None,
        'selected_cost_center': None,
        'selected_fiscal_year': datetime.now().year,
        'comparison_version': None,
        
        # Filters
        'global_filters': {
            'entity': [],
            'cost_center': [],
            'account_type': [],
            'period': []
        }
    }
    
    for key, value in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = value
    
    # Initialize workflow engine and notification service
    if st.session_state.workflow_engine is None:
        st.session_state.workflow_engine = WorkflowEngine()
    
    # Initialize AI Assistant
    if st.session_state.ai_assistant is None:
        st.session_state.ai_assistant = AIAssistant()

init_session_state()

# =============================================================================
# DATABASE FUNCTIONS
# =============================================================================

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def format_currency(value, decimals=0):
    """Format number as currency"""
    if pd.isna(value):
        return "$0"
    if abs(value) >= 1e9:
        return f"${value/1e9:.1f}B"
    elif abs(value) >= 1e6:
        return f"${value/1e6:.1f}M"
    elif abs(value) >= 1e3:
        return f"${value/1e3:.1f}K"
    else:
        return f"${value:,.{decimals}f}"


def get_quarter(month):
    """Get quarter from month number"""
    return f"Q{(month - 1) // 3 + 1}"


# =============================================================================
# SAMPLE DATA GENERATION
# =============================================================================

def generate_sample_data():
    """Generate comprehensive EnergySolutions sample data for demonstration"""
    
    current_year = datetime.now().year
    current_month = datetime.now().month
    np.random.seed(42)
    
    # EnergySolutions Facilities
    facilities = ['Kewaunee', 'TMI-2', 'Bear Creek', 'Clive', 'Hittman', 'LWP', 'Memphis', 'Erwin', 'Barnwell', 'MHF Logistics']
    divisions = ['D&D', 'WM', 'Corporate', 'Nuclear Services', 'ESFS']
    
    # Entities
    st.session_state.entities = {
        'CORP': {'name': 'EnergySolutions Corporate', 'type': 'holding', 'currency': 'USD'},
        'D&D': {'name': 'Decommissioning & Demolition', 'type': 'division', 'currency': 'USD', 'parent': 'CORP'},
        'WM': {'name': 'Waste Management', 'type': 'division', 'currency': 'USD', 'parent': 'CORP'},
        'NS': {'name': 'Nuclear Services', 'type': 'division', 'currency': 'USD', 'parent': 'CORP'},
        'ESFS': {'name': 'ESFS Division', 'type': 'division', 'currency': 'USD', 'parent': 'CORP'},
    }
    
    # Cost Centers by Facility
    st.session_state.cost_centers = {}
    cc_id = 1000
    for fac in facilities:
        st.session_state.cost_centers[str(cc_id)] = {'name': fac, 'entity': 'D&D' if fac in ['Kewaunee', 'TMI-2'] else 'WM', 'level': 0}
        cc_id += 100
    
    # Budget Versions
    st.session_state.budget_versions = {
        f'{current_year}-BUD-V1': {'name': f'FY{current_year} Annual Budget', 'type': 'Budget', 'status': 'Approved', 'scenario': 'Base', 'is_primary': True, 'fiscal_year': current_year},
        f'{current_year}-FC-Q1': {'name': f'FY{current_year} Q1 Forecast', 'type': 'Forecast', 'status': 'Locked', 'scenario': 'Base', 'fiscal_year': current_year},
        f'{current_year}-FC-Q2': {'name': f'FY{current_year} Q2 Forecast', 'type': 'Forecast', 'status': 'Draft', 'scenario': 'Base', 'fiscal_year': current_year},
    }
    st.session_state.current_version = f'{current_year}-BUD-V1'
    
    # Saved budget versions from Direct Entry and Templates
    # Format: {'version_id': {'name': str, 'data': DataFrame, 'source': 'direct_entry'|'template', 'created': datetime, 'fiscal_year': int}}
    # Only initialize if not already exists (to preserve saved versions)
    if 'saved_budget_versions' not in st.session_state:
        st.session_state.saved_budget_versions = {}
    
    # Corporate budget versions - rollups that aggregate department budgets
    if 'corporate_budget_versions' not in st.session_state:
        st.session_state.corporate_budget_versions = {}
    
    # =========================================================================
    # BUDGET DATA - EnergySolutions Style with Account Categories
    # =========================================================================
    budget_rows = []
    
    # Account categories typical for nuclear services
    account_categories = {
        'Labor': {'base_pct': 0.40, 'variance_range': (-0.05, 0.08)},
        'Fringe': {'base_pct': 0.12, 'variance_range': (-0.02, 0.04)},
        'Subcontracts': {'base_pct': 0.20, 'variance_range': (-0.10, 0.15)},
        'Travel': {'base_pct': 0.03, 'variance_range': (-0.15, 0.25)},
        'Materials': {'base_pct': 0.10, 'variance_range': (-0.08, 0.12)},
        'Equipment': {'base_pct': 0.05, 'variance_range': (-0.05, 0.10)},
        'Professional Services': {'base_pct': 0.04, 'variance_range': (-0.10, 0.20)},
        'Overhead': {'base_pct': 0.06, 'variance_range': (-0.02, 0.03)},
    }
    
    # Facility budgets (annual, in millions)
    facility_budgets = {
        'Kewaunee': 85, 'TMI-2': 120, 'Bear Creek': 45, 'Clive': 65, 'Hittman': 30,
        'LWP': 25, 'Memphis': 40, 'Erwin': 35, 'Barnwell': 50, 'MHF Logistics': 20
    }
    
    for facility, annual_budget in facility_budgets.items():
        monthly_budget = annual_budget * 1_000_000 / 12
        
        for month_idx, month in enumerate(MONTHS):
            # Seasonality factor
            seasonality = 1 + 0.1 * np.sin(2 * np.pi * (month_idx - 2) / 12)
            
            for category, params in account_categories.items():
                cat_budget = monthly_budget * params['base_pct'] * seasonality
                
                # Generate actuals only for past months
                if month_idx < current_month:
                    var_pct = np.random.uniform(*params['variance_range'])
                    actual = cat_budget * (1 + var_pct)
                else:
                    actual = 0
                
                # Forecast is budget adjusted for known trends
                forecast = cat_budget * np.random.uniform(0.98, 1.05)
                
                budget_rows.append({
                    'Version': f'{current_year}-BUD-V1',
                    'Entity': 'D&D' if facility in ['Kewaunee', 'TMI-2', 'Bear Creek'] else 'WM',
                    'Cost Center': facility,
                    'Cost Center Name': facility,
                    'Account': category,
                    'Account Name': category,
                    'Account_Category': category,
                    'Month': month,
                    'Month_Num': month_idx + 1,
                    'Budget': round(cat_budget, 0),
                    'Actual': round(actual, 0),
                    'Forecast': round(forecast, 0),
                    'Prior_Year': round(cat_budget * 0.92, 0),
                    'Division': 'D&D' if facility in ['Kewaunee', 'TMI-2', 'Bear Creek'] else 'WM',
                    'Facility': facility
                })
    
    st.session_state.budget_data = pd.DataFrame(budget_rows)
    
    # =========================================================================
    # CONTRACT DATA - DOE and Utility Contracts
    # =========================================================================
    contract_rows = []
    customers = ['DOE', 'Dominion Energy', 'Duke Energy', 'Entergy', 'Exelon', 'Southern Company', 'TVA', 'Xcel Energy', 'FirstEnergy', 'PSEG']
    contract_types = ['Cost Plus', 'Fixed Price', 'T&M', 'IDIQ', 'Cost Reimbursable']
    project_types = ['D&D', 'Waste Processing', 'Characterization', 'Transport', 'LLRW Disposal', 'ISFSI', 'Remediation']
    
    for i in range(30):
        contract_value = np.random.uniform(5, 150) * 1000000
        pct_complete = np.random.uniform(0.10, 0.95)
        
        # Cost variance (some over, some under)
        cost_variance = np.random.uniform(-0.08, 0.15)
        cost_to_date = contract_value * pct_complete * (1 + cost_variance)
        
        # Fee based on contract type
        fee_pct = np.random.uniform(6, 12) if 'Cost' in np.random.choice(contract_types) else np.random.uniform(12, 20)
        revenue_to_date = cost_to_date * (1 + fee_pct/100)
        
        facility = np.random.choice(facilities)
        
        contract_rows.append({
            'Contract_ID': f'ES-{current_year-np.random.randint(0,3)}-{i+1:04d}',
            'Contract_Name': f'{facility} - {np.random.choice(project_types)} Project',
            'Customer': np.random.choice(customers),
            'Contract_Type': np.random.choice(contract_types),
            'Status': np.random.choice(['Active', 'Active', 'Active', 'Closeout', 'Pending', 'Complete']),
            'Contract_Value': round(contract_value, 0),
            'Funded_Value': round(contract_value * np.random.uniform(0.6, 1.0), 0),
            'Cost_To_Date': round(cost_to_date, 0),
            'Revenue_To_Date': round(revenue_to_date, 0),
            'Percent_Complete': round(pct_complete * 100, 1),
            'EAC': round(contract_value * (1 + np.random.uniform(-0.05, 0.12)), 0),
            'ETC': round(contract_value * (1 - pct_complete) * np.random.uniform(0.95, 1.10), 0),
            'Fee_Percentage': round(fee_pct, 1),
            'Margin_Actual': round((revenue_to_date - cost_to_date) / revenue_to_date * 100, 1) if revenue_to_date > 0 else 0,
            'Start_Date': datetime(current_year - np.random.randint(0, 3), np.random.randint(1, 13), 1).strftime('%Y-%m-%d'),
            'End_Date': datetime(current_year + np.random.randint(1, 5), np.random.randint(1, 13), 28).strftime('%Y-%m-%d'),
            'PM': f'PM-{np.random.randint(100, 200)}',
            'Division': np.random.choice(divisions[:4]),
            'Facility': facility,
            'Risk_Rating': np.random.choice(['Low', 'Medium', 'Medium', 'High']),
            'Award_Type': np.random.choice(['Competitive', 'Sole Source', 'Task Order'])
        })
    
    st.session_state.contract_data = pd.DataFrame(contract_rows)
    
    # =========================================================================
    # CASH FLOW DATA - 13 Week Forecast
    # =========================================================================
    cash_flow_rows = []
    starting_balance = 52_000_000  # $52M starting cash
    current_balance = starting_balance
    
    for week in range(13):
        week_date = datetime.now() + timedelta(weeks=week)
        
        # Inflows
        ar_collections = np.random.uniform(12, 22) * 1000000
        milestone_payments = np.random.uniform(2, 8) * 1000000 if week % 3 == 0 else np.random.uniform(0, 2) * 1000000
        retainage_releases = np.random.uniform(0, 1.5) * 1000000
        other_inflows = np.random.uniform(0.1, 0.8) * 1000000
        total_inflows = ar_collections + milestone_payments + retainage_releases + other_inflows
        
        # Outflows
        payroll = 5_200_000 if week % 2 == 0 else 0  # Bi-weekly payroll ~$5.2M
        vendor_payments = np.random.uniform(3, 8) * 1000000
        subcontractor_payments = np.random.uniform(2, 6) * 1000000
        insurance_taxes = np.random.uniform(0.5, 1.5) * 1000000 if week == 0 else np.random.uniform(0.1, 0.3) * 1000000
        capex_payments = np.random.uniform(0.3, 1.2) * 1000000
        debt_service = 1_500_000 if week == 4 else 0
        other_outflows = np.random.uniform(0.2, 0.6) * 1000000
        total_outflows = payroll + vendor_payments + subcontractor_payments + insurance_taxes + capex_payments + debt_service + other_outflows
        
        net_change = total_inflows - total_outflows
        ending_balance = current_balance + net_change
        
        cash_flow_rows.append({
            'Week': week + 1,
            'Week_Number': week + 1,
            'Week_Start': week_date - timedelta(days=6),
            'Week_End': week_date,
            'Week_Ending': week_date.strftime('%Y-%m-%d'),
            'Beginning_Balance': round(current_balance, 0),
            'AR_Collections': round(ar_collections, 0),
            'Customer_Receipts': round(ar_collections, 0),
            'Milestone_Payments': round(milestone_payments, 0),
            'NDT_Draws': round(retainage_releases, 0),
            'Retainage_Releases': round(retainage_releases, 0),
            'Other_Inflows': round(other_inflows, 0),
            'Other_Receipts': round(other_inflows, 0),
            'Total_Inflows': round(total_inflows, 0),
            'Payroll': round(payroll, 0),
            'Vendor_Payments': round(vendor_payments, 0),
            'Subcontractor': round(subcontractor_payments, 0),
            'Subcontractor_Payments': round(subcontractor_payments, 0),
            'Insurance_Taxes': round(insurance_taxes, 0),
            'Taxes': round(insurance_taxes, 0),
            'CapEx_Payments': round(capex_payments, 0),
            'Debt_Service': round(debt_service, 0),
            'Other_Outflows': round(other_outflows, 0),
            'Other_Payments': round(other_outflows, 0),
            'Total_Outflows': round(total_outflows, 0),
            'Net_Change': round(net_change, 0),
            'Ending_Balance': round(ending_balance, 0),
            'Min_Balance_Target': 25_000_000,
            'Variance_to_Target': round(ending_balance - 25_000_000, 0),
            'Status': 'Actual' if week < 44 else 'Forecast'
        })
        
        current_balance = ending_balance
    
    st.session_state.cash_flow_data = pd.DataFrame(cash_flow_rows)
    
    # =========================================================================
    # CAPEX PROJECTS
    # =========================================================================
    capex_rows = []
    capex_types = ['Compliance Required', 'Growth', 'Maintenance', 'Technology', 'Safety', 'Fleet', 'Facility Upgrade']
    
    capex_projects = [
        ('Kewaunee Crane Replacement', 'Kewaunee', 2_800_000, 'Safety'),
        ('TMI-2 Cask Loading System', 'TMI-2', 4_500_000, 'Compliance Required'),
        ('Clive Cell Construction', 'Clive', 8_200_000, 'Growth'),
        ('Bear Creek Monitoring Wells', 'Bear Creek', 1_200_000, 'Compliance Required'),
        ('Fleet Vehicle Replacement', 'Corporate', 3_500_000, 'Fleet'),
        ('IT Infrastructure Upgrade', 'Corporate', 2_100_000, 'Technology'),
        ('Memphis Facility HVAC', 'Memphis', 950_000, 'Maintenance'),
        ('Hittman Lab Equipment', 'Hittman', 1_800_000, 'Technology'),
        ('LWP Compactor System', 'LWP', 2_400_000, 'Growth'),
        ('Erwin Safety Systems', 'Erwin', 1_600_000, 'Safety'),
        ('Barnwell Monitoring System', 'Barnwell', 890_000, 'Compliance Required'),
        ('MHF Transport Containers', 'MHF Logistics', 3_200_000, 'Growth'),
        ('Kewaunee Fuel Pool Equipment', 'Kewaunee', 5_100_000, 'Compliance Required'),
        ('TMI-2 Waste Processing', 'TMI-2', 3_800_000, 'Growth'),
        ('Corporate ERP Upgrade', 'Corporate', 4_200_000, 'Technology'),
        ('Clive Radiation Monitoring', 'Clive', 1_400_000, 'Compliance Required'),
        ('Bear Creek Remediation Equip', 'Bear Creek', 2_600_000, 'Compliance Required'),
        ('Memphis Dock Expansion', 'Memphis', 1_900_000, 'Growth'),
        ('Security System Upgrade', 'Corporate', 1_100_000, 'Safety'),
        ('Backup Generator System', 'Kewaunee', 2_300_000, 'Safety'),
    ]
    
    for i, (name, facility, budget, proj_type) in enumerate(capex_projects):
        pct_spent = np.random.uniform(0.05, 0.85)
        status = np.random.choice(['In Progress', 'In Progress', 'Approved', 'Planning', 'On Hold']) if pct_spent < 0.95 else 'Completed'
        approval = 'Approved' if status in ['In Progress', 'Completed', 'Approved'] else np.random.choice(['Pending', 'Under Review', 'Approved'])
        
        capex_rows.append({
            'Project_ID': f'CAPEX-{current_year}-{i+1:03d}',
            'Project_Name': name,
            'Facility': facility,
            'Division': 'D&D' if facility in ['Kewaunee', 'TMI-2', 'Bear Creek'] else 'WM' if facility != 'Corporate' else 'Corporate',
            'Type': proj_type,
            'Status': status,
            'Approval_Status': approval,
            'Priority': np.random.choice(['1 - High', '2 - Medium', '3 - Low']),
            'Budget_2025': budget,
            'Spent_To_Date': round(budget * pct_spent, 0),
            'Committed': round(budget * pct_spent * 0.15, 0),
            'Remaining': round(budget * (1 - pct_spent), 0),
            'Percent_Complete': round(pct_spent * 100, 1),
            'Start_Date': datetime(current_year, np.random.randint(1, 6), 1).strftime('%Y-%m-%d'),
            'Target_Completion': datetime(current_year, np.random.randint(8, 13), 28).strftime('%Y-%m-%d'),
            'Project_Manager': f'PM-{np.random.randint(100, 200)}',
            'Justification': np.random.choice(['Regulatory requirement', 'Cost savings', 'Capacity expansion', 'End of life', 'Safety improvement']),
            'ROI_Expected': round(np.random.uniform(8, 25), 1) if proj_type not in ['Compliance Required', 'Safety'] else 0
        })
    
    st.session_state.capex_projects = pd.DataFrame(capex_rows)
    
    # =========================================================================
    # RESOURCE DATA
    # =========================================================================
    resource_rows = []
    roles = ['Project Manager', 'Health Physicist', 'Radiation Protection Tech', 'D&D Engineer', 
             'Waste Engineer', 'QA Specialist', 'Safety Officer', 'Chemist', 'Operator', 
             'Craft Worker', 'Site Supervisor', 'Cost Analyst', 'Scheduler']
    
    for i in range(75):
        facility = np.random.choice(facilities)
        utilization = np.random.uniform(0.70, 0.98)
        bill_rate = np.random.uniform(85, 225)
        
        resource_rows.append({
            'Employee_ID': f'ES-{1000 + i}',
            'Name': f'Employee {1000 + i}',
            'Role': np.random.choice(roles),
            'Department': np.random.choice(['D&D Operations', 'WM Operations', 'Engineering', 'EHS', 'QA', 'Project Controls']),
            'Facility': facility,
            'Division': 'D&D' if facility in ['Kewaunee', 'TMI-2', 'Bear Creek'] else 'WM',
            'Status': np.random.choice(['Active', 'Active', 'Active', 'Active', 'On Leave', 'Training']),
            'Clearance_Level': np.random.choice(['Q', 'L', 'None', 'Q']),
            'Utilization_Target': 0.85,
            'Utilization_Actual': round(utilization, 2),
            'Bill_Rate': round(bill_rate, 0),
            'Cost_Rate': round(bill_rate * 0.55, 0),
            'Hours_This_Month': round(176 * utilization, 0),
            'Billable_Hours': round(176 * utilization * 0.92, 0),
            'Overtime_Hours': round(np.random.uniform(0, 20), 0),
            'Current_Contract': f'ES-{current_year}-{np.random.randint(1, 31):04d}',
            'Certifications': np.random.randint(2, 8),
            'Years_Experience': np.random.randint(2, 25)
        })
    
    st.session_state.resource_data = pd.DataFrame(resource_rows)
    
    # =========================================================================
    # HEADCOUNT PLAN
    # =========================================================================
    headcount_rows = []
    emp_id = 2000
    
    for facility in facilities:
        num_employees = np.random.randint(15, 60)
        for _ in range(num_employees):
            role = np.random.choice(roles)
            salary = np.random.uniform(65000, 180000)
            
            headcount_rows.append({
                'Employee ID': f'ES-{emp_id}',
                'Name': f'Employee {emp_id}',
                'Position': role,
                'Department': 'D&D Operations' if facility in ['Kewaunee', 'TMI-2', 'Bear Creek'] else 'WM Operations',
                'Cost Center': facility,
                'Cost Center Name': facility,
                'Entity': 'D&D' if facility in ['Kewaunee', 'TMI-2', 'Bear Creek'] else 'WM',
                'Hire Date': datetime(current_year - np.random.randint(0, 8), np.random.randint(1, 13), 1).strftime('%Y-%m-%d'),
                'Annual Salary': round(salary, 0),
                'Bonus Target %': np.random.choice([10, 15, 20]),
                'FTE': 1.0,
                'Status': np.random.choice(['Active', 'Active', 'Active', 'Active', 'Planned Hire']),
            })
            emp_id += 1
    
    st.session_state.headcount_plan = pd.DataFrame(headcount_rows)
    
    # =========================================================================
    # KPI DEFINITIONS
    # =========================================================================
    st.session_state.kpi_definitions = {
        'revenue_growth': {'name': 'Revenue Growth', 'category': 'Financial', 'unit': '%', 'direction': 'higher', 'target': 8},
        'gross_margin': {'name': 'Gross Margin', 'category': 'Financial', 'unit': '%', 'direction': 'higher', 'target': 18},
        'ebitda_margin': {'name': 'EBITDA Margin', 'category': 'Financial', 'unit': '%', 'direction': 'higher', 'target': 12},
        'contract_margin': {'name': 'Avg Contract Margin', 'category': 'Contracts', 'unit': '%', 'direction': 'higher', 'target': 10},
        'utilization': {'name': 'Resource Utilization', 'category': 'Operations', 'unit': '%', 'direction': 'higher', 'target': 85},
        'safety_rate': {'name': 'TRIR (Safety)', 'category': 'Safety', 'unit': 'rate', 'direction': 'lower', 'target': 0.5},
        'on_time_delivery': {'name': 'On-Time Delivery', 'category': 'Operations', 'unit': '%', 'direction': 'higher', 'target': 95},
        'cash_conversion': {'name': 'Cash Conversion Cycle', 'category': 'Financial', 'unit': 'days', 'direction': 'lower', 'target': 45},
    }
    
    st.success(" EnergySolutions sample data loaded! Budget, Contracts, Cash Flow, CapEx, Resources, and Headcount data ready for analysis.")


# =============================================================================
# PROJECT CONTROLS DATA INITIALIZATION & HELPER FUNCTIONS
# =============================================================================

# Initialize project control session state variables globally
if 'projects_data' not in st.session_state:
    st.session_state.projects_data = pd.DataFrame()
if 'project_costs' not in st.session_state:
    st.session_state.project_costs = pd.DataFrame()
if 'project_schedule' not in st.session_state:
    st.session_state.project_schedule = pd.DataFrame()
if 'project_resources' not in st.session_state:
    st.session_state.project_resources = pd.DataFrame()
if 'project_risks' not in st.session_state:
    st.session_state.project_risks = pd.DataFrame()
if 'project_changes' not in st.session_state:
    st.session_state.project_changes = pd.DataFrame()
if 'project_forecast_data' not in st.session_state:
    st.session_state.project_forecast_data = pd.DataFrame()
if 'project_forecast_versions' not in st.session_state:
    st.session_state.project_forecast_versions = {}

# Initialize unified corporate versions with samples for each page type
if 'unified_corporate_versions' not in st.session_state:
    st.session_state.unified_corporate_versions = {
        'FY2025_Q1_BUDGET_PLANNING': {
            'name': 'FY2025 Q1 Budget',
            'page_type': 'Budget Planning',
            'description': 'Q1 2025 Department Budget Rollup',
            'fiscal_year': 2025,
            'status': 'Approved',
            'created': datetime.now() - timedelta(days=30),
            'created_by': 'Admin',
            'approved_date': datetime.now() - timedelta(days=15),
            'contributors': {
                'Operations': {
                    'data': pd.DataFrame({
                        'Category': ['Labor', 'Materials', 'Overhead'],
                        'Department': ['Operations', 'Operations', 'Operations'],
                        'Jan': [125000, 45000, 22000], 'Feb': [128000, 47000, 23000],
                        'Mar': [130000, 48000, 24000], 'Apr': [132000, 50000, 24000],
                        'May': [135000, 52000, 25000], 'Jun': [138000, 54000, 26000],
                        'Jul': [140000, 55000, 26000], 'Aug': [142000, 57000, 27000],
                        'Sep': [145000, 58000, 28000], 'Oct': [148000, 60000, 28000],
                        'Nov': [150000, 62000, 29000], 'Dec': [155000, 65000, 30000]
                    }),
                    'total': 2568000,
                    'saved_at': (datetime.now() - timedelta(days=20)).strftime('%Y-%m-%d %H:%M'),
                    'saved_by': 'J. Smith'
                },
                'Engineering': {
                    'data': pd.DataFrame({
                        'Category': ['Labor', 'Software', 'Travel'],
                        'Department': ['Engineering', 'Engineering', 'Engineering'],
                        'Jan': [180000, 25000, 8000], 'Feb': [182000, 25000, 9000],
                        'Mar': [185000, 26000, 10000], 'Apr': [188000, 26000, 10000],
                        'May': [190000, 27000, 11000], 'Jun': [192000, 27000, 12000],
                        'Jul': [195000, 28000, 10000], 'Aug': [198000, 28000, 11000],
                        'Sep': [200000, 29000, 12000], 'Oct': [202000, 29000, 12000],
                        'Nov': [205000, 30000, 13000], 'Dec': [210000, 30000, 14000]
                    }),
                    'total': 2862000,
                    'saved_at': (datetime.now() - timedelta(days=18)).strftime('%Y-%m-%d %H:%M'),
                    'saved_by': 'M. Johnson'
                }
            },
            'total_amount': 5430000
        },
        'FY2025_Q2_BUDGET_PLANNING': {
            'name': 'FY2025 Q2 Budget',
            'page_type': 'Budget Planning',
            'description': 'Q2 2025 Department Budget - In Progress',
            'fiscal_year': 2025,
            'status': 'Working',
            'created': datetime.now() - timedelta(days=5),
            'created_by': 'Admin',
            'contributors': {},
            'total_amount': 0
        },
        'FY2025_ANNUAL_BD_FORECASTING': {
            'name': 'FY2025 Annual BD Forecast',
            'page_type': 'BD Forecasting',
            'description': 'Annual BD Pipeline Forecast',
            'fiscal_year': 2025,
            'status': 'Submitted',
            'created': datetime.now() - timedelta(days=25),
            'created_by': 'Admin',
            'contributors': {
                'West Region': {
                    'data': pd.DataFrame({
                        'Division': ['BCO', 'BCO', 'FRO'],
                        'Subdiv': ['B-DAW', 'B-Metals', 'F-NFS'],
                        'Process': ['COMPACTION', 'LEAD - DECON', 'NFS Services'],
                        'Sector': ['Navy', 'Utility', 'DOE'],
                        'Jan': [150000, 85000, 120000], 'Feb': [155000, 88000, 125000],
                        'Mar': [160000, 90000, 130000], 'Apr': [165000, 92000, 135000],
                        'May': [170000, 95000, 140000], 'Jun': [175000, 98000, 145000],
                        'Jul': [180000, 100000, 150000], 'Aug': [185000, 102000, 155000],
                        'Sep': [190000, 105000, 160000], 'Oct': [195000, 108000, 165000],
                        'Nov': [200000, 110000, 170000], 'Dec': [205000, 115000, 175000]
                    }),
                    'total': 5835000,
                    'saved_at': (datetime.now() - timedelta(days=12)).strftime('%Y-%m-%d %H:%M'),
                    'saved_by': 'R. Williams'
                }
            },
            'total_amount': 5835000
        },
        'FY2025_Q1_BD_FORECASTING': {
            'name': 'FY2025 Q1 BD Forecast',
            'page_type': 'BD Forecasting',
            'description': 'Q1 BD Pipeline',
            'fiscal_year': 2025,
            'status': 'Locked',
            'created': datetime.now() - timedelta(days=60),
            'created_by': 'Admin',
            'approved_date': datetime.now() - timedelta(days=45),
            'locked_date': datetime.now() - timedelta(days=40),
            'contributors': {
                'Sales Team A': {
                    'data': pd.DataFrame({
                        'Division': ['BCO', 'FRO'],
                        'Subdiv': ['B-GIC', 'F-LLRW'],
                        'Process': ['GIC - LD', 'LLRW Disposal'],
                        'Sector': ['Utility', 'Industrial'],
                        'Jan': [200000, 175000], 'Feb': [210000, 180000],
                        'Mar': [220000, 185000], 'Apr': [0, 0],
                        'May': [0, 0], 'Jun': [0, 0],
                        'Jul': [0, 0], 'Aug': [0, 0],
                        'Sep': [0, 0], 'Oct': [0, 0],
                        'Nov': [0, 0], 'Dec': [0, 0]
                    }),
                    'total': 1170000,
                    'saved_at': (datetime.now() - timedelta(days=50)).strftime('%Y-%m-%d %H:%M'),
                    'saved_by': 'T. Brown'
                }
            },
            'total_amount': 1170000
        },
        'FY2025_PROJECT_CONTROLS': {
            'name': 'FY2025 Project Forecast',
            'page_type': 'Project Controls',
            'description': 'Annual Project Forecasts',
            'fiscal_year': 2025,
            'status': 'Working',
            'created': datetime.now() - timedelta(days=10),
            'created_by': 'Admin',
            'contributors': {},
            'total_amount': 0
        },
        'FY2025_Q1_PROJECT_CONTROLS': {
            'name': 'FY2025 Q1 Projects',
            'page_type': 'Project Controls',
            'description': 'Q1 Project Cost & Revenue Forecast',
            'fiscal_year': 2025,
            'status': 'Approved',
            'created': datetime.now() - timedelta(days=45),
            'created_by': 'Admin',
            'approved_date': datetime.now() - timedelta(days=30),
            'contributors': {
                'D&D Projects': {
                    'data': pd.DataFrame({
                        'Project_ID': ['PRJ-001', 'PRJ-002'],
                        'Project_Name': ['TMI-2 D&D Phase 3', 'Kewaunee SAFSTOR'],
                        'Cost_Jan': [450000, 320000], 'Cost_Feb': [465000, 335000],
                        'Cost_Mar': [480000, 350000], 'Revenue_Jan': [520000, 370000],
                        'Revenue_Feb': [538000, 388000], 'Revenue_Mar': [555000, 405000]
                    }),
                    'total': 3545000,
                    'saved_at': (datetime.now() - timedelta(days=35)).strftime('%Y-%m-%d %H:%M'),
                    'saved_by': 'K. Davis'
                }
            },
            'total_amount': 3545000
        }
    }


# =============================================================================
# NAVIGATION SIDEBAR
# =============================================================================

with st.sidebar:
    # CSS for compact navigation buttons
    st.markdown("""
    <style>
    /* Make sidebar nav buttons more compact */
    [data-testid="stSidebar"] button {
        padding: 0.25rem 0.5rem !important;
        font-size: 1.1rem !important;
        margin-bottom: 2px !important;
    }
    [data-testid="stSidebar"] button[kind="secondary"] {
        background-color: transparent !important;
        border: none !important;
        color: #374151 !important;
        text-align: left !important;
    }
    [data-testid="stSidebar"] button[kind="secondary"]:hover {
        background-color: #f3f4f6 !important;
    }
    [data-testid="stSidebar"] button[kind="primary"] {
        background-color: #00843D !important;
        border: none !important;
        color: white !important;
        text-align: left !important;
        font-weight: 600 !important;
    }
    [data-testid="stSidebar"] button[kind="primary"]:hover {
        background-color: #006633 !important;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # st.markdown("""
    # <div style='text-align: center; padding: 1rem 0;'>
    #     <img src='https://cna.ca/wp-content/uploads/2018/09/Energy-Solutions-logo.png' style='max-width: 180px; margin-bottom: 5px;'>
    #     <p style='color: #6b7280; font-size: 0.75rem; margin: 0;'>Enterprise Planning Platform</p>
    # </div>
    # """, unsafe_allow_html=True)
    
    #st.markdown("---")
    
    # Show pending approvals count
    workflow_engine = st.session_state.workflow_engine
    pending_count = len(workflow_engine.get_pending_approvals()) if workflow_engine else 0
    
    # Initialize current page in session state
    if 'current_page' not in st.session_state:
        st.session_state.current_page = " Home"
    
    # Initialize collapsed state for categories
    if 'nav_collapsed' not in st.session_state:
        st.session_state.nav_collapsed = {}
    
    # Initialize home KPI detail panel state
    if 'home_kpi_detail' not in st.session_state:
        st.session_state.home_kpi_detail = None
    
    # Define all pages with categories
    approval_label = f" Approvals {'' if pending_count > 0 else ''}"
    
    all_pages = [
        (" Home", [
            " Home"
        ]),
        (" Executive Overview", [
            " Executive Dashboard",
            " Executive KPIs"
        ]),
        (" Planning", [
            " Budget Planning",
            " CapEx Management",
            " Labor/Resource Planning",
            " Purchasing",
            " Project Controls",
            " Revenue Planning",
            " Cash Flow",
            " Workforce Planning"
        ]),
        (" Forecasting", [
            " BD Forecasting",
            " Corporate Finance",
        ]),
        (" Analysis & Reporting", [
            " Variance Analysis",
            " Reports & Analytics"
        ]),
        (" AI", [
            " AI Assistant",
            " AI Agents"
        ]),
        (" Administration", [
            approval_label,
            " Templates",
            " Settings"
        ])
    ]
    
    # Custom CSS for compact navigation with expanders
    st.markdown("""
    <style>
    /* Reduce vertical spacing between elements */
    section[data-testid="stSidebar"] [data-testid="stVerticalBlockBorderWrapper"] {
        gap: 0rem;
    }
    /* Style expander headers - left aligned, smaller, bold italic */
    section[data-testid="stSidebar"] [data-testid="stExpander"] {
        border: none !important;
        background: transparent !important;
    }
    section[data-testid="stSidebar"] [data-testid="stExpander"] summary {
        font-size: 0.8rem !important;
        font-weight: bold !important;
        font-style: italic !important;
        color: #222 !important;
        padding: 0.3rem 0 !important;
    }
    section[data-testid="stSidebar"] [data-testid="stExpander"] summary p {
        font-size: 0.8rem !important;
        font-weight: bold !important;
        font-style: italic !important;
        color: #222 !important;
    }
    /* Style page buttons - centered */
    section[data-testid="stSidebar"] button {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        padding: 0.25rem 0.5rem !important;
        margin: 0 !important;
        width: 100% !important;
    }
    section[data-testid="stSidebar"] button:hover {
        background: rgba(0,0,0,0.05) !important;
    }
    /* Center button content */
    section[data-testid="stSidebar"] [data-testid="stExpander"] button > div {
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        width: 100% !important;
    }
    section[data-testid="stSidebar"] [data-testid="stExpander"] button > div > div {
        display: flex !important;
        justify-content: center !important;
        width: 100% !important;
    }
    section[data-testid="stSidebar"] [data-testid="stExpander"] button p {
        text-align: center !important;
        width: 100% !important;
        display: block !important;
    }
    /* Remove expander border/padding */
    section[data-testid="stSidebar"] [data-testid="stExpander"] > details {
        border: none !important;
    }
    section[data-testid="stSidebar"] [data-testid="stExpander"] > details > div {
        padding: 0 !important;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Initialize nav_all_expanded state
    if 'nav_all_expanded' not in st.session_state:
        st.session_state.nav_all_expanded = False
    
    # Single Expand/Collapse All toggle
    toggle_label = " Collapse All" if st.session_state.nav_all_expanded else " Expand All"
    if st.button(toggle_label, key="toggle_all_nav"):
        st.session_state.nav_all_expanded = not st.session_state.nav_all_expanded
        st.rerun()
    
    # Render categorized navigation with expanders
    for category, pages in all_pages:
        # Home is rendered directly without expander
        if category == " Home":
            if st.button(" Home", key="nav_home_direct", use_container_width=True, type="primary" if st.session_state.current_page == " Home" else "secondary"):
                st.session_state.current_page = " Home"
                st.rerun()
            st.markdown("")
            continue
        
        # Default expansion state - expand if current page is in this category
        current_page = st.session_state.current_page
        page_keys = [(" Approvals" if p == approval_label else p) for p in pages]
        page_in_category = current_page in page_keys
        default_expanded = st.session_state.nav_all_expanded or page_in_category
        
        with st.expander(category, expanded=default_expanded):
            for page_name in pages:
                page_key = " Approvals" if page_name == approval_label else page_name
                
                # Highlight current page with primary button type
                is_current = st.session_state.current_page == page_key
                btn_type = "primary" if is_current else "secondary"
                
                if st.button(page_name, key=f"nav_{page_name}", use_container_width=True, type=btn_type):
                    st.session_state.current_page = page_key
                    st.rerun()
    
    # Get current page
    page = st.session_state.current_page
    
    st.markdown("---")
    
    # Quick filters (always visible)
    st.markdown("**Quick Filters**")
    
    # Fiscal Year selector
    current_year = datetime.now().year
    selected_year = st.selectbox(
        "Fiscal Year",
        [current_year - 1, current_year, current_year + 1],
        index=1,
        key="fiscal_year_filter"
    )
    st.session_state.selected_fiscal_year = selected_year
    
    # Version selector
    if st.session_state.budget_versions:
        version_options = [v for v, info in st.session_state.budget_versions.items() 
                         if info['fiscal_year'] == selected_year]
        if version_options:
            selected_version = st.selectbox(
                "Budget Version",
                version_options,
                format_func=lambda x: st.session_state.budget_versions[x]['name'],
                key="version_filter"
            )
            st.session_state.current_version = selected_version
    
    # Entity filter
    if st.session_state.entities:
        entity_options = ['All'] + list(st.session_state.entities.keys())
        selected_entity = st.selectbox(
            "Entity",
            entity_options,
            key="entity_filter"
        )
        st.session_state.selected_entity = None if selected_entity == 'All' else selected_entity
    
    st.markdown("---")
    
    # Connection status
    if st.session_state.db_connected:
        st.success(" Database Connected")
    else:
        st.warning(" Local Mode")


# =============================================================================
# PROJECT CONTROLS HELPER FUNCTIONS
# =============================================================================

def _generate_sample_projects():
    np.random.seed(42)
    
    projects = [
        {'Project_ID': 'ZION-D&D-001', 'Project_Name': 'Zion Nuclear D&D', 'Customer': 'DOE-EM', 
         'Contract_Type': 'Cost Plus', 'Status': 'Active', 'PM': 'John Smith',
         'Start_Date': '2023-01-15', 'End_Date': '2027-12-31', 'Department': '11300  ZionSolutions',
         'Contract_Value': 125000000, 'Funded_Value': 95000000, 'Fee_Rate': 0.08},
        {'Project_ID': 'LWP-OPS-001', 'Project_Name': 'Liquid Waste Processing', 'Customer': 'Commercial',
         'Contract_Type': 'Fixed Price', 'Status': 'Active', 'PM': 'Sarah Johnson',
         'Start_Date': '2024-03-01', 'End_Date': '2026-06-30', 'Department': '11100  LWP',
         'Contract_Value': 45000000, 'Funded_Value': 45000000, 'Fee_Rate': 0.12},
        {'Project_ID': 'KEW-D&D-002', 'Project_Name': 'Kewaunee Decommissioning', 'Customer': 'DOE-EM',
         'Contract_Type': 'Cost Plus', 'Status': 'Active', 'PM': 'Mike Davis',
         'Start_Date': '2022-06-01', 'End_Date': '2028-12-31', 'Department': '11200  Non Utiliy Projects',
         'Contract_Value': 185000000, 'Funded_Value': 142000000, 'Fee_Rate': 0.07},
        {'Project_ID': 'TMI-ISFSI-001', 'Project_Name': 'TMI-2 ISFSI Operations', 'Customer': 'DOE-NE',
         'Contract_Type': 'Time & Materials', 'Status': 'Active', 'PM': 'Lisa Chen',
         'Start_Date': '2024-01-01', 'End_Date': '2029-12-31', 'Department': '11308  ZS D&D and Engineering',
         'Contract_Value': 78000000, 'Funded_Value': 52000000, 'Fee_Rate': 0.10},
        {'Project_ID': 'WM-CLIVE-001', 'Project_Name': 'Clive Disposal Operations', 'Customer': 'Commercial',
         'Contract_Type': 'Fixed Price', 'Status': 'Active', 'PM': 'Robert Wilson',
         'Start_Date': '2023-07-01', 'End_Date': '2025-12-31', 'Department': '11109  LWP - DWM',
         'Contract_Value': 32000000, 'Funded_Value': 32000000, 'Fee_Rate': 0.15},
    ]
    
    projects_df = pd.DataFrame(projects)
    projects_df['Start_Date'] = pd.to_datetime(projects_df['Start_Date'])
    projects_df['End_Date'] = pd.to_datetime(projects_df['End_Date'])
    
    for idx, row in projects_df.iterrows():
        total_months = (row['End_Date'].year - row['Start_Date'].year) * 12 + (row['End_Date'].month - row['Start_Date'].month)
        elapsed_months = (datetime.now().year - row['Start_Date'].year) * 12 + (datetime.now().month - row['Start_Date'].month)
        pct_complete = min(max(elapsed_months / total_months * 100, 0), 100) if total_months > 0 else 0
        
        bac = row['Contract_Value'] * (1 - row['Fee_Rate'])
        eac = bac * np.random.uniform(0.95, 1.08)
        acwp = bac * (pct_complete / 100) * np.random.uniform(0.92, 1.05)
        bcwp = bac * (pct_complete / 100)
        bcws = bac * (pct_complete / 100) * np.random.uniform(0.95, 1.02)
        
        projects_df.at[idx, 'Pct_Complete'] = round(pct_complete, 1)
        projects_df.at[idx, 'BAC'] = round(bac, 0)
        projects_df.at[idx, 'EAC'] = round(eac, 0)
        projects_df.at[idx, 'ETC'] = round(eac - acwp, 0)
        projects_df.at[idx, 'ACWP'] = round(acwp, 0)
        projects_df.at[idx, 'BCWP'] = round(bcwp, 0)
        projects_df.at[idx, 'BCWS'] = round(bcws, 0)
        projects_df.at[idx, 'CV'] = round(bcwp - acwp, 0)
        projects_df.at[idx, 'SV'] = round(bcwp - bcws, 0)
        projects_df.at[idx, 'CPI'] = round(bcwp / acwp, 2) if acwp > 0 else 1.0
        projects_df.at[idx, 'SPI'] = round(bcwp / bcws, 2) if bcws > 0 else 1.0
        projects_df.at[idx, 'VAC'] = round(bac - eac, 0)
        
        projects_df.at[idx, 'Revenue_Recognized'] = round(acwp * (1 + row['Fee_Rate']), 0)
        projects_df.at[idx, 'Billed_Amount'] = round(projects_df.at[idx, 'Revenue_Recognized'] * np.random.uniform(0.95, 1.0), 0)
        projects_df.at[idx, 'Unbilled_Revenue'] = round(projects_df.at[idx, 'Revenue_Recognized'] - projects_df.at[idx, 'Billed_Amount'], 0)
    
    return projects_df

def _generate_project_costs(projects_df):
    cost_rows = []
    for _, proj in projects_df.iterrows():
        total_bac = proj['BAC']
        category_pcts = {'Labor': 0.45, 'Materials': 0.15, 'Subcontracts': 0.25, 
                        'Travel': 0.05, 'Equipment': 0.05, 'ODCs': 0.05}
        
        for cat, pct in category_pcts.items():
            for month in MONTHS:
                month_idx = MONTHS.index(month)
                monthly_pct = 1/12 * np.random.uniform(0.8, 1.2)
                budget_amt = total_bac * pct * monthly_pct
                actual_amt = budget_amt * np.random.uniform(0.85, 1.15)
                
                cost_rows.append({
                    'Project_ID': proj['Project_ID'],
                    'Project_Name': proj['Project_Name'],
                    'Cost_Category': cat,
                    'Month': month,
                    'Budget': round(budget_amt, 0),
                    'Actual': round(actual_amt, 0) if month_idx < datetime.now().month else 0,
                    'Forecast': round(budget_amt if month_idx >= datetime.now().month else actual_amt, 0),
                    'Variance': round(budget_amt - actual_amt, 0) if month_idx < datetime.now().month else 0
                })
    return pd.DataFrame(cost_rows)

def _generate_project_schedule(projects_df):
    schedule_rows = []
    for _, proj in projects_df.iterrows():
        milestones = [
            ('Mobilization', 0.05, 'Completed'),
            ('Design Complete', 0.15, 'Completed'),
            ('Procurement', 0.25, 'Completed' if proj['Pct_Complete'] > 25 else 'In Progress'),
            ('Construction Start', 0.30, 'Completed' if proj['Pct_Complete'] > 30 else 'In Progress'),
            ('50% Construction', 0.50, 'Completed' if proj['Pct_Complete'] > 50 else 'Not Started'),
            ('Systems Testing', 0.75, 'Completed' if proj['Pct_Complete'] > 75 else 'Not Started'),
            ('Commissioning', 0.90, 'Completed' if proj['Pct_Complete'] > 90 else 'Not Started'),
            ('Project Closeout', 1.0, 'Completed' if proj['Pct_Complete'] >= 100 else 'Not Started'),
        ]
        total_days = (proj['End_Date'] - proj['Start_Date']).days
        
        for ms_name, ms_pct, ms_status in milestones:
            planned_date = proj['Start_Date'] + pd.Timedelta(days=int(total_days * ms_pct))
            actual_date = planned_date + pd.Timedelta(days=np.random.randint(-15, 30)) if ms_status == 'Completed' else None
            
            schedule_rows.append({
                'Project_ID': proj['Project_ID'],
                'Project_Name': proj['Project_Name'],
                'Milestone': ms_name,
                'Planned_Date': planned_date,
                'Actual_Date': actual_date,
                'Status': ms_status,
                'Variance_Days': (actual_date - planned_date).days if actual_date else 0,
                'Pct_Timeline': ms_pct * 100
            })
    return pd.DataFrame(schedule_rows)

def _generate_project_resources(projects_df):
    resource_rows = []
    for _, proj in projects_df.iterrows():
        fte_counts = {'Project Manager': 1, 'Engineer': np.random.randint(3, 8), 
                     'Technician': np.random.randint(10, 25), 'Supervisor': np.random.randint(2, 5),
                     'Admin': np.random.randint(1, 3), 'Safety Officer': np.random.randint(1, 3)}
        
        for role, fte_count in fte_counts.items():
            avg_rate = {'Project Manager': 95, 'Engineer': 75, 'Technician': 55, 
                       'Supervisor': 70, 'Admin': 45, 'Safety Officer': 65}.get(role, 60)
            
            for month in MONTHS:
                planned_hrs = fte_count * 173 * np.random.uniform(0.9, 1.1)
                actual_hrs = planned_hrs * np.random.uniform(0.85, 1.15) if MONTHS.index(month) < datetime.now().month else 0
                
                resource_rows.append({
                    'Project_ID': proj['Project_ID'],
                    'Project_Name': proj['Project_Name'],
                    'Role': role,
                    'Month': month,
                    'Planned_FTE': fte_count,
                    'Planned_Hours': round(planned_hrs, 0),
                    'Actual_Hours': round(actual_hrs, 0),
                    'Avg_Rate': avg_rate,
                    'Planned_Cost': round(planned_hrs * avg_rate, 0),
                    'Actual_Cost': round(actual_hrs * avg_rate, 0)
                })
    return pd.DataFrame(resource_rows)

def _generate_project_risks(projects_df):
    risk_rows = []
    risk_templates = [
        ('Schedule Delay - Permitting', 'Schedule', 'Medium', 'High', 50000),
        ('Labor Shortage', 'Resource', 'High', 'Medium', 75000),
        ('Material Cost Increase', 'Cost', 'Medium', 'Medium', 30000),
        ('Scope Creep', 'Scope', 'High', 'High', 100000),
        ('Weather Delays', 'Schedule', 'Low', 'Medium', 25000),
        ('Subcontractor Performance', 'Performance', 'Medium', 'High', 60000),
        ('Regulatory Changes', 'Compliance', 'Low', 'High', 80000),
        ('Equipment Failure', 'Technical', 'Low', 'Medium', 40000),
    ]
    
    for _, proj in projects_df.iterrows():
        num_risks = np.random.randint(3, 6)
        selected_risks = np.random.choice(len(risk_templates), num_risks, replace=False)
        
        for risk_idx in selected_risks:
            risk_name, risk_type, prob, impact, cost_impact = risk_templates[risk_idx]
            risk_rows.append({
                'Project_ID': proj['Project_ID'],
                'Project_Name': proj['Project_Name'],
                'Risk_ID': f"R-{proj['Project_ID'][:4]}-{risk_idx+1:03d}",
                'Risk_Description': risk_name,
                'Risk_Type': risk_type,
                'Probability': prob,
                'Impact': impact,
                'Cost_Impact': cost_impact * np.random.uniform(0.8, 1.5),
                'Status': np.random.choice(['Open', 'Mitigated', 'Closed'], p=[0.5, 0.3, 0.2]),
                'Owner': proj['PM'],
                'Mitigation': f"Implement {risk_type.lower()} controls"
            })
    return pd.DataFrame(risk_rows)


# =============================================================================
# PAGE: HOME - Landing Page
# =============================================================================

if page == " Home":
    # EnergySolutions Brand Colors
    # Navy Blue: #003366, Green: #00843D, Light Blue: #5BA4E5, Teal: #009688
    
    # Time-based greeting
    current_hour = datetime.now().hour
    if current_hour < 12:
        greeting = "Good Morning"
    elif current_hour < 17:
        greeting = "Good Afternoon"
    else:
        greeting = "Good Evening"
    
    # Hero Section with brand colors - compact version
    st.markdown(f"""
    <div style="text-align: center; padding: 1.5rem 0; background: linear-gradient(135deg, #003366 0%, #005588 50%, #00843D 100%); border-radius: 12px; margin-bottom: 0.3rem;">
        <div style="font-size: 0.85rem; color: #b8d4e8; margin: 0 auto 0.2rem auto;"> {greeting}!</div>
        <div style="font-size: 2rem; font-weight: bold; margin: 0 auto 0.2rem auto; color: white;">
            <span style="color: #5BA4E5;">XYZ</span><span style="color: #00843D;">Corp</span>
        </div>
        <div style="font-size: 1.3rem; color: white; margin: 0 auto 0.2rem auto; font-weight: 600;">Financial Platform</div>
        <div style="font-size: 0.85rem; color: #b8d4e8; margin: 0 auto;">{datetime.now().strftime('%A, %B %d, %Y')}</div>
    </div>
    """, unsafe_allow_html=True)
    
    # Header buttons for About and Getting Started modals
    hdr1, hdr2, hdr3, hdr4, hdr5 = st.columns([1, 1, 1, 1, 1])
    with hdr1:
        show_about = st.button(" About", key="home_about_btn", use_container_width=True)
    with hdr2:
        show_getting_started = st.button(" Getting Started", key="home_start_btn", use_container_width=True)
    with hdr3:
        show_workflow = st.button(" Workflow Guide", key="home_workflow_btn", use_container_width=True)
    with hdr4:
        if st.button(" Load Sample Data", key="home_sample_btn", use_container_width=True):
            generate_sample_data()
            st.rerun()
    with hdr5:
        show_board_pack = st.button(" Board Pack", key="home_board_btn", use_container_width=True, type="primary")
    
    # Custom CSS for green Board Pack button - multiple selectors to ensure it works
    st.markdown("""
    <style>
    /* Target primary buttons using multiple selectors for compatibility */
    button[kind="primary"],
    button[data-testid="baseButton-primary"],
    .stButton button[kind="primary"],
    div[data-testid="stButton"] button[kind="primary"] {
        background-color: #00843D !important;
        background: #00843D !important;
        border-color: #00843D !important;
        color: white !important;
    }
    button[kind="primary"]:hover,
    button[data-testid="baseButton-primary"]:hover,
    .stButton button[kind="primary"]:hover,
    div[data-testid="stButton"] button[kind="primary"]:hover {
        background-color: #006633 !important;
        background: #006633 !important;
        border-color: #006633 !important;
    }
    button[kind="primary"]:focus,
    button[data-testid="baseButton-primary"]:focus {
        box-shadow: 0 0 0 0.2rem rgba(0, 132, 61, 0.5) !important;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # About Modal
    if show_about:
        @st.dialog(" About Financial Platform", width="large")
        def about_dialog():
            st.markdown("""
            <div style="padding: 1rem;">
                <h3 style="color: #003366; margin-top: 0;">Enterprise Financial Management Solution</h3>
                <p>The This Financial Platform is a comprehensive enterprise financial management solution designed for 
                the nuclear decommissioning and environmental services industry.</p>
            </div>
            """, unsafe_allow_html=True)
            
            col1, col2 = st.columns(2)
            with col1:
                st.markdown("""
                ** Key Capabilities:**
                - **Budget Planning & Management** - Multi-level budgeting with Oracle EBS integration
                - **Purchase Requisitions & Orders** - End-to-end procurement workflow
                - **Project Financial Controls** - EVM, forecasting, and change management
                - **Workforce Planning** - Labor cost modeling and resource allocation
                - **Executive Reporting** - Real-time dashboards and KPI monitoring
                - **AI-Powered Analytics** - Natural language queries and automated insights
                """)
            
            with col2:
                st.markdown("""
                ** Integrations:**
                - **Oracle E-Business Suite (EBS)** - GL, AP, AR, PA, PO modules
                - **Oracle Projects** - Task and resource management
                - **Incorta** - Business intelligence and data warehouse
                - **Microsoft Office** - Excel, Word, PowerPoint exports
                
                ** Data Sources:**
                - Real-time Oracle EBS data
                - Historical actuals and forecasts
                - Budget versions and scenarios
                """)
            
            st.markdown("---")
            #st.caption("EnergySolutions Financial Platform v1.0 |  2025 EnergySolutions")
            
            if st.button("Close", key="about_close", use_container_width=True):
                st.rerun()
        
        about_dialog()
    
    # Getting Started Modal
    if show_getting_started:
        @st.dialog(" Getting Started", width="large")
        def getting_started_dialog():
            st.markdown("""
            <div style="padding: 0.5rem;">
                <h3 style="color: #00843D; margin-top: 0;">Welcome to the Platform!</h3>
            </div>
            """, unsafe_allow_html=True)
            
            st.markdown("""
            ** First Time Users:**
            
            1. **Load Sample Data** - Click " Load Sample Data" on the Home page to explore with demo data
            2. **Navigate to Budget Planning** - Go to Budget Planning  Import Data to create your first budget
            3. **Choose Your Method** - Use **Direct Entry** for manual input or **Template Import** for bulk data
            """)
            
            st.markdown("---")
            
            st.markdown("""
            ** Tips & Tricks:**
            
            | Feature | Description |
            |---------|-------------|
            | **Quick Filters** | Use sidebar filters to select fiscal year and budget version |
            | **Corporate Versions** | Allow multiple contributors to collaborate on budgets |
            | **Detail Level** | Add Project, Task, Vendor details for granular tracking |
            | **Needs PR** | Check this box on lines requiring Purchase Requests |
            | **AI Assistant** | Ask natural language questions about your financial data |
            """)
            
            st.markdown("---")
            
            st.info("**Pro Tip:** Press `?` anywhere in the app to see keyboard shortcuts!")
            
            if st.button("Got it!", key="start_close", type="primary", use_container_width=True):
                st.rerun()
        
        getting_started_dialog()
    
    # Workflow Guide Modal
    if show_workflow:
        @st.dialog(" Typical Workflow", width="large")
        def workflow_dialog():
            st.markdown("""
            <div style="padding: 0.5rem;">
                <h3 style="color: #003366; margin-top: 0;">Budget to Purchase Request Workflow</h3>
            </div>
            """, unsafe_allow_html=True)
            
            st.markdown("""
            ```
                      
              1. CREATE          2. MARK PR         3. SAVE TO     
                 BUDGET                LINES                 CORP VER    
                      
                                                                   
                                                                   
                      
              6. MONITOR &       5. CREATE          4. APPROVE     
                 REPORT                POs                   PRs         
                      
            ```
            """)
            
            st.markdown("---")
            
            col1, col2 = st.columns(2)
            with col1:
                st.markdown("""
                **Step 1: Create Budget**
                - Go to Budget Planning  Import Data
                - Use Direct Entry or Template Import
                - Enter budget by Cost Center or Detail Level
                
                **Step 2: Mark PR Lines**
                - Switch to Detail Level view
                - Check "Needs PR" for new spend items
                - These will flow to Purchasing
                
                **Step 3: Save to Corporate Version**
                - Click  Save
                - Select or create a Corporate Version
                - Multiple contributors can collaborate
                """)
            
            with col2:
                st.markdown("""
                **Step 4: Approve PRs**
                - Go to Purchasing  Purchase Requests
                - Click  Refresh from Budgets
                - Review and approve lines
                
                **Step 5: Create POs**
                - Generate PR numbers for approved lines
                - Convert PRs to Purchase Orders
                - Assign vendors and terms
                
                **Step 6: Monitor & Report**
                - Track actuals vs budget
                - Use dashboards for KPIs
                - Export reports as needed
                """)
            
            if st.button("Close", key="workflow_close", use_container_width=True):
                st.rerun()
        
        workflow_dialog()
    
    # Board Pack Modal - Generate Executive PowerPoint
    if show_board_pack:
        @st.dialog(" Generate Board Pack", width="large")
        def board_pack_dialog():
            st.markdown("""
            <div style="padding: 0.5rem;">
                <h3 style="color: #003366; margin-top: 0;">Executive Board Presentation</h3>
                <p>Generate a professional PowerPoint presentation with financial summaries from your approved corporate budget.</p>
            </div>
            """, unsafe_allow_html=True)
            
            # Get available corporate versions for selection
            unified_versions = st.session_state.get('unified_corporate_versions', {})
            bp_versions = [(k, v) for k, v in unified_versions.items() if v.get('page_type') == 'Budget Planning']
            
            if not bp_versions:
                st.warning(" No Budget Planning corporate versions found. Please create and save a budget first.")
                return
            
            # Version selector
            version_names = {f"{v.get('name', k)} ({v.get('status', 'Draft')})": k for k, v in bp_versions}
            selected_version_display = st.selectbox(" Select Corporate Budget", list(version_names.keys()), key="bp_version_select")
            selected_version_key = version_names[selected_version_display]
            selected_version_info = unified_versions[selected_version_key]
            
            # Show version summary
            st.info(f"**Total Budget:** ${selected_version_info.get('total_amount', 0):,.0f} | **Contributors:** {len(selected_version_info.get('contributors', {}))} | **FY:** {selected_version_info.get('fiscal_year', 'N/A')}")
            
            st.caption("Includes: Executive Summary, Budget Overview, Department & Category Breakdown, Monthly Trends, and Account Analysis")
            
            # Generate button
            if st.button(" Generate Board Pack", type="primary", use_container_width=True, key="bp_generate_btn"):
                with st.spinner("Generating executive presentation..."):
                    try:
                        # Try to import pptx, auto-install if needed
                        try:
                            from pptx import Presentation
                            from pptx.util import Inches, Pt
                            from pptx.dml.color import RGBColor
                            from pptx.enum.text import PP_ALIGN, MSO_ANCHOR
                            from pptx.enum.shapes import MSO_SHAPE
                        except ImportError:
                            import subprocess
                            import sys
                            with st.spinner("Installing python-pptx library..."):
                                subprocess.check_call([sys.executable, "-m", "pip", "install", "python-pptx", "-q"])
                            from pptx import Presentation
                            from pptx.util import Inches, Pt
                            from pptx.dml.color import RGBColor
                            from pptx.enum.text import PP_ALIGN, MSO_ANCHOR
                            from pptx.enum.shapes import MSO_SHAPE
                            st.success("python-pptx installed!")
                        
                        # All slides enabled
                        inc_exec_summary = True
                        inc_budget_overview = True
                        inc_dept_breakdown = True
                        inc_category_detail = True
                        inc_account_analysis = True
                        inc_monthly_trend = True
                        inc_project_breakdown = True
                        inc_vendor_analysis = True
                        inc_variance_analysis = True
                        
                        # Create presentation
                        prs = Presentation()
                        prs.slide_width = Inches(13.333)
                        prs.slide_height = Inches(7.5)
                        
                        # Brand colors
                        NAVY = RGBColor(0, 51, 102)  # #003366
                        GREEN = RGBColor(0, 132, 61)  # #00843D
                        LIGHT_BLUE = RGBColor(91, 164, 229)  # #5BA4E5
                        WHITE = RGBColor(255, 255, 255)
                        GRAY = RGBColor(100, 100, 100)
                        LIGHT_GRAY = RGBColor(248, 249, 250)
                        
                        # Get data from selected version
                        fy = selected_version_info.get('fiscal_year', datetime.now().year)
                        total_budget = selected_version_info.get('total_amount', 0)
                        contributors = selected_version_info.get('contributors', {})
                        version_name = selected_version_info.get('name', 'Budget')
                        version_status = selected_version_info.get('status', 'Draft')
                        
                        # Combine all contributor data
                        all_data = []
                        dept_totals = {}
                        category_totals = {}
                        account_totals = {}  # For Code Combination analysis
                        project_totals = {}  # For Detail Level Project breakdown
                        vendor_totals = {}   # For Detail Level Vendor analysis
                        month_cols = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
                        monthly_totals = {m: 0 for m in month_cols}
                        
                        # Track if we have Detail Level data
                        has_detail_data = False
                        detail_lines_count = 0
                        cc_lines_count = 0
                        
                        for dept_name, dept_info in contributors.items():
                            dept_data = dept_info.get('data', pd.DataFrame())
                            dept_total = dept_info.get('total', 0)
                            dept_totals[dept_name] = dept_total
                            
                            if isinstance(dept_data, pd.DataFrame) and not dept_data.empty:
                                dept_data = dept_data.copy()
                                dept_data['_Department'] = dept_name
                                all_data.append(dept_data)
                                
                                # Check for Detail Level columns
                                has_project = 'Project' in dept_data.columns
                                has_vendor = 'Vendor' in dept_data.columns
                                has_account = 'Account' in dept_data.columns
                                
                                if has_project or has_vendor:
                                    has_detail_data = True
                                
                                # Sum by category
                                if 'Category' in dept_data.columns:
                                    for idx, row in dept_data.iterrows():
                                        cat = row['Category']
                                        row_total = 0
                                        for m in month_cols:
                                            if m in dept_data.columns:
                                                try:
                                                    row_total += float(row[m]) if pd.notna(row[m]) else 0
                                                except:
                                                    pass
                                        if row_total == 0 and 'Budget_Annual' in dept_data.columns:
                                            try:
                                                row_total = float(row['Budget_Annual']) if pd.notna(row['Budget_Annual']) else 0
                                            except:
                                                pass
                                        category_totals[cat] = category_totals.get(cat, 0) + row_total
                                
                                # Sum by Account (Code Combination)
                                if has_account:
                                    for idx, row in dept_data.iterrows():
                                        acct = str(row['Account']) if pd.notna(row['Account']) else 'Unknown'
                                        acct_name = str(row['Account_Name']) if 'Account_Name' in row.index and pd.notna(row.get('Account_Name')) else acct
                                        display_acct = f"{acct} - {acct_name}" if acct_name and acct_name != acct else acct
                                        row_total = 0
                                        for m in month_cols:
                                            if m in dept_data.columns:
                                                try:
                                                    row_total += float(row[m]) if pd.notna(row[m]) else 0
                                                except:
                                                    pass
                                        if row_total == 0 and 'Budget_Annual' in dept_data.columns:
                                            try:
                                                row_total = float(row['Budget_Annual']) if pd.notna(row['Budget_Annual']) else 0
                                            except:
                                                pass
                                        account_totals[display_acct] = account_totals.get(display_acct, 0) + row_total
                                        cc_lines_count += 1
                                
                                # Sum by Project (Detail Level)
                                if has_project:
                                    for idx, row in dept_data.iterrows():
                                        proj = str(row['Project']) if pd.notna(row['Project']) else ''
                                        if proj and proj.strip():
                                            row_total = 0
                                            for m in month_cols:
                                                if m in dept_data.columns:
                                                    try:
                                                        row_total += float(row[m]) if pd.notna(row[m]) else 0
                                                    except:
                                                        pass
                                            if row_total == 0 and 'Budget_Annual' in dept_data.columns:
                                                try:
                                                    row_total = float(row['Budget_Annual']) if pd.notna(row['Budget_Annual']) else 0
                                                except:
                                                    pass
                                            project_totals[proj] = project_totals.get(proj, 0) + row_total
                                            detail_lines_count += 1
                                
                                # Sum by Vendor (Detail Level)
                                if has_vendor:
                                    for idx, row in dept_data.iterrows():
                                        vendor = str(row['Vendor']) if pd.notna(row['Vendor']) else ''
                                        if vendor and vendor.strip():
                                            row_total = 0
                                            for m in month_cols:
                                                if m in dept_data.columns:
                                                    try:
                                                        row_total += float(row[m]) if pd.notna(row[m]) else 0
                                                    except:
                                                        pass
                                            if row_total == 0 and 'Budget_Annual' in dept_data.columns:
                                                try:
                                                    row_total = float(row['Budget_Annual']) if pd.notna(row['Budget_Annual']) else 0
                                                except:
                                                    pass
                                            vendor_totals[vendor] = vendor_totals.get(vendor, 0) + row_total
                                
                                # Sum monthly
                                for m in month_cols:
                                    if m in dept_data.columns:
                                        try:
                                            monthly_totals[m] += dept_data[m].sum()
                                        except:
                                            pass
                        
                        combined_data = pd.concat(all_data, ignore_index=True) if all_data else pd.DataFrame()
                        
                        # Helper function for title slides
                        def add_title_slide(title, subtitle=""):
                            slide_layout = prs.slide_layouts[6]  # Blank
                            slide = prs.slides.add_slide(slide_layout)
                            
                            # Navy background
                            background = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, 0, 0, prs.slide_width, prs.slide_height)
                            background.fill.solid()
                            background.fill.fore_color.rgb = NAVY
                            background.line.fill.background()
                            
                            # Green accent bar
                            accent = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, 0, Inches(5.5), prs.slide_width, Inches(0.15))
                            accent.fill.solid()
                            accent.fill.fore_color.rgb = GREEN
                            accent.line.fill.background()
                            
                            # Title
                            title_box = slide.shapes.add_textbox(Inches(0.5), Inches(2.5), Inches(12), Inches(1.5))
                            tf = title_box.text_frame
                            p = tf.paragraphs[0]
                            p.text = title
                            p.font.size = Pt(44)
                            p.font.bold = True
                            p.font.color.rgb = WHITE
                            p.alignment = PP_ALIGN.CENTER
                            
                            # Subtitle
                            if subtitle:
                                sub_box = slide.shapes.add_textbox(Inches(0.5), Inches(4), Inches(12), Inches(0.8))
                                tf = sub_box.text_frame
                                p = tf.paragraphs[0]
                                p.text = subtitle
                                p.font.size = Pt(24)
                                p.font.color.rgb = LIGHT_BLUE
                                p.alignment = PP_ALIGN.CENTER
                            
                            return slide
                        
                        # Helper for content slides
                        def add_content_slide(title):
                            slide_layout = prs.slide_layouts[6]  # Blank
                            slide = prs.slides.add_slide(slide_layout)
                            
                            # Header bar
                            header = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, 0, 0, prs.slide_width, Inches(1.2))
                            header.fill.solid()
                            header.fill.fore_color.rgb = NAVY
                            header.line.fill.background()
                            
                            # Title
                            title_box = slide.shapes.add_textbox(Inches(0.5), Inches(0.3), Inches(10), Inches(0.7))
                            tf = title_box.text_frame
                            p = tf.paragraphs[0]
                            p.text = title
                            p.font.size = Pt(32)
                            p.font.bold = True
                            p.font.color.rgb = WHITE
                            
                            # Footer
                            footer = slide.shapes.add_textbox(Inches(0.5), Inches(7), Inches(12), Inches(0.3))
                            tf = footer.text_frame
                            p = tf.paragraphs[0]
                            p.text = f"EnergySolutions | {version_name} | FY{fy} | Confidential"
                            p.font.size = Pt(10)
                            p.font.color.rgb = GRAY
                            
                            return slide
                        
                        # SLIDE 1: Title Slide
                        add_title_slide(
                            "XYZ Corporation",
                            f"Financial Board Pack | {version_name} | FY{fy}"
                        )
                        
                        # SLIDE 2: Executive Summary
                        if inc_exec_summary:
                            slide = add_content_slide("Executive Summary")
                            
                            # Summary text
                            content = slide.shapes.add_textbox(Inches(0.5), Inches(1.5), Inches(12), Inches(5))
                            tf = content.text_frame
                            tf.word_wrap = True
                            
                            p = tf.paragraphs[0]
                            p.text = f"FY{fy} Budget Overview - {version_status}"
                            p.font.size = Pt(24)
                            p.font.bold = True
                            p.font.color.rgb = NAVY
                            
                            bullets = [
                                f"Total Annual Budget: ${total_budget:,.0f} ({total_budget/1e6:.2f}M)",
                                f"Contributing Departments: {len(dept_totals)}",
                                f"Budget Categories: {len(category_totals)}",
                                f"Budget Lines: {len(combined_data):,}",
                                f"Status: {version_status} | Source: {version_name}"
                            ]
                            
                            for bullet in bullets:
                                p = tf.add_paragraph()
                                p.text = f" {bullet}"
                                p.font.size = Pt(18)
                                p.space_before = Pt(12)
                            
                            # Add department highlights
                            if dept_totals:
                                p = tf.add_paragraph()
                                p.text = ""
                                p.space_before = Pt(24)
                                
                                p = tf.add_paragraph()
                                p.text = "Department Highlights:"
                                p.font.size = Pt(20)
                                p.font.bold = True
                                p.font.color.rgb = GREEN
                                
                                for dept, amt in sorted(dept_totals.items(), key=lambda x: x[1], reverse=True)[:5]:
                                    pct = (amt / total_budget * 100) if total_budget > 0 else 0
                                    p = tf.add_paragraph()
                                    p.text = f"   {dept}: ${amt:,.0f} ({pct:.1f}%)"
                                    p.font.size = Pt(16)
                        
                        # SLIDE 3: Budget Overview KPIs
                        if inc_budget_overview:
                            slide = add_content_slide("Budget Overview")
                            
                            # Calculate some KPIs
                            q1_total = sum(monthly_totals.get(m, 0) for m in ['Jan', 'Feb', 'Mar'])
                            q2_total = sum(monthly_totals.get(m, 0) for m in ['Apr', 'May', 'Jun'])
                            h1_total = q1_total + q2_total
                            avg_monthly = total_budget / 12 if total_budget > 0 else 0
                            
                            kpi_data = [
                                ("Total Budget", f"${total_budget/1e6:.2f}M"),
                                ("Q1 Budget", f"${q1_total/1e6:.2f}M"),
                                ("Q2 Budget", f"${q2_total/1e6:.2f}M"),
                                ("Avg Monthly", f"${avg_monthly/1e6:.2f}M")
                            ]
                            
                            for i, (label, value) in enumerate(kpi_data):
                                left = Inches(0.5 + i * 3.1)
                                box = slide.shapes.add_shape(MSO_SHAPE.ROUNDED_RECTANGLE, left, Inches(1.8), Inches(2.8), Inches(1.5))
                                box.fill.solid()
                                box.fill.fore_color.rgb = LIGHT_GRAY
                                
                                # Label
                                lbl = slide.shapes.add_textbox(left + Inches(0.1), Inches(1.9), Inches(2.6), Inches(0.4))
                                tf = lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = label
                                p.font.size = Pt(12)
                                p.font.color.rgb = GRAY
                                p.alignment = PP_ALIGN.CENTER
                                
                                # Value
                                val = slide.shapes.add_textbox(left + Inches(0.1), Inches(2.3), Inches(2.6), Inches(0.8))
                                tf = val.text_frame
                                p = tf.paragraphs[0]
                                p.text = value
                                p.font.size = Pt(28)
                                p.font.bold = True
                                p.font.color.rgb = NAVY
                                p.alignment = PP_ALIGN.CENTER
                            
                            # Add breakdown table
                            if dept_totals:
                                tbl_top = Inches(3.6)
                                header_txt = slide.shapes.add_textbox(Inches(0.5), tbl_top, Inches(12), Inches(0.5))
                                tf = header_txt.text_frame
                                p = tf.paragraphs[0]
                                p.text = "Department Summary"
                                p.font.size = Pt(18)
                                p.font.bold = True
                                p.font.color.rgb = NAVY
                                
                                y_pos = tbl_top + Inches(0.5)
                                for dept, amt in sorted(dept_totals.items(), key=lambda x: x[1], reverse=True):
                                    pct = (amt / total_budget * 100) if total_budget > 0 else 0
                                    
                                    dept_txt = slide.shapes.add_textbox(Inches(0.5), y_pos, Inches(4), Inches(0.35))
                                    tf = dept_txt.text_frame
                                    p = tf.paragraphs[0]
                                    p.text = dept
                                    p.font.size = Pt(14)
                                    
                                    amt_txt = slide.shapes.add_textbox(Inches(5), y_pos, Inches(3), Inches(0.35))
                                    tf = amt_txt.text_frame
                                    p = tf.paragraphs[0]
                                    p.text = f"${amt:,.0f}"
                                    p.font.size = Pt(14)
                                    p.font.bold = True
                                    p.alignment = PP_ALIGN.RIGHT
                                    
                                    pct_txt = slide.shapes.add_textbox(Inches(8.5), y_pos, Inches(2), Inches(0.35))
                                    tf = pct_txt.text_frame
                                    p = tf.paragraphs[0]
                                    p.text = f"{pct:.1f}%"
                                    p.font.size = Pt(14)
                                    p.font.color.rgb = GREEN
                                    p.alignment = PP_ALIGN.RIGHT
                                    
                                    y_pos += Inches(0.4)
                        
                        # SLIDE 4: Department Breakdown with Bars
                        if inc_dept_breakdown:
                            slide = add_content_slide("Department Breakdown")
                            
                            if dept_totals:
                                sorted_depts = sorted(dept_totals.items(), key=lambda x: x[1], reverse=True)
                                max_amt = max(dept_totals.values()) if dept_totals else 1
                                
                                for i, (dept, amt) in enumerate(sorted_depts[:6]):
                                    y = Inches(1.6 + i * 0.9)
                                    pct = (amt / total_budget * 100) if total_budget > 0 else 0
                                    bar_width = (amt / max_amt) * 7 if max_amt > 0 else 0
                                    
                                    # Label
                                    lbl = slide.shapes.add_textbox(Inches(0.5), y, Inches(3), Inches(0.4))
                                    tf = lbl.text_frame
                                    p = tf.paragraphs[0]
                                    p.text = dept
                                    p.font.size = Pt(14)
                                    p.font.bold = True
                                    
                                    # Bar background
                                    bar_bg = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, Inches(3.5), y + Inches(0.05), Inches(7), Inches(0.35))
                                    bar_bg.fill.solid()
                                    bar_bg.fill.fore_color.rgb = RGBColor(230, 230, 230)
                                    bar_bg.line.fill.background()
                                    
                                    # Bar fill
                                    if bar_width > 0:
                                        bar = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, Inches(3.5), y + Inches(0.05), Inches(bar_width), Inches(0.35))
                                        bar.fill.solid()
                                        bar.fill.fore_color.rgb = GREEN if i % 2 == 0 else NAVY
                                        bar.line.fill.background()
                                    
                                    # Amount & Percentage
                                    amt_lbl = slide.shapes.add_textbox(Inches(10.7), y, Inches(2.2), Inches(0.4))
                                    tf = amt_lbl.text_frame
                                    p = tf.paragraphs[0]
                                    p.text = f"${amt/1e6:.2f}M ({pct:.1f}%)"
                                    p.font.size = Pt(12)
                                    p.font.bold = True
                                    p.font.color.rgb = NAVY
                        
                        # SLIDE 5: Category Detail
                        if inc_category_detail and category_totals:
                            slide = add_content_slide("Budget by Category")
                            
                            sorted_cats = sorted(category_totals.items(), key=lambda x: x[1], reverse=True)
                            max_cat = max(category_totals.values()) if category_totals else 1
                            
                            for i, (cat, amt) in enumerate(sorted_cats[:8]):
                                y = Inches(1.5 + i * 0.7)
                                pct = (amt / total_budget * 100) if total_budget > 0 else 0
                                bar_width = (amt / max_cat) * 6 if max_cat > 0 else 0
                                
                                # Category name
                                cat_lbl = slide.shapes.add_textbox(Inches(0.5), y, Inches(3), Inches(0.35))
                                tf = cat_lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = cat
                                p.font.size = Pt(13)
                                p.font.bold = True
                                
                                # Bar
                                if bar_width > 0:
                                    bar = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, Inches(3.8), y + Inches(0.05), Inches(bar_width), Inches(0.28))
                                    bar.fill.solid()
                                    bar.fill.fore_color.rgb = LIGHT_BLUE if i % 2 == 0 else GREEN
                                    bar.line.fill.background()
                                
                                # Amount
                                amt_lbl = slide.shapes.add_textbox(Inches(10), y, Inches(2.8), Inches(0.35))
                                tf = amt_lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = f"${amt:,.0f} ({pct:.1f}%)"
                                p.font.size = Pt(12)
                                p.alignment = PP_ALIGN.RIGHT
                        
                        # SLIDE 6: Monthly Trend
                        if inc_monthly_trend:
                            slide = add_content_slide("Monthly Budget Distribution")
                            
                            # Create visual monthly bars
                            max_month = max(monthly_totals.values()) if any(monthly_totals.values()) else 1
                            bar_base_y = Inches(5.5)
                            max_bar_height = 3.5
                            
                            for i, month in enumerate(month_cols):
                                amt = monthly_totals.get(month, 0)
                                bar_height = (amt / max_month) * max_bar_height if max_month > 0 else 0
                                x = Inches(0.8 + i * 1.0)
                                
                                # Bar
                                if bar_height > 0:
                                    bar = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, x, Inches(bar_base_y - bar_height), Inches(0.7), Inches(bar_height))
                                    bar.fill.solid()
                                    bar.fill.fore_color.rgb = NAVY if i < 6 else GREEN
                                    bar.line.fill.background()
                                
                                # Month label
                                m_lbl = slide.shapes.add_textbox(x - Inches(0.1), Inches(5.7), Inches(0.9), Inches(0.3))
                                tf = m_lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = month
                                p.font.size = Pt(10)
                                p.alignment = PP_ALIGN.CENTER
                                
                                # Amount on top of bar
                                if amt > 0:
                                    a_lbl = slide.shapes.add_textbox(x - Inches(0.2), Inches(bar_base_y - bar_height - 0.35), Inches(1.1), Inches(0.3))
                                    tf = a_lbl.text_frame
                                    p = tf.paragraphs[0]
                                    p.text = f"${amt/1e3:.0f}K"
                                    p.font.size = Pt(9)
                                    p.font.bold = True
                                    p.alignment = PP_ALIGN.CENTER
                            
                            # Add quarterly summary
                            q_summary = slide.shapes.add_textbox(Inches(0.5), Inches(6.2), Inches(12), Inches(0.5))
                            tf = q_summary.text_frame
                            p = tf.paragraphs[0]
                            q1 = sum(monthly_totals.get(m, 0) for m in ['Jan', 'Feb', 'Mar'])
                            q2 = sum(monthly_totals.get(m, 0) for m in ['Apr', 'May', 'Jun'])
                            q3 = sum(monthly_totals.get(m, 0) for m in ['Jul', 'Aug', 'Sep'])
                            q4 = sum(monthly_totals.get(m, 0) for m in ['Oct', 'Nov', 'Dec'])
                            p.text = f"Q1: ${q1/1e6:.2f}M  |  Q2: ${q2/1e6:.2f}M  |  Q3: ${q3/1e6:.2f}M  |  Q4: ${q4/1e6:.2f}M"
                            p.font.size = Pt(12)
                            p.font.bold = True
                            p.alignment = PP_ALIGN.CENTER
                        
                        # SLIDE: Account Analysis (Code Combination)
                        if inc_account_analysis and account_totals:
                            slide = add_content_slide("Account Analysis (Code Combination)")
                            
                            # Header with stats
                            stats_box = slide.shapes.add_textbox(Inches(0.5), Inches(1.4), Inches(12), Inches(0.4))
                            tf = stats_box.text_frame
                            p = tf.paragraphs[0]
                            p.text = f" {len(account_totals)} unique account codes across {len(dept_totals)} departments"
                            p.font.size = Pt(14)
                            p.font.color.rgb = GRAY
                            
                            sorted_accts = sorted(account_totals.items(), key=lambda x: x[1], reverse=True)
                            max_acct = max(account_totals.values()) if account_totals else 1
                            
                            for i, (acct, amt) in enumerate(sorted_accts[:8]):
                                y = Inches(1.9 + i * 0.65)
                                pct = (amt / total_budget * 100) if total_budget > 0 else 0
                                bar_width = (amt / max_acct) * 5.5 if max_acct > 0 else 0
                                
                                # Account name (truncate if too long)
                                display_name = acct[:35] + "..." if len(str(acct)) > 35 else str(acct)
                                acct_lbl = slide.shapes.add_textbox(Inches(0.5), y, Inches(4), Inches(0.35))
                                tf = acct_lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = display_name
                                p.font.size = Pt(11)
                                p.font.bold = True
                                
                                # Bar
                                if bar_width > 0:
                                    bar = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, Inches(4.5), y + Inches(0.05), Inches(bar_width), Inches(0.25))
                                    bar.fill.solid()
                                    bar.fill.fore_color.rgb = NAVY if i % 2 == 0 else LIGHT_BLUE
                                    bar.line.fill.background()
                                
                                # Amount
                                amt_lbl = slide.shapes.add_textbox(Inches(10.2), y, Inches(2.5), Inches(0.35))
                                tf = amt_lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = f"${amt:,.0f} ({pct:.1f}%)"
                                p.font.size = Pt(11)
                                p.alignment = PP_ALIGN.RIGHT
                            
                            # Footer note
                            if len(account_totals) > 8:
                                note_box = slide.shapes.add_textbox(Inches(0.5), Inches(6.5), Inches(12), Inches(0.3))
                                tf = note_box.text_frame
                                p = tf.paragraphs[0]
                                p.text = f"Showing top 8 of {len(account_totals)} accounts"
                                p.font.size = Pt(10)
                                p.font.italic = True
                                p.font.color.rgb = GRAY
                        
                        # SLIDE: Project Breakdown (Detail Level)
                        if inc_project_breakdown and project_totals:
                            slide = add_content_slide("Project Breakdown (Detail Level)")
                            
                            # Header with stats
                            stats_box = slide.shapes.add_textbox(Inches(0.5), Inches(1.4), Inches(12), Inches(0.4))
                            tf = stats_box.text_frame
                            p = tf.paragraphs[0]
                            p.text = f" {len(project_totals)} projects | {detail_lines_count} detail budget lines"
                            p.font.size = Pt(14)
                            p.font.color.rgb = GRAY
                            
                            sorted_projects = sorted(project_totals.items(), key=lambda x: x[1], reverse=True)
                            max_proj = max(project_totals.values()) if project_totals else 1
                            project_total = sum(project_totals.values())
                            
                            for i, (proj, amt) in enumerate(sorted_projects[:7]):
                                y = Inches(1.9 + i * 0.75)
                                pct = (amt / project_total * 100) if project_total > 0 else 0
                                bar_width = (amt / max_proj) * 6 if max_proj > 0 else 0
                                
                                # Project card background
                                card = slide.shapes.add_shape(MSO_SHAPE.ROUNDED_RECTANGLE, Inches(0.4), y - Inches(0.05), Inches(12.5), Inches(0.65))
                                card.fill.solid()
                                card.fill.fore_color.rgb = LIGHT_GRAY
                                card.line.fill.background()
                                
                                # Project name
                                proj_lbl = slide.shapes.add_textbox(Inches(0.6), y, Inches(4), Inches(0.35))
                                tf = proj_lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = f" {proj}"
                                p.font.size = Pt(13)
                                p.font.bold = True
                                p.font.color.rgb = NAVY
                                
                                # Bar
                                if bar_width > 0:
                                    bar = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, Inches(4.8), y + Inches(0.1), Inches(bar_width), Inches(0.3))
                                    bar.fill.solid()
                                    bar.fill.fore_color.rgb = GREEN
                                    bar.line.fill.background()
                                
                                # Amount
                                amt_lbl = slide.shapes.add_textbox(Inches(11), y, Inches(1.8), Inches(0.35))
                                tf = amt_lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = f"${amt:,.0f}"
                                p.font.size = Pt(13)
                                p.font.bold = True
                                p.alignment = PP_ALIGN.RIGHT
                                
                                # Percentage
                                pct_lbl = slide.shapes.add_textbox(Inches(11), y + Inches(0.3), Inches(1.8), Inches(0.25))
                                tf = pct_lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = f"{pct:.1f}%"
                                p.font.size = Pt(10)
                                p.font.color.rgb = GRAY
                                p.alignment = PP_ALIGN.RIGHT
                        
                        # SLIDE: Vendor Analysis (Detail Level)
                        if inc_vendor_analysis and vendor_totals:
                            slide = add_content_slide("Vendor Analysis (Detail Level)")
                            
                            # Header with stats
                            stats_box = slide.shapes.add_textbox(Inches(0.5), Inches(1.4), Inches(12), Inches(0.4))
                            tf = stats_box.text_frame
                            p = tf.paragraphs[0]
                            p.text = f" {len(vendor_totals)} vendors with assigned budget"
                            p.font.size = Pt(14)
                            p.font.color.rgb = GRAY
                            
                            sorted_vendors = sorted(vendor_totals.items(), key=lambda x: x[1], reverse=True)
                            max_vendor = max(vendor_totals.values()) if vendor_totals else 1
                            vendor_total = sum(vendor_totals.values())
                            
                            for i, (vendor, amt) in enumerate(sorted_vendors[:8]):
                                y = Inches(1.9 + i * 0.65)
                                pct = (amt / vendor_total * 100) if vendor_total > 0 else 0
                                bar_width = (amt / max_vendor) * 5.5 if max_vendor > 0 else 0
                                
                                # Vendor name
                                vendor_lbl = slide.shapes.add_textbox(Inches(0.5), y, Inches(4), Inches(0.35))
                                tf = vendor_lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = f" {vendor}"
                                p.font.size = Pt(12)
                                p.font.bold = True
                                
                                # Bar
                                if bar_width > 0:
                                    bar = slide.shapes.add_shape(MSO_SHAPE.RECTANGLE, Inches(4.5), y + Inches(0.05), Inches(bar_width), Inches(0.28))
                                    bar.fill.solid()
                                    bar.fill.fore_color.rgb = LIGHT_BLUE if i % 2 == 0 else GREEN
                                    bar.line.fill.background()
                                
                                # Amount
                                amt_lbl = slide.shapes.add_textbox(Inches(10.2), y, Inches(2.5), Inches(0.35))
                                tf = amt_lbl.text_frame
                                p = tf.paragraphs[0]
                                p.text = f"${amt:,.0f} ({pct:.1f}%)"
                                p.font.size = Pt(11)
                                p.alignment = PP_ALIGN.RIGHT
                        
                        # SLIDE: Budget Composition Analysis
                        if inc_variance_analysis:
                            slide = add_content_slide("Budget Composition Analysis")
                            
                            content = slide.shapes.add_textbox(Inches(0.5), Inches(1.5), Inches(6), Inches(5))
                            tf = content.text_frame
                            tf.word_wrap = True
                            
                            p = tf.paragraphs[0]
                            p.text = "Category Breakdown"
                            p.font.size = Pt(18)
                            p.font.bold = True
                            p.font.color.rgb = NAVY
                            
                            # Analyze category distribution
                            if category_totals:
                                for cat, amt in sorted(category_totals.items(), key=lambda x: x[1], reverse=True)[:6]:
                                    pct = (amt / total_budget * 100) if total_budget > 0 else 0
                                    indicator = "" if pct < 30 else "" if pct < 50 else ""
                                    p = tf.add_paragraph()
                                    p.text = f"{indicator} {cat}: ${amt:,.0f} ({pct:.1f}%)"
                                    p.font.size = Pt(14)
                                    p.space_before = Pt(8)
                            
                            # Right column - Summary stats
                            stats_box = slide.shapes.add_textbox(Inches(7), Inches(1.5), Inches(5.5), Inches(5))
                            tf = stats_box.text_frame
                            tf.word_wrap = True
                            
                            p = tf.paragraphs[0]
                            p.text = "Budget Summary"
                            p.font.size = Pt(18)
                            p.font.bold = True
                            p.font.color.rgb = GREEN
                            
                            # Add summary stats
                            summary_items = [
                                f" Total Budget: ${total_budget:,.0f}",
                                f" Departments: {len(dept_totals)}",
                                f" Categories: {len(category_totals)}",
                                f" Budget Lines: {len(combined_data)}",
                            ]
                            
                            if has_detail_data:
                                summary_items.extend([
                                    f" Projects: {len(project_totals)}",
                                    f" Vendors: {len(vendor_totals)}",
                                    f" Detail Lines: {detail_lines_count}",
                                ])
                            
                            for item in summary_items:
                                p = tf.add_paragraph()
                                p.text = item
                                p.font.size = Pt(14)
                                p.space_before = Pt(10)
                        
                        # SLIDE: Thank You
                        add_title_slide(
                            "Questions?",
                            f"XYZ Finance Team | {datetime.now().strftime('%B %Y')}"
                        )
                        
                        # Save to buffer
                        buffer = io.BytesIO()
                        prs.save(buffer)
                        buffer.seek(0)
                        
                        # Summary message
                        slides_count = 2  # Title + Thank You
                        if inc_exec_summary: slides_count += 1
                        if inc_budget_overview: slides_count += 1
                        if inc_dept_breakdown: slides_count += 1
                        if inc_category_detail and category_totals: slides_count += 1
                        if inc_account_analysis and account_totals: slides_count += 1
                        if inc_monthly_trend: slides_count += 1
                        if inc_project_breakdown and project_totals: slides_count += 1
                        if inc_vendor_analysis and vendor_totals: slides_count += 1
                        if inc_variance_analysis: slides_count += 1
                        
                        st.success(" Board Pack generated successfully!")
                        
                        detail_msg = ""
                        if has_detail_data:
                            detail_msg = f" | Projects: {len(project_totals)} | Vendors: {len(vendor_totals)}"
                        
                        st.info(f" **{slides_count} slides** from: **{version_name}** | Departments: {len(dept_totals)} | Categories: {len(category_totals)} | Accounts: {len(account_totals)}{detail_msg}")
                        
                        st.download_button(
                            label=" Download Board Pack (PPTX)",
                            data=buffer,
                            file_name=f"xyz_BoardPack_{version_name.replace(' ', '_')}_FY{fy}_{datetime.now().strftime('%Y%m%d')}.pptx",
                            mime="application/vnd.openxmlformats-officedocument.presentationml.presentation",
                            use_container_width=True,
                            type="primary"
                        )
                        
                    except Exception as e:
                        st.error(f"Error generating presentation: {str(e)}")
                        import traceback
                        st.code(traceback.format_exc())
            
            st.markdown("---")
            if st.button("Cancel", key="board_close", use_container_width=True):
                st.rerun()
        
        board_pack_dialog()
    
    # Quick Stats Row - Custom styled centered KPIs
    # Get data from the last approved corporate budget
    unified_versions = st.session_state.get('unified_corporate_versions', {})
    bp_versions = [(k, v) for k, v in unified_versions.items() if v.get('page_type') == 'Budget Planning']
    
    # Find the last approved version or most recent version
    last_approved_name = None
    total_budget = 0
    budget_lines = 0
    selected_version = None
    
    if bp_versions:
        # First try to find an approved version
        for key, info in bp_versions:
            if info.get('status') == 'Approved':
                selected_version = (key, info)
                break
        
        # If no approved version, use the most recent one
        if not selected_version:
            # Sort by created if available, otherwise just use first
            sorted_versions = sorted(bp_versions, key=lambda x: str(x[1].get('created', '')), reverse=True)
            if sorted_versions:
                selected_version = sorted_versions[0]
        
        # Calculate totals from corporate budget
        if selected_version:
            key, info = selected_version
            last_approved_name = info.get('name', key)
            
            # Use total_amount if available
            if info.get('total_amount'):
                total_budget = info['total_amount']
            
            # Count lines and sum from contributors
            contributors = info.get('contributors', {})
            for contrib_name, contrib_info in contributors.items():
                contrib_data = contrib_info.get('data', pd.DataFrame())
                if isinstance(contrib_data, pd.DataFrame) and not contrib_data.empty:
                    budget_lines += len(contrib_data)
                    
                    # If total_amount wasn't set, calculate from data
                    if total_budget == 0:
                        month_cols = [c for c in contrib_data.columns if c in ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']]
                        if month_cols:
                            total_budget += contrib_data[month_cols].sum().sum()
                        elif 'Amount' in contrib_data.columns:
                            total_budget += contrib_data['Amount'].sum()
                        elif 'Budget_Annual' in contrib_data.columns:
                            total_budget += contrib_data['Budget_Annual'].sum()
    
    # Fallback to session budget_data if no corporate versions
    if total_budget == 0:
        budget_data = st.session_state.get('budget_data', pd.DataFrame())
        if not budget_data.empty:
            month_cols = [c for c in budget_data.columns if c in ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']]
            if month_cols:
                total_budget = budget_data[month_cols].sum().sum()
            elif 'Amount' in budget_data.columns:
                total_budget = budget_data['Amount'].sum()
            budget_lines = len(budget_data)
    
    # Get PR data for pending approvals
    pr_data = st.session_state.get('pr_budget_data', pd.DataFrame())
    pending_prs = len(pr_data[pr_data['Approval_Status'] == 'Pending']) if not pr_data.empty and 'Approval_Status' in pr_data.columns else 0
    approved_prs = len(pr_data[pr_data['Approval_Status'] == 'Approved']) if not pr_data.empty and 'Approval_Status' in pr_data.columns else 0
    
    # Custom CSS for centered, larger metrics with reduced spacing
    st.markdown("""
    <style>
    /* Reduce spacing between elements on home page */
    .stMarkdown { margin-bottom: 0 !important; }
    
    .kpi-card {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 10px;
        padding: 0.8rem;
        text-align: center;
        border-left: 4px solid #003366;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin-bottom: 0.2rem;
    }
    .kpi-card-green { border-left-color: #00843D; }
    .kpi-card-blue { border-left-color: #5BA4E5; }
    .kpi-card-warning { border-left-color: #ffc107; }
    .kpi-label {
        font-size: 0.75rem;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 0.2rem;
    }
    .kpi-value {
        font-size: 1.8rem;
        font-weight: 700;
        color: #003366;
        line-height: 1.1;
    }
    .kpi-value-green { color: #00843D; }
    .kpi-value-blue { color: #5BA4E5; }
    .kpi-value-warning { color: #ff9800; }
    .kpi-delta {
        font-size: 0.8rem;
        color: #28a745;
    }
    .kpi-delta-negative { color: #dc3545; }
    </style>
    """, unsafe_allow_html=True)
    
    # KPI Row
    k1, k2, k3, k4, k5 = st.columns(5)
    
    with k1:
        version_count = len(bp_versions)
        st.markdown(f"""
        <div class="kpi-card">
            <div class="kpi-label"> Corporate Versions</div>
            <div class="kpi-value">{version_count}</div>
        </div>
        """, unsafe_allow_html=True)
    
    with k2:
        st.markdown(f"""
        <div class="kpi-card kpi-card-blue">
            <div class="kpi-label"> Budget Lines</div>
            <div class="kpi-value kpi-value-blue">{budget_lines:,}</div>
        </div>
        """, unsafe_allow_html=True)
    
    with k3:
        budget_display = f"${total_budget/1e6:.1f}M" if total_budget >= 1e6 else f"${total_budget/1e3:.0f}K" if total_budget > 0 else "$0"
        st.markdown(f"""
        <div class="kpi-card kpi-card-green">
            <div class="kpi-label"> Total Budget</div>
            <div class="kpi-value kpi-value-green">{budget_display}</div>
        </div>
        """, unsafe_allow_html=True)
    
    with k4:
        fy = st.session_state.get('selected_fiscal_year', datetime.now().year)
        st.markdown(f"""
        <div class="kpi-card">
            <div class="kpi-label"> Fiscal Year</div>
            <div class="kpi-value">FY{fy}</div>
        </div>
        """, unsafe_allow_html=True)
    
    with k5:
        pending_class = "kpi-card-warning" if pending_prs > 0 else "kpi-card-green"
        value_class = "kpi-value-warning" if pending_prs > 0 else "kpi-value-green"
        st.markdown(f"""
        <div class="kpi-card {pending_class}">
            <div class="kpi-label"> Pending Approvals</div>
            <div class="kpi-value {value_class}">{pending_prs}</div>
        </div>
        """, unsafe_allow_html=True)
    
    # KPI Detail buttons row with popovers
    btn1, btn2, btn3, btn4, btn5 = st.columns(5)
    with btn1:
        with st.popover("View Details", use_container_width=True):
            st.markdown("###  Corporate Versions")
            if bp_versions:
                for vkey, vinfo in bp_versions:
                    status_icon = "" if vinfo.get('status') == 'Approved' else "" if vinfo.get('status') == 'In Progress' else ""
                    st.markdown(f"**{status_icon} {vinfo.get('name', vkey)}**")
                    st.caption(f"Status: {vinfo.get('status', 'Draft')} | FY: {vinfo.get('fiscal_year', 'N/A')} | Total: ${vinfo.get('total_amount', 0):,.0f}")
                    vcontributors = vinfo.get('contributors', {})
                    if vcontributors:
                        for vcontrib_name, vcontrib_info in vcontributors.items():
                            st.write(f"   {vcontrib_name}: ${vcontrib_info.get('total', 0):,.0f}")
                    st.markdown("---")
            else:
                st.info("No corporate versions found.")
    
    with btn2:
        with st.popover("View Details", use_container_width=True):
            st.markdown("###  Budget Lines")
            if selected_version:
                lkey, linfo = selected_version
                st.write(f"**Source:** {linfo.get('name', lkey)}")
                lcontributors = linfo.get('contributors', {})
                ldata = []
                for lname, lcinfo in lcontributors.items():
                    lcdata = lcinfo.get('data', pd.DataFrame())
                    if isinstance(lcdata, pd.DataFrame) and not lcdata.empty:
                        ldata.append({'Contributor': lname, 'Lines': len(lcdata), 
                                      'Categories': lcdata['Category'].nunique() if 'Category' in lcdata.columns else 'N/A'})
                if ldata:
                    st.dataframe(pd.DataFrame(ldata), use_container_width=True, hide_index=True)
            else:
                st.info("No budget data available.")
    
    with btn3:
        with st.popover("View Details", use_container_width=True):
            st.markdown("###  Total Budget")
            if selected_version:
                bkey, binfo = selected_version
                st.write(f"**Source:** {binfo.get('name', bkey)} | **Status:** {binfo.get('status', 'Draft')}")
                bcontributors = binfo.get('contributors', {})
                bdata = []
                for bname, bcinfo in bcontributors.items():
                    bdata.append({'Department': bname, 'Amount': f"${bcinfo.get('total', 0):,.0f}", 'Saved By': bcinfo.get('saved_by', 'N/A')})
                if bdata:
                    st.dataframe(pd.DataFrame(bdata), use_container_width=True, hide_index=True)
                    st.metric("Total Budget", f"${binfo.get('total_amount', 0):,.0f}")
            else:
                st.info("No budget data available.")
    
    with btn4:
        with st.popover("View Details", use_container_width=True):
            st.markdown(f"###  Fiscal Year {fy}")
            fy_vers = [(fk, fv) for fk, fv in bp_versions if fv.get('fiscal_year') == fy]
            fcol1, fcol2, fcol3 = st.columns(3)
            with fcol1:
                st.metric("Approved", len([fv for fk, fv in fy_vers if fv.get('status') == 'Approved']))
            with fcol2:
                st.metric("In Progress", len([fv for fk, fv in fy_vers if fv.get('status') == 'In Progress']))
            with fcol3:
                st.metric("Total", len(fy_vers))
            if fy_vers:
                for fkey, finfo in fy_vers:
                    fstatus = "" if finfo.get('status') == 'Approved' else ""
                    st.write(f"{fstatus} {finfo.get('name', fkey)} - ${finfo.get('total_amount', 0):,.0f}")
    
    with btn5:
        with st.popover("View Details", use_container_width=True):
            st.markdown("###  Pending Approvals")
            apr_data = st.session_state.get('pr_budget_data', pd.DataFrame())
            if not apr_data.empty and 'Approval_Status' in apr_data.columns:
                acol1, acol2, acol3 = st.columns(3)
                with acol1:
                    st.metric("Pending", len(apr_data[apr_data['Approval_Status'] == 'Pending']))
                with acol2:
                    st.metric("Approved", len(apr_data[apr_data['Approval_Status'] == 'Approved']))
                with acol3:
                    st.metric("Total", len(apr_data))
                apending = apr_data[apr_data['Approval_Status'] == 'Pending']
                if not apending.empty:
                    st.markdown("**Pending Items:**")
                    adisp = [c for c in ['Description', 'Amount', 'Department', 'Urgency'] if c in apending.columns]
                    if adisp:
                        st.dataframe(apending[adisp].head(10), use_container_width=True, hide_index=True)
                else:
                    st.success(" No pending approvals!")
            else:
                st.info("No purchase request data available.")
    
    st.markdown("---")
    
    # Feature Cards - Using EnergySolutions brand colors
    st.markdown("###  Quick Start")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div style="background: linear-gradient(135deg, #003366 0%, #005588 100%); padding: 1.5rem; border-radius: 10px; color: white; height: 180px; border-left: 4px solid #00843D;">
            <h3 style="color: #5BA4E5; margin-top: 0;"> Budget Planning</h3>
            <p style="font-size: 0.9rem; color: #e8f4f8;">Create, import, and manage budgets with Direct Entry or Template Import. Support for cost center and detail-level budgeting.</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Open Budget Planning ", key="home_budget", use_container_width=True):
            st.session_state.current_page = " Budget Planning"
            st.rerun()
    
    with col2:
        st.markdown("""
        <div style="background: linear-gradient(135deg, #00843D 0%, #00a64d 100%); padding: 1.5rem; border-radius: 10px; color: white; height: 180px; border-left: 4px solid #003366;">
            <h3 style="color: #b8e8c8; margin-top: 0;"> Purchasing</h3>
            <p style="font-size: 0.9rem; color: #e8f8eb;">End-to-end purchase request and order management. Integrated with Oracle EBS for seamless procurement workflows.</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Open Purchasing ", key="home_purch", use_container_width=True):
            st.session_state.current_page = " Purchasing"
            st.rerun()
    
    with col3:
        st.markdown("""
        <div style="background: linear-gradient(135deg, #5BA4E5 0%, #3d8bd4 100%); padding: 1.5rem; border-radius: 10px; color: white; height: 180px; border-left: 4px solid #00843D;">
            <h3 style="color: white; margin-top: 0;"> Executive Dashboard</h3>
            <p style="font-size: 0.9rem; color: #e8f4ff;">Real-time KPIs, variance analysis, and executive reporting. Monitor financial performance at a glance.</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Open Dashboard ", key="home_dash", use_container_width=True):
            st.session_state.current_page = " Executive Dashboard"
            st.rerun()
    
    st.markdown("")
    
    col4, col5, col6 = st.columns(3)
    
    with col4:
        st.markdown("""
        <div style="background: linear-gradient(135deg, #004d80 0%, #003366 100%); padding: 1.5rem; border-radius: 10px; color: white; height: 180px; border-left: 4px solid #5BA4E5;">
            <h3 style="color: #5BA4E5; margin-top: 0;"> Project Controls</h3>
            <p style="font-size: 0.9rem; color: #e8f4f8;">Track project budgets, forecasts, and earned value. Manage change orders and project financials.</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Open Project Controls ", key="home_proj", use_container_width=True):
            st.session_state.current_page = " Project Controls"
            st.rerun()
    
    with col5:
        st.markdown("""
        <div style="background: linear-gradient(135deg, #006633 0%, #00843D 100%); padding: 1.5rem; border-radius: 10px; color: white; height: 180px; border-left: 4px solid #003366;">
            <h3 style="color: #b8e8c8; margin-top: 0;"> Reports & Analytics</h3>
            <p style="font-size: 0.9rem; color: #e8f8eb;">Financial statements, custom reports, and data visualization. Export to Excel, PDF, and more.</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Open Reports ", key="home_reports", use_container_width=True):
            st.session_state.current_page = " Reports & Analytics"
            st.rerun()
    
    with col6:
        st.markdown("""
        <div style="background: linear-gradient(135deg, #009688 0%, #00796B 100%); padding: 1.5rem; border-radius: 10px; color: white; height: 180px; border-left: 4px solid #00843D;">
            <h3 style="color: #b2dfdb; margin-top: 0;"> AI Assistant</h3>
            <p style="font-size: 0.9rem; color: #e0f2f1;">Natural language queries, automated analysis, and intelligent insights powered by AI.</p>
        </div>
        """, unsafe_allow_html=True)
        if st.button("Open AI Assistant ", key="home_ai", use_container_width=True):
            st.session_state.current_page = " AI Assistant"
            st.rerun()
    
    # Footer
    st.markdown("---")
    st.markdown(f"""
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; color: #888; font-size: 0.8rem;">
        <div>
            <strong style="color: #003366;">XYZ Corporation</strong> Financial Platform v1.0
        </div>
        <div>
             Secure |  Oracle EBS Integrated |  Cloud-Native
        </div>
        <div>
             {datetime.now().year} XYZ Corporation LLC
        </div>
    </div>
    """, unsafe_allow_html=True)


# =============================================================================
# PAGE: EXECUTIVE DASHBOARD
# =============================================================================

elif page == " Executive Dashboard":
    st.caption(f"Fiscal Year {st.session_state.selected_fiscal_year} | As of {datetime.now().strftime('%B %d, %Y')}")
    
    if st.session_state.budget_data.empty:
        st.info(" Welcome! Go to the Home page and click 'Load Sample Data' to explore the dashboard with demo data.")
        st.stop()
    
    df = st.session_state.budget_data
    current_month = datetime.now().month
    
    # Calculate key metrics
    revenue_accounts = df[df['Account'].str.startswith('4')]
    expense_accounts = df[~df['Account'].str.startswith('4')]
    
    total_revenue_budget = revenue_accounts['Budget'].sum()
    total_revenue_actual = revenue_accounts['Actual'].sum()
    total_revenue_forecast = revenue_accounts['Forecast'].sum()
    
    total_expense_budget = expense_accounts['Budget'].sum()
    total_expense_actual = expense_accounts['Actual'].sum()
    total_expense_forecast = expense_accounts['Forecast'].sum()
    
    ytd_revenue_budget = revenue_accounts[revenue_accounts['Month_Num'] <= current_month]['Budget'].sum()
    ytd_revenue_actual = revenue_accounts[revenue_accounts['Month_Num'] <= current_month]['Actual'].sum()
    
    ytd_expense_budget = expense_accounts[expense_accounts['Month_Num'] <= current_month]['Budget'].sum()
    ytd_expense_actual = expense_accounts[expense_accounts['Month_Num'] <= current_month]['Actual'].sum()
    
    # KPI Row
    kpi_cols = st.columns(5)
    
    with kpi_cols[0]:
        st.metric(
            "Annual Revenue Target",
            format_currency(total_revenue_budget),
            f"{((total_revenue_forecast - total_revenue_budget) / total_revenue_budget * 100):+.1f}% Forecast",
            delta_color="normal"
        )
    
    with kpi_cols[1]:
        st.metric(
            "YTD Revenue",
            format_currency(ytd_revenue_actual),
            f"{((ytd_revenue_actual - ytd_revenue_budget) / ytd_revenue_budget * 100):+.1f}% vs Budget",
            delta_color="normal"
        )
    
    with kpi_cols[2]:
        gross_margin = ((total_revenue_budget - total_expense_budget * 0.2) / total_revenue_budget * 100)
        st.metric(
            "Gross Margin",
            f"{gross_margin:.1f}%",
            "+2.3% YoY",
            delta_color="normal"
        )
    
    with kpi_cols[3]:
        ebitda_margin = ((total_revenue_budget - total_expense_budget) / total_revenue_budget * 100)
        st.metric(
            "EBITDA Margin",
            f"{ebitda_margin:.1f}%",
            f"{ebitda_margin - 18:.1f}% vs Target",
            delta_color="normal"
        )
    
    with kpi_cols[4]:
        if not st.session_state.headcount_plan.empty:
            hc = len(st.session_state.headcount_plan[st.session_state.headcount_plan['Status'] == 'Active'])
        else:
            hc = 0
        st.metric(
            "Headcount",
            f"{hc:,}",
            "+15 vs Plan",
            delta_color="inverse"
        )
    
    st.markdown("---")
    
    # Charts Row 1
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("###  Revenue Trend")
        
        monthly_revenue = revenue_accounts.groupby('Month').agg({
            'Budget': 'sum',
            'Actual': 'sum',
            'Forecast': 'sum'
        }).reindex(MONTHS)
        
        fig_revenue = go.Figure()
        
        fig_revenue.add_trace(go.Bar(
            name='Budget',
            x=MONTHS,
            y=monthly_revenue['Budget'] / 1e6,
            marker_color='#e5e7eb'
        ))
        
        fig_revenue.add_trace(go.Bar(
            name='Actual',
            x=MONTHS[:current_month],
            y=monthly_revenue['Actual'][:current_month] / 1e6,
            marker_color='#3b82f6'
        ))
        
        fig_revenue.add_trace(go.Scatter(
            name='Forecast',
            x=MONTHS,
            y=monthly_revenue['Forecast'] / 1e6,
            mode='lines+markers',
            line=dict(color='#10b981', width=2, dash='dot'),
            marker=dict(size=6)
        ))
        
        fig_revenue.update_layout(
            barmode='overlay',
            height=350,
            margin=dict(l=20, r=20, t=30, b=20),
            legend=dict(orientation='h', yanchor='bottom', y=1.02, xanchor='right', x=1),
            yaxis_title='Revenue ($M)',
            xaxis_title='',
            plot_bgcolor='white'
        )
        
        st.plotly_chart(fig_revenue, use_container_width=True)
    
    with col2:
        st.markdown("###  Expense by Category")
        
        expense_by_account = expense_accounts.groupby('Account Name')['Budget'].sum().sort_values(ascending=True).tail(8)
        
        fig_expense = go.Figure(go.Bar(
            x=expense_by_account.values / 1e6,
            y=expense_by_account.index,
            orientation='h',
            marker_color='#6366f1'
        ))
        
        fig_expense.update_layout(
            height=350,
            margin=dict(l=20, r=20, t=30, b=20),
            xaxis_title='Annual Budget ($M)',
            yaxis_title='',
            plot_bgcolor='white'
        )
        
        st.plotly_chart(fig_expense, use_container_width=True)
    
    # Charts Row 2
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("###  Budget vs Actual (YTD)")
        
        # Waterfall chart for variance
        categories = ['Budget', 'Revenue Variance', 'Expense Variance', 'Actual']
        
        budget_profit = ytd_revenue_budget - ytd_expense_budget
        actual_profit = ytd_revenue_actual - ytd_expense_actual
        revenue_var = ytd_revenue_actual - ytd_revenue_budget
        expense_var = -(ytd_expense_actual - ytd_expense_budget)  # Negative because lower expense is good
        
        fig_waterfall = go.Figure(go.Waterfall(
            name="",
            orientation="v",
            measure=["absolute", "relative", "relative", "total"],
            x=categories,
            y=[budget_profit / 1e6, revenue_var / 1e6, expense_var / 1e6, 0],
            connector={"line": {"color": "#e5e7eb"}},
            decreasing={"marker": {"color": "#ef4444"}},
            increasing={"marker": {"color": "#10b981"}},
            totals={"marker": {"color": "#3b82f6"}}
        ))
        
        fig_waterfall.update_layout(
            height=350,
            margin=dict(l=20, r=20, t=30, b=20),
            yaxis_title='Operating Income ($M)',
            showlegend=False,
            plot_bgcolor='white'
        )
        
        st.plotly_chart(fig_waterfall, use_container_width=True)
    
    with col2:
        st.markdown("###  Expense by Department")
        
        dept_expense = expense_accounts.groupby('Cost Center Name')['Budget'].sum().sort_values(ascending=False).head(10)
        
        fig_dept = px.pie(
            values=dept_expense.values,
            names=dept_expense.index,
            hole=0.4
        )
        
        fig_dept.update_layout(
            height=350,
            margin=dict(l=20, r=20, t=30, b=20),
            showlegend=True,
            legend=dict(orientation='h', yanchor='bottom', y=-0.3)
        )
        
        st.plotly_chart(fig_dept, use_container_width=True)
    
    # Variance Summary Table
    st.markdown("---")
    st.markdown("###  YTD Variance Summary by Department")
    
    variance_summary = expense_accounts[expense_accounts['Month_Num'] <= current_month].groupby('Cost Center Name').agg({
        'Budget': 'sum',
        'Actual': 'sum',
        'Forecast': 'sum'
    }).round(0)
    
    variance_summary['Variance $'] = variance_summary['Budget'] - variance_summary['Actual']
    variance_summary['Variance %'] = ((variance_summary['Budget'] - variance_summary['Actual']) / variance_summary['Budget'] * 100).round(1)
    variance_summary['Full Year Forecast'] = (variance_summary['Forecast'] / current_month * 12).round(0)
    
    # Format for display
    display_df = variance_summary.copy()
    display_df['Budget'] = display_df['Budget'].apply(lambda x: f"${x:,.0f}")
    display_df['Actual'] = display_df['Actual'].apply(lambda x: f"${x:,.0f}")
    display_df['Variance $'] = display_df['Variance $'].apply(lambda x: f"${x:,.0f}")
    display_df['Variance %'] = display_df['Variance %'].apply(lambda x: f"{x:+.1f}%")
    display_df['Full Year Forecast'] = display_df['Full Year Forecast'].apply(lambda x: f"${x:,.0f}")
    
    display_df = display_df[['Budget', 'Actual', 'Variance $', 'Variance %', 'Full Year Forecast']]
    
    st.dataframe(display_df, use_container_width=True, height=400)


# =============================================================================
# PAGE: EXECUTIVE KPIs
# =============================================================================

elif page == " Executive KPIs":
    st.markdown("###  Executive KPIs")
    st.caption("Key Performance Indicators for executive leadership")
    
    # Get data
    budget_data = st.session_state.get('direct_entry_data', pd.DataFrame())
    if budget_data.empty:
        budget_data = st.session_state.get('budget_data_enhanced', pd.DataFrame())
    
    current_month = datetime.now().month
    current_year = datetime.now().year
    
    # Financial KPIs Section
    st.markdown("####  Financial Performance")
    
    fin_col1, fin_col2, fin_col3, fin_col4 = st.columns(4)
    
    # Calculate financial metrics
    if not budget_data.empty and 'Annual_Budget' in budget_data.columns:
        total_budget = budget_data['Annual_Budget'].sum()
        total_actual = budget_data.get('Actual_YTD', pd.Series([0])).sum()
        total_forecast = budget_data.get('Forecast', budget_data['Annual_Budget']).sum()
    else:
        total_budget = 96000000
        total_actual = total_budget * (current_month / 12) * 0.97
        total_forecast = total_budget * 1.02
    
    variance = total_forecast - total_budget
    variance_pct = (variance / total_budget * 100) if total_budget != 0 else 0
    
    with fin_col1:
        st.metric(
            "Revenue YTD",
            f"${total_actual/1e6:.1f}M",
            delta=f"{(total_actual/(total_budget*current_month/12)-1)*100:+.1f}% vs Budget"
        )
    with fin_col2:
        st.metric(
            "Annual Budget",
            f"${total_budget/1e6:.1f}M"
        )
    with fin_col3:
        st.metric(
            "Full Year Forecast",
            f"${total_forecast/1e6:.1f}M",
            delta=f"{variance_pct:+.1f}%"
        )
    with fin_col4:
        run_rate = (total_actual / current_month) * 12 if current_month > 0 else 0
        st.metric(
            "Run Rate",
            f"${run_rate/1e6:.1f}M",
            delta=f"{(run_rate/total_budget-1)*100:+.1f}% vs Budget"
        )
    
    st.markdown("---")
    
    # Operational KPIs
    st.markdown("####  Operational Metrics")
    
    op_col1, op_col2, op_col3, op_col4 = st.columns(4)
    
    with op_col1:
        st.metric("Projects Active", "47", delta="+3 this month")
    with op_col2:
        st.metric("On-Time Delivery", "94.2%", delta="+1.8%")
    with op_col3:
        st.metric("Resource Utilization", "87%", delta="+2%")
    with op_col4:
        st.metric("Backlog", "$12.4M", delta="-$0.8M")
    
    st.markdown("---")
    
    # Profitability KPIs
    st.markdown("####  Profitability Metrics")
    
    prof_col1, prof_col2, prof_col3, prof_col4 = st.columns(4)
    
    gross_margin = 42.5
    operating_margin = 18.3
    ebitda_margin = 22.1
    
    with prof_col1:
        st.metric("Gross Margin", f"{gross_margin:.1f}%", delta="+0.8%")
    with prof_col2:
        st.metric("Operating Margin", f"{operating_margin:.1f}%", delta="+0.3%")
    with prof_col3:
        st.metric("EBITDA Margin", f"{ebitda_margin:.1f}%", delta="+0.5%")
    with prof_col4:
        st.metric("Net Margin", "12.4%", delta="+0.2%")
    
    st.markdown("---")
    
    # Trend Charts
    st.markdown("####  KPI Trends")
    
    trend_col1, trend_col2 = st.columns(2)
    
    with trend_col1:
        st.markdown("**Monthly Revenue vs Budget**")
        
        months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
        monthly_budget = [total_budget/12 * (0.85 + 0.03*i) for i in range(12)]
        monthly_actual = [monthly_budget[i] * random.uniform(0.95, 1.08) if i < current_month else 0 for i in range(12)]
        
        trend_df = pd.DataFrame({
            'Month': months,
            'Budget': monthly_budget,
            'Actual': monthly_actual
        })
        
        st.line_chart(trend_df.set_index('Month')[['Budget', 'Actual']], height=250)
    
    with trend_col2:
        st.markdown("**Margin Trends**")
        
        margin_df = pd.DataFrame({
            'Month': months[:current_month],
            'Gross Margin': [gross_margin + random.uniform(-1, 1) for _ in range(current_month)],
            'Operating Margin': [operating_margin + random.uniform(-0.5, 0.5) for _ in range(current_month)]
        })
        
        st.line_chart(margin_df.set_index('Month'), height=250)
    
    st.markdown("---")
    
    # KPI Scorecard
    st.markdown("####  KPI Scorecard")
    
    scorecard_data = [
        {'KPI': 'Revenue Growth', 'Target': '15%', 'Actual': '12.3%', 'Status': '', 'Trend': ''},
        {'KPI': 'Gross Margin', 'Target': '42%', 'Actual': '42.5%', 'Status': '', 'Trend': ''},
        {'KPI': 'Operating Margin', 'Target': '18%', 'Actual': '18.3%', 'Status': '', 'Trend': ''},
        {'KPI': 'Customer Retention', 'Target': '95%', 'Actual': '96.2%', 'Status': '', 'Trend': ''},
        {'KPI': 'Employee Utilization', 'Target': '85%', 'Actual': '87%', 'Status': '', 'Trend': ''},
        {'KPI': 'Project On-Time %', 'Target': '95%', 'Actual': '94.2%', 'Status': '', 'Trend': ''},
        {'KPI': 'Cash Conversion Cycle', 'Target': '45 days', 'Actual': '48 days', 'Status': '', 'Trend': ''},
        {'KPI': 'DSO (Days Sales Outstanding)', 'Target': '35 days', 'Actual': '38 days', 'Status': '', 'Trend': ''},
    ]
    
    scorecard_df = pd.DataFrame(scorecard_data)
    
    st.dataframe(
        scorecard_df,
        column_config={
            'KPI': st.column_config.TextColumn('KPI', width='large'),
            'Target': st.column_config.TextColumn('Target', width='small'),
            'Actual': st.column_config.TextColumn('Actual', width='small'),
            'Status': st.column_config.TextColumn('Status', width='small'),
            'Trend': st.column_config.TextColumn('Trend', width='small'),
        },
        use_container_width=True,
        hide_index=True
    )
    
    # Legend
    st.caption(" On Track |  At Risk |  Off Track |  Improving |  Stable |  Declining")


# =============================================================================
# PAGE: BUDGET PLANNING
# =============================================================================


elif page == " Budget Planning":
    tab1, tab2, tab3, tab4 = st.tabs([" Import Data", " Budget Analysis", " Year-over-Year", " Calculation Builder"])
    
    with tab2:
        # -----------------------------------------------------------------
        # CORPORATE BUDGET VERSIONS (FROM UNIFIED SYSTEM)
        # -----------------------------------------------------------------
        # Get Budget Planning corporate versions from unified storage
        if 'unified_corporate_versions' not in st.session_state:
            st.session_state.unified_corporate_versions = {}
        
        bp_corp_versions = {k: v for k, v in st.session_state.unified_corporate_versions.items() 
                          if v.get('page_type') == 'Budget Planning'}
        saved_versions = st.session_state.get('saved_budget_versions', {})
        
        # Version management expander
        with st.expander(" Corporate Budget Versions", expanded=False):
            st.markdown("**Load or save to corporate budget versions**")
            
            ver_col1, ver_col2 = st.columns(2)
            
            with ver_col1:
                st.markdown("** Load Version**")
                
                # Build combined options for loading
                load_options = ['-- Select --']
                load_mapping = {}  # Maps display name to (source, key)
                
                if bp_corp_versions:
                    for k, v in bp_corp_versions.items():
                        status_icon = {'Working': '', 'Submitted': '', 'Approved': '', 'Locked': ''}.get(v.get('status', 'Working'), '')
                        display = f" {v['name']} ({status_icon} {v.get('status', 'Working')})"
                        load_options.append(display)
                        load_mapping[display] = ('corporate', k)
                
                if saved_versions:
                    for k, v in saved_versions.items():
                        display = f" {k}"
                        load_options.append(display)
                        load_mapping[display] = ('standalone', k)
                
                if len(load_options) > 1:
                    selected_load = st.selectbox("Select Version to Load", load_options, key="bp_load_version_select")
                    
                    if selected_load != '-- Select --':
                        source, ver_key = load_mapping[selected_load]
                        
                        lc1, lc2 = st.columns(2)
                        with lc1:
                            if st.button(" Load", key="bp_load_version_btn", type="primary"):
                                if source == 'corporate':
                                    # Load from unified corporate - need to combine all contributors
                                    corp_ver = st.session_state.unified_corporate_versions[ver_key]
                                    contributors = corp_ver.get('contributors', {})
                                    if contributors:
                                        # Combine all contributor data
                                        analysis_rows = []
                                        current_year = datetime.now().year
                                        
                                        for dept_name, contrib in contributors.items():
                                            contrib_data = contrib.get('data', pd.DataFrame())
                                            if isinstance(contrib_data, dict):
                                                contrib_data = contrib_data.get('cc_data', pd.DataFrame())
                                            
                                            if isinstance(contrib_data, pd.DataFrame) and not contrib_data.empty:
                                                has_month_cols = any(m in contrib_data.columns for m in MONTHS)
                                                
                                                if has_month_cols:
                                                    for _, row in contrib_data.iterrows():
                                                        for month in MONTHS:
                                                            if month in row.index:
                                                                amt = row.get(month, 0)
                                                                if pd.notna(amt) and amt != 0:
                                                                    analysis_rows.append({
                                                                        'Year': current_year,
                                                                        'Data_Type': 'Budget',
                                                                        'Cost_Center_Name': row.get('Department', dept_name),
                                                                        'Category': row.get('Category', 'Other'),
                                                                        'Account_Category': row.get('Category', 'Other'),
                                                                        'Month': month,
                                                                        'Month_Num': MONTHS.index(month) + 1,
                                                                        'Amount': amt,
                                                                        'Contributing_Dept': dept_name,
                                                                    })
                                                else:
                                                    # No month columns - distribute evenly
                                                    for _, row in contrib_data.iterrows():
                                                        total_amt = row.get('Total', row.get('Amount', 0))
                                                        if pd.notna(total_amt) and total_amt != 0:
                                                            monthly = total_amt / 12
                                                            for month in MONTHS:
                                                                analysis_rows.append({
                                                                    'Year': current_year,
                                                                    'Data_Type': 'Budget',
                                                                    'Cost_Center_Name': row.get('Department', dept_name),
                                                                    'Category': row.get('Category', 'Other'),
                                                                    'Month': month,
                                                                    'Month_Num': MONTHS.index(month) + 1,
                                                                    'Amount': monthly,
                                                                    'Contributing_Dept': dept_name,
                                                                })
                                        
                                        if analysis_rows:
                                            st.session_state.budget_data_enhanced = pd.DataFrame(analysis_rows)
                                            st.session_state.bp_current_version = f"Corporate: {corp_ver['name']}"
                                            st.toast(f" Loaded: {corp_ver['name']} with {len(contributors)} contributors")
                                        else:
                                            st.warning("No detailed data in this version")
                                    else:
                                        st.warning("No contributions in this corporate version yet")
                                else:
                                    # Load from standalone
                                    ver_data = saved_versions[ver_key]
                                    if 'data' in ver_data:
                                        data = ver_data['data']
                                        if isinstance(data, dict):
                                            st.session_state.budget_data_enhanced = data.get('cc_data', pd.DataFrame())
                                        else:
                                            st.session_state.budget_data_enhanced = data
                                    st.session_state.bp_current_version = ver_key
                                    st.toast(f" Loaded: {ver_key}")
                                st.rerun()
                        
                        with lc2:
                            if source == 'corporate':
                                ver_info = st.session_state.unified_corporate_versions[ver_key]
                                st.caption(f"FY: {ver_info.get('fiscal_year', 'N/A')}")
                                st.caption(f"Contributors: {len(ver_info.get('contributors', {}))}")
                                st.caption(f"Total: ${ver_info.get('total_amount', 0):,.0f}")
                            else:
                                ver_info = saved_versions[ver_key]
                                st.caption(f"Saved: {ver_info.get('saved_at', 'N/A')}")
                else:
                    st.info("No saved versions yet")
            
            with ver_col2:
                st.markdown("** Save Version**")
                
                # Save type selection
                save_type = st.radio("Save As", ["Standalone (Personal)", "To Corporate Version"], 
                                    horizontal=True, key="bp_save_type")
                
                if "Standalone" in save_type:
                    new_version_name = st.text_input("Version Name", key="bp_new_version_name", 
                                                     placeholder="e.g., My Q1 Draft")
                    
                    if st.button(" Save Standalone", key="bp_save_standalone_btn"):
                        if new_version_name.strip():
                            data_to_save = st.session_state.get('budget_data_enhanced', pd.DataFrame())
                            if 'saved_budget_versions' not in st.session_state:
                                st.session_state.saved_budget_versions = {}
                            st.session_state.saved_budget_versions[new_version_name.strip()] = {
                                'data': data_to_save.copy() if not data_to_save.empty else pd.DataFrame(),
                                'version_type': 'Standalone',
                                'page_type': 'Budget Planning',
                                'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M'),
                                'saved_by': 'User'
                            }
                            st.session_state.bp_current_version = new_version_name.strip()
                            st.toast(f" Saved: {new_version_name}")
                            st.rerun()
                        else:
                            st.warning("Please enter a version name")
                else:
                    # Save to corporate version
                    available_corp = {k: v for k, v in st.session_state.unified_corporate_versions.items() 
                                     if v.get('page_type') == 'Budget Planning' and v.get('status') == 'Working'}
                    
                    if available_corp:
                        corp_options = list(available_corp.keys())
                        corp_display = [f"{available_corp[k]['name']} (FY{available_corp[k].get('fiscal_year', '')})" for k in corp_options]
                        
                        selected_corp_idx = st.selectbox("Select Corporate Version", range(len(corp_options)),
                                                        format_func=lambda i: corp_display[i], key="bp_corp_select")
                        selected_corp_key = corp_options[selected_corp_idx]
                        
                        contributor_name = st.text_input("Contributor Name", key="bp_contributor_name",
                                                        placeholder="e.g., Your Name or Department")
                        
                        if st.button(" Save to Corporate", key="bp_save_corp_btn"):
                            if contributor_name.strip():
                                # Get current data
                                df = st.session_state.get('budget_data_enhanced', pd.DataFrame())
                                total_amount = df['Amount'].sum() if 'Amount' in df.columns and not df.empty else 0
                                
                                # Add as contributor
                                st.session_state.unified_corporate_versions[selected_corp_key]['contributors'][contributor_name.strip()] = {
                                    'data': df.copy() if not df.empty else pd.DataFrame(),
                                    'total': total_amount,
                                    'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M'),
                                    'saved_by': 'User'
                                }
                                
                                # Update total
                                new_total = sum(c.get('total', 0) for c in st.session_state.unified_corporate_versions[selected_corp_key]['contributors'].values())
                                st.session_state.unified_corporate_versions[selected_corp_key]['total_amount'] = new_total
                                
                                st.session_state.bp_current_version = f"Corporate: {available_corp[selected_corp_key]['name']} ({contributor_name.strip()})"
                                st.toast(f" Saved to corporate version: {available_corp[selected_corp_key]['name']}")
                                st.rerun()
                            else:
                                st.warning("Please enter your name or department")
                    else:
                        st.warning("No Working corporate versions available. Create one in Settings  Versions.")
            
            # Show current version indicator
            if st.session_state.get('bp_current_version'):
                st.success(f" Current: {st.session_state.bp_current_version}")
            
            # View saved data section
            if bp_corp_versions:
                st.markdown("---")
                st.markdown("** View Saved Data in Corporate Versions**")
                view_options = ['-- Select --'] + [f"{v['name']} ({v.get('status', '')})" for k, v in bp_corp_versions.items()]
                view_keys = [''] + list(bp_corp_versions.keys())
                
                view_col1, view_col2 = st.columns([2, 2])
                with view_col1:
                    view_idx = st.selectbox("Select to View", range(len(view_options)), 
                                           format_func=lambda i: view_options[i], key="bp_view_corp_select")
                
                if view_idx > 0:
                    view_key = view_keys[view_idx]
                    view_ver = bp_corp_versions[view_key]
                    contributors = view_ver.get('contributors', {})
                    
                    if contributors:
                        with view_col2:
                            st.metric("Total Contributors", len(contributors))
                        
                        for contrib_name, contrib_info in contributors.items():
                            with st.expander(f" {contrib_name} - ${contrib_info.get('total', 0):,.0f}", expanded=False):
                                st.caption(f"Saved: {contrib_info.get('saved_at', 'N/A')} by {contrib_info.get('saved_by', 'N/A')}")
                                contrib_data = contrib_info.get('data', pd.DataFrame())
                                if isinstance(contrib_data, pd.DataFrame) and not contrib_data.empty:
                                    st.dataframe(contrib_data, use_container_width=True, height=200)
                                    
                                    # Pull down button
                                    if view_ver.get('status') not in ['Locked', 'Approved']:
                                        if st.button(f" Pull Down to My Data", key=f"bp_pull_{view_key}_{contrib_name.replace(' ', '_')}"):
                                            st.session_state.budget_data_enhanced = contrib_data.copy()
                                            st.session_state.bp_current_version = f"Pulled from {view_ver['name']}: {contrib_name}"
                                            st.toast(f" Pulled data from {contrib_name}")
                                            st.rerun()
                                else:
                                    st.caption("No detailed data")
                    else:
                        st.info("No contributions in this version yet")
        
        # -----------------------------------------------------------------
        # BUDGET ANALYSIS SECTION
        # -----------------------------------------------------------------
                
                # Show all versions in a table
                if len(saved_versions) > 0:
                    st.markdown("---")
                    version_table = []
                    for vid, vinfo in saved_versions.items():
                        version_table.append({
                            'Version': vid,
                            'Name': vinfo.get('name', ''),
                            'Source': vinfo.get('source', ''),
                            'Total': f"${vinfo.get('total_budget', 0):,.0f}",
                            'CC Lines': vinfo.get('cc_count', 0),
                            'Detail Lines': vinfo.get('detail_count', 0),
                            'Created': vinfo.get('created', '').strftime('%Y-%m-%d') if hasattr(vinfo.get('created', ''), 'strftime') else '',
                        })
                    st.dataframe(pd.DataFrame(version_table), hide_index=True, use_container_width=True)
                    
                    # Delete version option
                    del_col1, del_col2 = st.columns([3, 1])
                    with del_col1:
                        del_version = st.selectbox("Delete Version", ["-- Select --"] + list(saved_versions.keys()), key="ba_del_version")
                    with del_col2:
                        if st.button(" Delete", disabled=del_version == "-- Select --", key="ba_del_btn"):
                            saved = st.session_state.get('saved_budget_versions', {})
                            if del_version in saved:
                                del st.session_state.saved_budget_versions[del_version]
                                st.toast(f"Deleted version '{del_version}'")
                                st.rerun()
        
        st.markdown("---")
        
        # Check if we need to generate enhanced budget data with history
        if 'budget_data_enhanced' not in st.session_state or st.session_state.budget_data_enhanced.empty:
            
            if st.session_state.budget_data.empty:
                st.info("No budget data loaded. Use 'Import Data' or click below to load sample data with historical actuals.")
                
                if st.button(" Load Sample Budget Data with 2-Year History", type="primary"):
                    np.random.seed(42)
                    current_year = datetime.now().year
                    
                    business_units = {
                        'D&D': {'name': 'Decommissioning & Demolition', 'cost_centers': ['CC-1100', 'CC-1200', 'CC-1300']},
                        'WM': {'name': 'Waste Management', 'cost_centers': ['CC-2100', 'CC-2200', 'CC-2300']},
                        'NS': {'name': 'Nuclear Services', 'cost_centers': ['CC-3100', 'CC-3200']},
                        'CORP': {'name': 'Corporate', 'cost_centers': ['CC-4100', 'CC-4200', 'CC-4300']},
                        'ESFS': {'name': 'ES Federal Services', 'cost_centers': ['CC-5100', 'CC-5200']},
                    }
                    
                    cost_center_details = {
                        'CC-1100': {'name': 'D&D Operations', 'bu': 'D&D'},
                        'CC-1200': {'name': 'D&D Engineering', 'bu': 'D&D'},
                        'CC-1300': {'name': 'D&D Project Mgmt', 'bu': 'D&D'},
                        'CC-2100': {'name': 'Waste Processing', 'bu': 'WM'},
                        'CC-2200': {'name': 'Transportation', 'bu': 'WM'},
                        'CC-2300': {'name': 'Disposal Operations', 'bu': 'WM'},
                        'CC-3100': {'name': 'Consulting Services', 'bu': 'NS'},
                        'CC-3200': {'name': 'Engineering Services', 'bu': 'NS'},
                        'CC-4100': {'name': 'Executive', 'bu': 'CORP'},
                        'CC-4200': {'name': 'Finance & Accounting', 'bu': 'CORP'},
                        'CC-4300': {'name': 'Human Resources', 'bu': 'CORP'},
                        'CC-5100': {'name': 'Federal Programs', 'bu': 'ESFS'},
                        'CC-5200': {'name': 'Federal Engineering', 'bu': 'ESFS'},
                    }
                    
                    account_categories = {
                        'Labor': {'5000': 'Direct Labor', '5010': 'Indirect Labor', '5020': 'Overtime', '5030': 'Benefits & Burden'},
                        'Materials': {'5100': 'Direct Materials', '5110': 'Supplies', '5120': 'Equipment Rental'},
                        'Subcontracts': {'5200': 'Professional Services', '5210': 'Subcontractor Labor', '5220': 'Temp Services'},
                        'Travel': {'5300': 'Travel - Domestic', '5310': 'Travel - International', '5320': 'Per Diem & Meals'},
                        'Other Direct': {'5400': 'Training & Development', '5410': 'Software & Licenses', '5420': 'Other Direct Costs'},
                        'Overhead': {'6000': 'Facilities', '6010': 'Utilities', '6020': 'Insurance', '6030': 'Depreciation'},
                        'G&A': {'7000': 'G&A Allocation', '7010': 'Corporate Overhead'},
                    }
                    
                    budget_rows = []
                    years = [current_year - 2, current_year - 1, current_year]
                    
                    for cc_code, cc_info in cost_center_details.items():
                        bu = cc_info['bu']
                        base_annual = np.random.uniform(2000000, 8000000)
                        
                        for cat_name, accounts in account_categories.items():
                            cat_weights = {'Labor': 0.55, 'Materials': 0.12, 'Subcontracts': 0.15, 'Travel': 0.03, 'Other Direct': 0.05, 'Overhead': 0.07, 'G&A': 0.03}
                            cat_weight = cat_weights.get(cat_name, 0.05)
                            cat_budget = base_annual * cat_weight
                            
                            for acct_code, acct_name in accounts.items():
                                acct_weight = 1 / len(accounts) * np.random.uniform(0.7, 1.3)
                                acct_annual = cat_budget * acct_weight
                                
                                for year in years:
                                    year_factors = {current_year - 2: (0.88, 'Actual'), current_year - 1: (0.94, 'Actual'), current_year: (1.0, 'Budget')}
                                    year_factor, data_type = year_factors[year]
                                    
                                    for month_idx, month in enumerate(MONTHS):
                                        seasonality = 1 + 0.1 * np.sin(2 * np.pi * (month_idx - 2) / 12)
                                        monthly_base = (acct_annual * year_factor / 12) * seasonality
                                        monthly_value = monthly_base * np.random.uniform(0.85, 1.15) if data_type == 'Actual' else monthly_base
                                        
                                        budget_rows.append({
                                            'Year': year, 'Data_Type': data_type, 'Business_Unit': bu,
                                            'Business_Unit_Name': business_units[bu]['name'],
                                            'Cost_Center': cc_code, 'Cost_Center_Name': cc_info['name'],
                                            'Account_Category': cat_name, 'GL_Account': acct_code,
                                            'GL_Account_Name': acct_name, 'Month': month,
                                            'Month_Num': month_idx + 1, 'Amount': round(monthly_value, 0),
                                        })
                    
                    st.session_state.budget_data_enhanced = pd.DataFrame(budget_rows)
                    st.success(f" Loaded {len(budget_rows):,} budget records with 2-year history!")
                    st.rerun()
            else:
                st.info("Converting existing data to enhanced format...")
                edf = st.session_state.budget_data.copy()
                current_year = datetime.now().year
                edf['Year'] = current_year
                edf['Data_Type'] = 'Budget'
                edf['Business_Unit'] = edf['Entity'] if 'Entity' in edf.columns else 'CORP'
                edf['Business_Unit_Name'] = edf['Entity'] if 'Entity' in edf.columns else 'Corporate'
                if 'Cost Center' in edf.columns:
                    edf['Cost_Center'] = edf['Cost Center']
                elif 'Facility' in edf.columns:
                    edf['Cost_Center'] = edf['Facility']
                else:
                    edf['Cost_Center'] = 'CC-1000'
                if 'Cost Center Name' in edf.columns:
                    edf['Cost_Center_Name'] = edf['Cost Center Name']
                elif 'Facility' in edf.columns:
                    edf['Cost_Center_Name'] = edf['Facility']
                else:
                    edf['Cost_Center_Name'] = 'Default'
                if 'Account_Category' in edf.columns:
                    pass  # Already has it
                elif 'Account Name' in edf.columns:
                    edf['Account_Category'] = edf['Account Name'].apply(lambda x: 'Labor' if 'Salary' in str(x) or 'Labor' in str(x) else 'Other')
                else:
                    edf['Account_Category'] = 'Other'
                edf['GL_Account'] = edf['Account'] if 'Account' in edf.columns else '5000'
                edf['GL_Account_Name'] = edf['Account Name'] if 'Account Name' in edf.columns else 'Default'
                edf['Amount'] = edf['Budget'] if 'Budget' in edf.columns else 0
                st.session_state.budget_data_enhanced = edf
                st.rerun()
        
        else:
            # =================================================================
            # MAIN BUDGET ANALYSIS - ULTRA COMPACT DESIGN
            # =================================================================
            df = st.session_state.budget_data_enhanced.copy()
            current_year = datetime.now().year
            
            # Ensure Year is integer for comparisons
            if 'Year' in df.columns:
                df['Year'] = pd.to_numeric(df['Year'], errors='coerce').fillna(current_year).astype(int)
            
            # Ensure required columns exist (handle different data formats)
            if 'Cost_Center_Name' not in df.columns:
                if 'Cost_Center' in df.columns:
                    df['Cost_Center_Name'] = df['Cost_Center']
                elif 'Department' in df.columns:
                    df['Cost_Center_Name'] = df['Department']
                else:
                    df['Cost_Center_Name'] = 'Unknown'
            if 'Business_Unit_Name' not in df.columns:
                if 'Business_Unit' in df.columns:
                    df['Business_Unit_Name'] = df['Business_Unit']
                else:
                    df['Business_Unit_Name'] = 'Unknown'
            if 'Account_Category' not in df.columns:
                if 'Category' in df.columns:
                    df['Account_Category'] = df['Category']
                else:
                    df['Account_Category'] = 'Other'
            if 'GL_Account' not in df.columns:
                if 'Account' in df.columns:
                    df['GL_Account'] = df['Account']
                else:
                    df['GL_Account'] = ''
            if 'GL_Account_Name' not in df.columns:
                if 'Account_Name' in df.columns:
                    df['GL_Account_Name'] = df['Account_Name']
                elif 'Description' in df.columns:
                    df['GL_Account_Name'] = df['Description']
                else:
                    df['GL_Account_Name'] = ''
            
            # Calculate high-level metrics
            year_opts = sorted(df['Year'].unique().tolist(), reverse=True)
            total_budget = df[df['Year'] == current_year]['Amount'].sum()
            total_prior = df[df['Year'] == current_year - 1]['Amount'].sum()
            total_2y_prior = df[df['Year'] == current_year - 2]['Amount'].sum() if current_year - 2 in df['Year'].values else 0
            variance = total_budget - total_prior
            variance_pct = (variance / total_prior * 100) if total_prior > 0 else 0
            
            # -----------------------------------------------------------------
            # COMPACT HEADER: Metrics + Budget Year + Period + Toggle
            # -----------------------------------------------------------------
            hdr1, hdr2, hdr3, hdr4, hdr5, hdr6 = st.columns([1.3, 1.3, 1.3, 1, 1, 0.6])
            
            with hdr1:
                st.metric(f"FY{current_year}", f"${total_budget/1e6:.1f}M", help="Current year budget")
            with hdr2:
                st.metric(f"FY{current_year-1}", f"${total_prior/1e6:.1f}M", help="Prior year actual")
            with hdr3:
                delta_color = "normal" if variance >= 0 else "inverse"
                st.metric("Variance", f"${variance/1e6:+.1f}M", delta=f"{variance_pct:+.1f}%", delta_color=delta_color)
            with hdr4:
                planning_year = st.selectbox("Budget Year", year_opts, key="ba_year2", label_visibility="collapsed")
                planning_year = int(planning_year)  # Ensure it's an integer
            with hdr5:
                view_period = st.selectbox("Period", ['Annual', 'Quarterly', 'Monthly'], key="ba_per2", label_visibility="collapsed")
            with hdr6:
                st.markdown("<div style='height:4px'></div>", unsafe_allow_html=True)
                show_charts = st.toggle("", value=True, help="Show/hide charts")
            
            # Always compare to prior year
            compare_year = planning_year - 1
            
            # -----------------------------------------------------------------
            # FILTER BAR + GROUP BY + COLUMNS (inline popovers)
            # -----------------------------------------------------------------
            f1, f2, f3, f4, f5, f6 = st.columns([1.3, 1.3, 1.3, 1.3, 0.8, 0.8])
            
            with f1:
                # Legal Entity / Business Unit filter
                le_col = 'Legal_Entity' if 'Legal_Entity' in df.columns else ('Business_Unit' if 'Business_Unit' in df.columns else ('Business_Unit_Name' if 'Business_Unit_Name' in df.columns else None))
                if le_col:
                    le_opts = ['All Entities'] + sorted(df[le_col].dropna().unique().tolist())
                else:
                    le_opts = ['All Entities']
                selected_le = st.selectbox("Entity", le_opts, key="ba_le", label_visibility="collapsed")
            
            with f2:
                # Department / Cost Center filter
                dept_col = 'Department' if 'Department' in df.columns else ('Cost_Center_Name' if 'Cost_Center_Name' in df.columns else ('Cost_Center' if 'Cost_Center' in df.columns else None))
                if dept_col:
                    if selected_le != 'All Entities' and le_col in df.columns:
                        dept_opts = ['All Departments'] + sorted(df[df[le_col] == selected_le][dept_col].dropna().unique().tolist())
                    else:
                        dept_opts = ['All Departments'] + sorted(df[dept_col].dropna().unique().tolist())
                else:
                    dept_opts = ['All Departments']
                selected_dept = st.selectbox("Dept", dept_opts, key="ba_dept", label_visibility="collapsed")
            
            with f3:
                # Account filter
                acct_col = 'Account' if 'Account' in df.columns else ('GL_Account' if 'GL_Account' in df.columns else ('GL_Account_Name' if 'GL_Account_Name' in df.columns else None))
                if acct_col:
                    acct_opts = ['All Accounts'] + sorted(df[acct_col].dropna().unique().tolist())
                else:
                    acct_opts = ['All Accounts']
                selected_acct = st.selectbox("Acct", acct_opts, key="ba_acct", label_visibility="collapsed")
            
            with f4:
                # Category filter
                cat_col = 'Category' if 'Category' in df.columns else ('Account_Category' if 'Account_Category' in df.columns else None)
                if cat_col:
                    cat_opts = ['All Categories'] + sorted(df[cat_col].dropna().unique().tolist())
                else:
                    cat_opts = ['All Categories']
                selected_cat = st.selectbox("Cat", cat_opts, key="ba_cat2", label_visibility="collapsed")
            
            with f5:
                with st.popover(" Group"):
                    st.caption("**CC Level (Required)**")
                    grp_le = st.checkbox("Legal Entity", value=True, key="ba_grp_le")
                    grp_dept = st.checkbox("Department", value=False, key="ba_grp_dept")
                    grp_acct = st.checkbox("Account", value=False, key="ba_grp_acct")
                    grp_cat = st.checkbox("Category", value=False, key="ba_grp_cat")
                    
                    st.markdown("---")
                    st.caption("**Detail Level (Optional)**")
                    grp_project = st.checkbox("Project", value=False, key="ba_grp_project")
                    grp_vendor = st.checkbox("Vendor", value=False, key="ba_grp_vendor")
                    grp_customer = st.checkbox("Customer", value=False, key="ba_grp_customer")
            
            with f6:
                with st.popover(" Cols"):
                    show_budget = st.checkbox("Budget", value=True, key="ba_sb2")
                    show_prior = st.checkbox("Prior Year", value=True, key="ba_sp2")
                    show_var = st.checkbox("$ Variance", value=True, key="ba_sv2")
                    show_pct = st.checkbox("% Variance", value=True, key="ba_spct2")
                    show_totals = st.checkbox("Totals Row", value=True, key="ba_st2")
            
            # Apply filters
            filtered_df = df.copy()
            if selected_le != 'All Entities' and le_col in filtered_df.columns:
                filtered_df = filtered_df[filtered_df[le_col] == selected_le]
            if selected_dept != 'All Departments' and dept_col and dept_col in filtered_df.columns:
                filtered_df = filtered_df[filtered_df[dept_col] == selected_dept]
            if selected_acct != 'All Accounts' and acct_col and acct_col in filtered_df.columns:
                filtered_df = filtered_df[filtered_df[acct_col] == selected_acct]
            if selected_cat != 'All Categories' and cat_col and cat_col in filtered_df.columns:
                filtered_df = filtered_df[filtered_df[cat_col] == selected_cat]
            
            # Build group columns based on checkbox selections - use columns that exist
            group_cols = []
            
            # CC Level grouping
            if grp_le:
                if 'Legal_Entity' in df.columns:
                    group_cols.append('Legal_Entity')
                elif 'Business_Unit' in df.columns:
                    group_cols.append('Business_Unit')
                if 'Business_Unit_Name' in df.columns:
                    group_cols.append('Business_Unit_Name')
            if grp_dept:
                if 'Department' in df.columns:
                    group_cols.append('Department')
                elif 'Cost_Center' in df.columns:
                    group_cols.append('Cost_Center')
                if 'Cost_Center_Name' in df.columns and 'Cost_Center' not in group_cols:
                    group_cols.append('Cost_Center_Name')
            if grp_acct:
                if 'Account' in df.columns:
                    group_cols.append('Account')
                elif 'GL_Account' in df.columns:
                    group_cols.append('GL_Account')
                if 'GL_Account_Name' in df.columns and 'GL_Account' not in group_cols:
                    group_cols.append('GL_Account_Name')
                if 'Account_Name' in df.columns:
                    group_cols.append('Account_Name')
            if grp_cat:
                if 'Category' in df.columns:
                    group_cols.append('Category')
                elif 'Account_Category' in df.columns:
                    group_cols.append('Account_Category')
            
            # Detail Level grouping
            if grp_project:
                if 'Project' in df.columns:
                    group_cols.append('Project')
            if grp_vendor:
                if 'Vendor' in df.columns:
                    group_cols.append('Vendor')
            if grp_customer:
                if 'Customer' in df.columns:
                    group_cols.append('Customer')
            
            # Default grouping if nothing selected - use available columns
            if not group_cols:
                if 'Legal_Entity' in df.columns:
                    group_cols = ['Legal_Entity']
                elif 'Business_Unit' in df.columns:
                    group_cols = ['Business_Unit']
                elif 'Department' in df.columns:
                    group_cols = ['Department']
                elif 'Category' in df.columns:
                    group_cols = ['Category']
                else:
                    group_cols = [df.columns[0]]  # Use first column as fallback
            
            # -----------------------------------------------------------------
            # DATA PROCESSING
            # -----------------------------------------------------------------
            budget_df = filtered_df[filtered_df['Year'] == planning_year].copy()
            prior_df = filtered_df[filtered_df['Year'] == compare_year].copy()
            
            # Filter group_cols to only include columns that exist in both dataframes
            available_cols = set(budget_df.columns) & set(prior_df.columns) if not budget_df.empty and not prior_df.empty else set(filtered_df.columns)
            group_cols = [c for c in group_cols if c in available_cols]
            if not group_cols:
                # Fallback - use first available column
                group_cols = [list(available_cols)[0]] if available_cols else ['index']
            
            if budget_df.empty and prior_df.empty:
                st.warning("No data for selected filters.")
            elif 'Amount' not in filtered_df.columns:
                st.warning("Data missing 'Amount' column. Please check your data format.")
            else:
                # Process based on view period
                if view_period == 'Annual':
                    budget_agg = budget_df.groupby(group_cols)['Amount'].sum().reset_index().rename(columns={'Amount': 'Budget'})
                    prior_agg = prior_df.groupby(group_cols)['Amount'].sum().reset_index().rename(columns={'Amount': 'Prior_Year'})
                    
                    display_df = budget_agg.merge(prior_agg, on=group_cols, how='outer').fillna(0)
                    display_df['Variance'] = display_df['Budget'] - display_df['Prior_Year']
                    display_df['Var_%'] = display_df.apply(lambda row: round((row['Variance'] / row['Prior_Year'] * 100), 1) if row['Prior_Year'] != 0 else 0, axis=1)
                    
                    final_cols = group_cols.copy()
                    if show_budget: final_cols.append('Budget')
                    if show_prior: final_cols.append('Prior_Year')
                    if show_var: final_cols.append('Variance')
                    if show_pct: final_cols.append('Var_%')
                    display_df = display_df[final_cols].sort_values('Budget', ascending=False)
                    
                elif view_period == 'Quarterly':
                    def get_qtr(m): return 'Q1' if m in ['Jan','Feb','Mar'] else 'Q2' if m in ['Apr','May','Jun'] else 'Q3' if m in ['Jul','Aug','Sep'] else 'Q4'
                    budget_df['Quarter'] = budget_df['Month'].apply(get_qtr)
                    prior_df['Quarter'] = prior_df['Month'].apply(get_qtr)
                    
                    budget_qtr = budget_df.groupby(group_cols + ['Quarter'])['Amount'].sum().reset_index()
                    prior_qtr = prior_df.groupby(group_cols + ['Quarter'])['Amount'].sum().reset_index()
                    
                    budget_pivot = budget_qtr.pivot_table(index=group_cols, columns='Quarter', values='Amount').reindex(columns=['Q1','Q2','Q3','Q4']).fillna(0).reset_index()
                    prior_pivot = prior_qtr.pivot_table(index=group_cols, columns='Quarter', values='Amount').reindex(columns=['Q1','Q2','Q3','Q4']).fillna(0).reset_index()
                    
                    for q in ['Q1','Q2','Q3','Q4']:
                        budget_pivot = budget_pivot.rename(columns={q: f'{q}_Bud'})
                        prior_pivot = prior_pivot.rename(columns={q: f'{q}_PY'})
                    
                    display_df = budget_pivot.merge(prior_pivot, on=group_cols, how='outer').fillna(0)
                    
                    final_cols = group_cols.copy()
                    for q in ['Q1','Q2','Q3','Q4']:
                        display_df[f'{q}_Var'] = display_df[f'{q}_Bud'] - display_df[f'{q}_PY']
                        display_df[f'{q}_%'] = display_df.apply(
                            lambda row: round((row[f'{q}_Var'] / row[f'{q}_PY'] * 100), 1) if row[f'{q}_PY'] != 0 else 0, axis=1)
                        if show_budget: final_cols.append(f'{q}_Bud')
                        if show_prior: final_cols.append(f'{q}_PY')
                        if show_var: final_cols.append(f'{q}_Var')
                        if show_pct: final_cols.append(f'{q}_%')
                    
                    display_df['Total_Bud'] = display_df[[f'{q}_Bud' for q in ['Q1','Q2','Q3','Q4']]].sum(axis=1)
                    display_df['Total_PY'] = display_df[[f'{q}_PY' for q in ['Q1','Q2','Q3','Q4']]].sum(axis=1)
                    display_df['Total_Var'] = display_df['Total_Bud'] - display_df['Total_PY']
                    display_df['Total_%'] = display_df.apply(
                        lambda row: round((row['Total_Var'] / row['Total_PY'] * 100), 1) if row['Total_PY'] != 0 else 0, axis=1)
                    if show_budget: final_cols.append('Total_Bud')
                    if show_prior: final_cols.append('Total_PY')
                    if show_var: final_cols.append('Total_Var')
                    if show_pct: final_cols.append('Total_%')
                    display_df = display_df[final_cols]
                    
                else:  # Monthly
                    budget_monthly = budget_df.groupby(group_cols + ['Month', 'Month_Num'])['Amount'].sum().reset_index()
                    prior_monthly = prior_df.groupby(group_cols + ['Month', 'Month_Num'])['Amount'].sum().reset_index()
                    
                    budget_pivot = budget_monthly.pivot_table(index=group_cols, columns='Month', values='Amount').reindex(columns=MONTHS).fillna(0).reset_index()
                    prior_pivot = prior_monthly.pivot_table(index=group_cols, columns='Month', values='Amount').reindex(columns=MONTHS).fillna(0).reset_index()
                    
                    for m in MONTHS:
                        budget_pivot = budget_pivot.rename(columns={m: f'{m[:3]}B'})
                        prior_pivot = prior_pivot.rename(columns={m: f'{m[:3]}P'})
                    
                    display_df = budget_pivot.merge(prior_pivot, on=group_cols, how='outer').fillna(0)
                    
                    final_cols = group_cols.copy()
                    for m in MONTHS:
                        if show_budget: final_cols.append(f'{m[:3]}B')
                        if show_prior: final_cols.append(f'{m[:3]}P')
                    display_df = display_df[final_cols]
                
                # Add totals row
                if show_totals and len(display_df) > 0:
                    totals = {}
                    for i, col in enumerate(display_df.columns):
                        if col in group_cols:
                            totals[col] = 'TOTAL' if i == 0 else ''
                        elif display_df[col].dtype in ['int64', 'float64']:
                            totals[col] = display_df[col].sum()
                        else:
                            totals[col] = ''
                    # Recalc percentages
                    for col in display_df.columns:
                        if '_%' in col:
                            base_col = col.replace('_%', '_PY').replace('Var_%', 'Prior_Year')
                            var_col = col.replace('_%', '_Var').replace('Var_%', 'Variance')
                            if base_col in totals and var_col in totals and totals.get(base_col, 0) != 0:
                                totals[col] = round(totals[var_col] / totals[base_col] * 100, 1)
                    display_df = pd.concat([display_df, pd.DataFrame([totals])], ignore_index=True)
                
                # -----------------------------------------------------------------
                # DISPLAY TABLE
                # -----------------------------------------------------------------
                col_config = {}
                for col in display_df.columns:
                    if col not in group_cols:
                        if '_%' in col:
                            col_config[col] = st.column_config.NumberColumn(col, format="%.1f%%", width="small")
                        else:
                            col_config[col] = st.column_config.NumberColumn(col, format="$%.0f", width="small")
                
                table_height = 300 if show_charts else 500
                st.dataframe(display_df, use_container_width=True, height=table_height, column_config=col_config, hide_index=True)
                
                # -----------------------------------------------------------------
                # ANALYSIS CHARTS (collapsible)
                # -----------------------------------------------------------------
                if show_charts:
                    c1, c2, c3 = st.columns(3)
                    
                    with c1:
                        st.caption(" Budget Mix")
                        if 'Account_Category' in filtered_df.columns:
                            cat_data = filtered_df[filtered_df['Year'] == planning_year].groupby('Account_Category')['Amount'].sum()
                            fig = go.Figure(go.Pie(labels=cat_data.index, values=cat_data.values, hole=0.4, textinfo='percent', textposition='outside'))
                            fig.update_layout(height=200, margin=dict(l=0, r=0, t=0, b=0), showlegend=False)
                            st.plotly_chart(fig, use_container_width=True)
                    
                    with c2:
                        st.caption(" YoY Variance")
                        if 'Account_Category' in filtered_df.columns:
                            bud_cat = filtered_df[filtered_df['Year'] == planning_year].groupby('Account_Category')['Amount'].sum()
                            py_cat = filtered_df[filtered_df['Year'] == compare_year].groupby('Account_Category')['Amount'].sum()
                            var_cat = (bud_cat - py_cat).sort_values()
                            colors = ['#ef4444' if v < 0 else '#22c55e' for v in var_cat.values]
                            fig = go.Figure(go.Bar(x=var_cat.values, y=var_cat.index, orientation='h', marker_color=colors))
                            fig.update_layout(height=200, margin=dict(l=0, r=0, t=0, b=0), xaxis_tickformat='$,.0f')
                            st.plotly_chart(fig, use_container_width=True)
                    
                    with c3:
                        st.caption(" Monthly Trend")
                        monthly_bud = budget_df.groupby('Month_Num')['Amount'].sum().sort_index()
                        monthly_py = prior_df.groupby('Month_Num')['Amount'].sum().sort_index()
                        fig = go.Figure()
                        fig.add_trace(go.Scatter(x=list(range(1,13)), y=monthly_bud.reindex(range(1,13)).fillna(0).values, name=str(planning_year), line=dict(color='#3b82f6')))
                        fig.add_trace(go.Scatter(x=list(range(1,13)), y=monthly_py.reindex(range(1,13)).fillna(0).values, name=str(compare_year), line=dict(color='#9ca3af', dash='dot')))
                        fig.update_layout(height=200, margin=dict(l=0, r=0, t=0, b=0), xaxis=dict(ticktext=['J','F','M','A','M','J','J','A','S','O','N','D'], tickvals=list(range(1,13))), showlegend=True, legend=dict(orientation='h', y=1.1))
                        st.plotly_chart(fig, use_container_width=True)
                
                # -----------------------------------------------------------------
                # INSIGHTS & DRILL-DOWN
                # -----------------------------------------------------------------
                with st.expander(" Variance Insights & Drill-Down", expanded=False):
                    ins1, ins2 = st.columns(2)
                    
                    with ins1:
                        st.markdown("**Top 5 Largest Increases**")
                        if not budget_df.empty and not prior_df.empty:
                            bud_cc = budget_df.groupby(['Cost_Center_Name'])['Amount'].sum()
                            py_cc = prior_df.groupby(['Cost_Center_Name'])['Amount'].sum()
                            var_cc = (bud_cc - py_cc).sort_values(ascending=False).head(5)
                            for cc, val in var_cc.items():
                                pct = (val / py_cc.get(cc, 1) * 100) if py_cc.get(cc, 0) != 0 else 0
                                st.markdown(f" **{cc}**: ${val/1e6:+.2f}M ({pct:+.1f}%)")
                    
                    with ins2:
                        st.markdown("**Top 5 Largest Decreases**")
                        if not budget_df.empty and not prior_df.empty:
                            bud_cc = budget_df.groupby(['Cost_Center_Name'])['Amount'].sum()
                            py_cc = prior_df.groupby(['Cost_Center_Name'])['Amount'].sum()
                            var_cc = (bud_cc - py_cc).sort_values(ascending=True).head(5)
                            for cc, val in var_cc.items():
                                pct = (val / py_cc.get(cc, 1) * 100) if py_cc.get(cc, 0) != 0 else 0
                                st.markdown(f" **{cc}**: ${val/1e6:+.2f}M ({pct:+.1f}%)")
                    
                    st.markdown("---")
                    st.markdown("**Category Breakdown**")
                    if 'Account_Category' in filtered_df.columns:
                        cat_summary = []
                        for cat in filtered_df['Account_Category'].unique():
                            cat_bud = budget_df[budget_df['Account_Category'] == cat]['Amount'].sum()
                            cat_py = prior_df[prior_df['Account_Category'] == cat]['Amount'].sum()
                            cat_var = cat_bud - cat_py
                            cat_pct = (cat_var / cat_py * 100) if cat_py > 0 else 0
                            cat_summary.append({'Category': cat, 'Budget': cat_bud, 'Prior': cat_py, 'Variance': cat_var, 'Var%': cat_pct})
                        cat_df = pd.DataFrame(cat_summary).sort_values('Variance', key=abs, ascending=False)
                        st.dataframe(cat_df, column_config={
                            'Budget': st.column_config.NumberColumn(format='$%.0f'),
                            'Prior': st.column_config.NumberColumn(format='$%.0f'),
                            'Variance': st.column_config.NumberColumn(format='$%.0f'),
                            'Var%': st.column_config.NumberColumn(format='%.1f%%')
                        }, hide_index=True, use_container_width=True)
                
                # -----------------------------------------------------------------
                # EXPORT ROW
                # -----------------------------------------------------------------
                e1, e2, e3, e4, e5 = st.columns([1, 1, 1, 1, 2])
                with e1:
                    if st.button(" Save", use_container_width=True, type="primary"):
                        st.toast("Budget saved!")
                with e2:
                    output = io.BytesIO()
                    display_df.to_excel(output, index=False)
                    st.download_button(" Excel", output.getvalue(), f"budget_{planning_year}.xlsx", use_container_width=True)
                with e3:
                    st.download_button(" CSV", display_df.to_csv(index=False), f"budget_{planning_year}.csv", use_container_width=True)
                with e4:
                    if st.button(" Refresh", use_container_width=True):
                        st.rerun()

    with tab3:
        # =================================================================
        # YEAR-OVER-YEAR ANALYSIS - COMPACT DESIGN
        # =================================================================
        
        if st.session_state.budget_data.empty and ('budget_data_enhanced' not in st.session_state or st.session_state.budget_data_enhanced.empty):
            st.info("Load budget data first to see Year-over-Year comparisons.")
        else:
            # Use enhanced data if available, otherwise use regular budget data
            if 'budget_data_enhanced' in st.session_state and not st.session_state.budget_data_enhanced.empty:
                df = st.session_state.budget_data_enhanced
                available_years = sorted(df['Year'].unique().tolist(), reverse=True)
            else:
                # Generate historical data
                if not st.session_state.historical_data.get('budget'):
                    st.session_state.historical_data['budget'] = YearOverYearAnalysis.generate_historical_data(
                        st.session_state.budget_data, years_back=4
                    )
                df = st.session_state.budget_data
                available_years = sorted(st.session_state.historical_data['budget'].keys(), reverse=True)
            
            current_year = datetime.now().year
            
            # -----------------------------------------------------------------
            # HEADER: YoY Summary Metrics
            # -----------------------------------------------------------------
            if 'budget_data_enhanced' in st.session_state and not st.session_state.budget_data_enhanced.empty:
                y1 = df[df['Year'] == current_year]['Amount'].sum() if current_year in df['Year'].values else 0
                y2 = df[df['Year'] == current_year - 1]['Amount'].sum() if current_year - 1 in df['Year'].values else 0
                y3 = df[df['Year'] == current_year - 2]['Amount'].sum() if current_year - 2 in df['Year'].values else 0
            else:
                y1 = st.session_state.historical_data['budget'].get(current_year, pd.DataFrame())['Budget'].sum() if current_year in st.session_state.historical_data['budget'] else 0
                y2 = st.session_state.historical_data['budget'].get(current_year - 1, pd.DataFrame())['Budget'].sum() if current_year - 1 in st.session_state.historical_data['budget'] else 0
                y3 = st.session_state.historical_data['budget'].get(current_year - 2, pd.DataFrame())['Budget'].sum() if current_year - 2 in st.session_state.historical_data['budget'] else 0
            
            yoy_var1 = ((y1 - y2) / y2 * 100) if y2 > 0 else 0
            yoy_var2 = ((y2 - y3) / y3 * 100) if y3 > 0 else 0
            cagr = ((y1 / y3) ** 0.5 - 1) * 100 if y3 > 0 and y1 > 0 else 0
            
            m1, m2, m3, m4, m5, m6 = st.columns(6)
            with m1:
                st.metric(f"FY{current_year}", f"${y1/1e6:.1f}M", delta=f"{yoy_var1:+.1f}% YoY")
            with m2:
                st.metric(f"FY{current_year-1}", f"${y2/1e6:.1f}M", delta=f"{yoy_var2:+.1f}% YoY")
            with m3:
                st.metric(f"FY{current_year-2}", f"${y3/1e6:.1f}M")
            with m4:
                st.metric("2-Yr CAGR", f"{cagr:.1f}%", help="Compound Annual Growth Rate")
            with m5:
                st.metric("Avg YoY Growth", f"{(yoy_var1+yoy_var2)/2:.1f}%")
            with m6:
                st.metric("Total Growth", f"{((y1-y3)/y3*100):.1f}%" if y3 > 0 else "N/A")
            
            st.markdown("---")
            
            # -----------------------------------------------------------------
            # CONTROLS: Filters + Period + Group By + Options
            # -----------------------------------------------------------------
            c1, c2, c3, c4, c5, c6 = st.columns([1.2, 1.2, 1.2, 1.2, 0.8, 0.6])
            
            with c1:
                if 'budget_data_enhanced' in st.session_state and not st.session_state.budget_data_enhanced.empty:
                    # Legal Entity / Business Unit filter
                    le_col = 'Legal_Entity' if 'Legal_Entity' in df.columns else ('Business_Unit' if 'Business_Unit' in df.columns else None)
                    if le_col:
                        le_opts = ['All Entities'] + sorted(df[le_col].dropna().unique().tolist())
                    else:
                        le_opts = ['All Entities']
                    yoy_le = st.selectbox("Entity", le_opts, key="yoy_le", label_visibility="collapsed")
                else:
                    yoy_le = 'All Entities'
                    st.text("All Data")
            
            with c2:
                if 'budget_data_enhanced' in st.session_state and not st.session_state.budget_data_enhanced.empty:
                    cat_col = 'Category' if 'Category' in df.columns else ('Account_Category' if 'Account_Category' in df.columns else None)
                    if cat_col:
                        cat_opts = ['All Categories'] + sorted(df[cat_col].dropna().unique().tolist())
                    else:
                        cat_opts = ['All Categories']
                    yoy_cat = st.selectbox("Category", cat_opts, key="yoy_cat", label_visibility="collapsed")
                else:
                    yoy_cat = 'All Categories'
            
            with c3:
                years_to_show = st.multiselect("Years", available_years, default=available_years[:3], key="yoy_years")
            
            with c4:
                yoy_period = st.selectbox("View Period", ['Annual', 'Quarterly', 'Monthly'], key="yoy_period", label_visibility="collapsed")
            
            with c5:
                with st.popover(" Group"):
                    st.caption("**CC Level**")
                    yoy_grp_le = st.checkbox("Legal Entity", value=True, key="yoy_grp_le")
                    yoy_grp_dept = st.checkbox("Department", value=False, key="yoy_grp_dept")
                    yoy_grp_cat = st.checkbox("Category", value=False, key="yoy_grp_cat")
            
            with c6:
                show_yoy_charts = st.toggle("", value=True, key="yoy_charts_toggle", help="Show charts")
            
            # Build group columns
            yoy_group_cols = []
            if 'budget_data_enhanced' in st.session_state and not st.session_state.budget_data_enhanced.empty:
                if yoy_grp_le:
                    if 'Legal_Entity' in df.columns:
                        yoy_group_cols.append('Legal_Entity')
                    elif 'Business_Unit' in df.columns:
                        yoy_group_cols.append('Business_Unit')
                    if 'Business_Unit_Name' in df.columns:
                        yoy_group_cols.append('Business_Unit_Name')
                if yoy_grp_dept:
                    if 'Department' in df.columns:
                        yoy_group_cols.append('Department')
                    elif 'Cost_Center' in df.columns:
                        yoy_group_cols.append('Cost_Center')
                    if 'Cost_Center_Name' in df.columns and 'Cost_Center' not in yoy_group_cols:
                        yoy_group_cols.append('Cost_Center_Name')
                if yoy_grp_cat:
                    if 'Category' in df.columns:
                        yoy_group_cols.append('Category')
                    elif 'Account_Category' in df.columns:
                        yoy_group_cols.append('Account_Category')
                if not yoy_group_cols:
                    if 'Legal_Entity' in df.columns:
                        yoy_group_cols = ['Legal_Entity']
                    elif 'Business_Unit' in df.columns:
                        yoy_group_cols = ['Business_Unit', 'Business_Unit_Name']
                    else:
                        yoy_group_cols = ['Category'] if 'Category' in df.columns else ['Account_Category']
            
            # -----------------------------------------------------------------
            # DATA PROCESSING
            # -----------------------------------------------------------------
            if 'budget_data_enhanced' in st.session_state and not st.session_state.budget_data_enhanced.empty:
                # Filter data
                work_df = df.copy()
                
                # Apply entity filter
                le_col = 'Legal_Entity' if 'Legal_Entity' in df.columns else ('Business_Unit' if 'Business_Unit' in df.columns else None)
                if yoy_le != 'All Entities' and le_col and le_col in work_df.columns:
                    work_df = work_df[work_df[le_col] == yoy_le]
                
                # Apply category filter
                cat_col = 'Category' if 'Category' in df.columns else ('Account_Category' if 'Account_Category' in df.columns else None)
                if yoy_cat != 'All Categories' and cat_col and cat_col in work_df.columns:
                    work_df = work_df[work_df[cat_col] == yoy_cat]
                
                # Build YoY comparison table based on period
                if yoy_period == 'Annual':
                    # Annual view - original logic
                    yoy_data = None
                    for year in sorted(years_to_show, reverse=True):
                        year_df = work_df[work_df['Year'] == year]
                        if not year_df.empty:
                            year_agg = year_df.groupby(yoy_group_cols)['Amount'].sum().reset_index()
                            year_agg = year_agg.rename(columns={'Amount': f'FY{year}'})
                            if yoy_data is None:
                                yoy_data = year_agg
                            else:
                                yoy_data = yoy_data.merge(year_agg, on=yoy_group_cols, how='outer')
                    
                    if yoy_data is None:
                        yoy_display = pd.DataFrame()
                    else:
                        yoy_display = yoy_data.fillna(0)
                        
                        # Calculate variances
                        sorted_years = sorted(years_to_show, reverse=True)
                        for i in range(len(sorted_years) - 1):
                            curr_yr = sorted_years[i]
                            prev_yr = sorted_years[i + 1]
                            curr_col = f'FY{curr_yr}'
                            prev_col = f'FY{prev_yr}'
                            var_col = f'{str(curr_yr)[-2:]}v{str(prev_yr)[-2:]}_$'
                            pct_col = f'{str(curr_yr)[-2:]}v{str(prev_yr)[-2:]}_%'
                            
                            if curr_col in yoy_display.columns and prev_col in yoy_display.columns:
                                yoy_display[var_col] = yoy_display[curr_col] - yoy_display[prev_col]
                                yoy_display[pct_col] = np.where(yoy_display[prev_col] != 0, 
                                    (yoy_display[var_col] / yoy_display[prev_col] * 100).round(1), 0)
                
                elif yoy_period == 'Quarterly':
                    # Quarterly view
                    def get_qtr(m): return 'Q1' if m in ['Jan','Feb','Mar'] else 'Q2' if m in ['Apr','May','Jun'] else 'Q3' if m in ['Jul','Aug','Sep'] else 'Q4'
                    work_df['Quarter'] = work_df['Month'].apply(get_qtr)
                    
                    yoy_data = None
                    for year in sorted(years_to_show, reverse=True):
                        year_df = work_df[work_df['Year'] == year]
                        if not year_df.empty:
                            year_qtr = year_df.groupby(yoy_group_cols + ['Quarter'])['Amount'].sum().reset_index()
                            year_pivot = year_qtr.pivot_table(index=yoy_group_cols, columns='Quarter', values='Amount').reindex(columns=['Q1','Q2','Q3','Q4']).fillna(0).reset_index()
                            
                            # Rename columns with year prefix
                            for q in ['Q1','Q2','Q3','Q4']:
                                if q in year_pivot.columns:
                                    year_pivot = year_pivot.rename(columns={q: f'{year}_{q}'})
                            
                            # Add annual total
                            q_cols = [f'{year}_{q}' for q in ['Q1','Q2','Q3','Q4'] if f'{year}_{q}' in year_pivot.columns]
                            if q_cols:
                                year_pivot[f'{year}_Total'] = year_pivot[q_cols].sum(axis=1)
                            
                            if yoy_data is None:
                                yoy_data = year_pivot
                            else:
                                yoy_data = yoy_data.merge(year_pivot, on=yoy_group_cols, how='outer')
                    
                    yoy_display = yoy_data.fillna(0) if yoy_data is not None else pd.DataFrame()
                    
                    # Calculate YoY variance for totals
                    if len(years_to_show) >= 2:
                        sorted_years = sorted(years_to_show, reverse=True)
                        curr_yr, prev_yr = sorted_years[0], sorted_years[1]
                        curr_col, prev_col = f'{curr_yr}_Total', f'{prev_yr}_Total'
                        if curr_col in yoy_display.columns and prev_col in yoy_display.columns:
                            yoy_display['YoY_$'] = yoy_display[curr_col] - yoy_display[prev_col]
                            yoy_display['YoY_%'] = np.where(yoy_display[prev_col] != 0, 
                                (yoy_display['YoY_$'] / yoy_display[prev_col] * 100).round(1), 0)
                
                else:  # Monthly
                    yoy_data = None
                    for year in sorted(years_to_show, reverse=True):
                        year_df = work_df[work_df['Year'] == year]
                        if not year_df.empty:
                            year_monthly = year_df.groupby(yoy_group_cols + ['Month', 'Month_Num'])['Amount'].sum().reset_index()
                            year_pivot = year_monthly.pivot_table(index=yoy_group_cols, columns='Month', values='Amount').reindex(columns=MONTHS).fillna(0).reset_index()
                            
                            # Rename columns with year prefix
                            for m in MONTHS:
                                if m in year_pivot.columns:
                                    year_pivot = year_pivot.rename(columns={m: f'{year}_{m[:3]}'})
                            
                            # Add annual total
                            m_cols = [f'{year}_{m[:3]}' for m in MONTHS if f'{year}_{m[:3]}' in year_pivot.columns]
                            if m_cols:
                                year_pivot[f'{year}_Total'] = year_pivot[m_cols].sum(axis=1)
                            
                            if yoy_data is None:
                                yoy_data = year_pivot
                            else:
                                yoy_data = yoy_data.merge(year_pivot, on=yoy_group_cols, how='outer')
                    
                    yoy_display = yoy_data.fillna(0) if yoy_data is not None else pd.DataFrame()
                    
                    # Calculate YoY variance
                    if len(years_to_show) >= 2:
                        sorted_years = sorted(years_to_show, reverse=True)
                        curr_yr, prev_yr = sorted_years[0], sorted_years[1]
                        curr_col, prev_col = f'{curr_yr}_Total', f'{prev_yr}_Total'
                        if curr_col in yoy_display.columns and prev_col in yoy_display.columns:
                            yoy_display['YoY_$'] = yoy_display[curr_col] - yoy_display[prev_col]
                            yoy_display['YoY_%'] = np.where(yoy_display[prev_col] != 0, 
                                (yoy_display['YoY_$'] / yoy_display[prev_col] * 100).round(1), 0)
            else:
                # Use historical data approach
                historical = st.session_state.historical_data['budget']
                current_df = st.session_state.budget_data
                
                # Simplified grouping for non-enhanced data
                group_col = 'Cost Center Name' if 'Cost Center Name' in current_df.columns else current_df.columns[0]
                groups = current_df[group_col].unique()
                
                yoy_rows = []
                for group in groups:
                    row = {group_col: group}
                    for year in sorted(years_to_show, reverse=True):
                        if year in historical:
                            year_df = historical[year]
                            if group_col in year_df.columns and 'Budget' in year_df.columns:
                                row[f'FY{year}'] = year_df[year_df[group_col] == group]['Budget'].sum()
                            else:
                                row[f'FY{year}'] = 0
                    yoy_rows.append(row)
                
                yoy_display = pd.DataFrame(yoy_rows)
                yoy_group_cols = [group_col]
            
            # -----------------------------------------------------------------
            # DISPLAY TABLE
            # -----------------------------------------------------------------
            if not yoy_display.empty:
                # Configure columns
                col_config = {}
                for col in yoy_display.columns:
                    if col not in yoy_group_cols:
                        if '_%' in col:
                            col_config[col] = st.column_config.NumberColumn(col, format="%.1f%%", width="small")
                        else:
                            col_config[col] = st.column_config.NumberColumn(col, format="$%.0f", width="small")
                
                # Add totals row
                totals = {}
                for col in yoy_display.columns:
                    if col in yoy_group_cols:
                        totals[col] = 'TOTAL' if yoy_display.columns.get_loc(col) == 0 else ''
                    elif yoy_display[col].dtype in ['int64', 'float64']:
                        totals[col] = yoy_display[col].sum()
                
                # Recalc pct for totals
                for col in yoy_display.columns:
                    if '_%' in col:
                        var_col = col.replace('_%', '_$')
                        # Find the prior year column
                        parts = col.replace('_%', '').split('v')
                        if len(parts) == 2:
                            prev_col = f'FY20{parts[1]}'
                            if prev_col in totals and var_col in totals and totals.get(prev_col, 0) != 0:
                                totals[col] = round(totals[var_col] / totals[prev_col] * 100, 1)
                
                yoy_display = pd.concat([yoy_display, pd.DataFrame([totals])], ignore_index=True)
                
                table_height = 250 if show_yoy_charts else 450
                st.dataframe(yoy_display, use_container_width=True, height=table_height, column_config=col_config, hide_index=True)
                
                # -----------------------------------------------------------------
                # CHARTS - Enhanced with Growth by Category
                # -----------------------------------------------------------------
                if show_yoy_charts:
                    ch1, ch2, ch3 = st.columns(3)
                    
                    with ch1:
                        st.caption(" YoY Trend by Group")
                        # Get top 5 groups by latest year value
                        if len(yoy_group_cols) > 0 and len(years_to_show) > 0:
                            display_col = yoy_group_cols[0] if 'Name' not in yoy_group_cols[0] else (yoy_group_cols[1] if len(yoy_group_cols) > 1 else yoy_group_cols[0])
                            
                            # Find the right column based on period
                            if yoy_period == 'Annual':
                                latest_col = f'FY{max(years_to_show)}'
                            else:
                                latest_col = f'{max(years_to_show)}_Total'
                            
                            if latest_col in yoy_display.columns:
                                data_only = yoy_display[yoy_display[yoy_group_cols[0]] != 'TOTAL'].copy()
                                if not data_only.empty:
                                    top5 = data_only.nlargest(5, latest_col)
                                    
                                    fig = go.Figure()
                                    for yr in sorted(years_to_show):
                                        if yoy_period == 'Annual':
                                            col = f'FY{yr}'
                                        else:
                                            col = f'{yr}_Total'
                                        if col in top5.columns:
                                            fig.add_trace(go.Bar(
                                                name=str(yr),
                                                x=top5[display_col] if display_col in top5.columns else top5[yoy_group_cols[0]],
                                                y=top5[col] / 1e6,
                                                text=[f'${v/1e6:.1f}M' for v in top5[col]],
                                                textposition='outside'
                                            ))
                                    fig.update_layout(barmode='group', height=200, margin=dict(l=0, r=0, t=10, b=0), yaxis_title='$M', showlegend=True, legend=dict(orientation='h', y=1.15))
                                    st.plotly_chart(fig, use_container_width=True)
                    
                    with ch2:
                        st.caption(" Growth Rate by Group")
                        # Horizontal bar chart showing growth rates
                        if len(yoy_group_cols) > 0:
                            data_only = yoy_display[yoy_display[yoy_group_cols[0]] != 'TOTAL'].copy()
                            
                            # Find percentage column
                            pct_cols = [c for c in yoy_display.columns if '_%' in c]
                            if pct_cols and not data_only.empty:
                                pct_col = pct_cols[0]
                                display_col = yoy_group_cols[-1] if len(yoy_group_cols) > 1 else yoy_group_cols[0]
                                
                                # Sort by growth rate
                                sorted_data = data_only.sort_values(pct_col, ascending=True).tail(10)
                                
                                colors = ['#ef4444' if v < 0 else '#22c55e' if v > 0 else '#6b7280' for v in sorted_data[pct_col]]
                                
                                fig = go.Figure(go.Bar(
                                    x=sorted_data[pct_col],
                                    y=sorted_data[display_col] if display_col in sorted_data.columns else sorted_data[yoy_group_cols[0]],
                                    orientation='h',
                                    marker_color=colors,
                                    text=[f'{v:+.1f}%' for v in sorted_data[pct_col]],
                                    textposition='outside'
                                ))
                                fig.update_layout(height=200, margin=dict(l=0, r=0, t=10, b=0), xaxis_title='YoY Growth %', xaxis=dict(zeroline=True, zerolinewidth=2, zerolinecolor='gray'))
                                st.plotly_chart(fig, use_container_width=True)
                    
                    with ch3:
                        st.caption(" Growth by Category")
                        # Category growth chart
                        if 'budget_data_enhanced' in st.session_state and not st.session_state.budget_data_enhanced.empty:
                            cat_growth = []
                            for cat in df['Account_Category'].unique():
                                curr_val = df[(df['Year'] == max(years_to_show)) & (df['Account_Category'] == cat)]['Amount'].sum()
                                if len(years_to_show) >= 2:
                                    prev_val = df[(df['Year'] == sorted(years_to_show, reverse=True)[1]) & (df['Account_Category'] == cat)]['Amount'].sum()
                                    growth = ((curr_val - prev_val) / prev_val * 100) if prev_val > 0 else 0
                                else:
                                    growth = 0
                                cat_growth.append({'Category': cat, 'Growth': growth, 'Value': curr_val})
                            
                            cat_df = pd.DataFrame(cat_growth).sort_values('Growth', ascending=True)
                            colors = ['#ef4444' if v < 0 else '#22c55e' for v in cat_df['Growth']]
                            
                            fig = go.Figure(go.Bar(
                                x=cat_df['Growth'],
                                y=cat_df['Category'],
                                orientation='h',
                                marker_color=colors,
                                text=[f'{v:+.1f}%' for v in cat_df['Growth']],
                                textposition='outside'
                            ))
                            fig.update_layout(height=200, margin=dict(l=0, r=0, t=10, b=0), xaxis_title='YoY Growth %', xaxis=dict(zeroline=True, zerolinewidth=2, zerolinecolor='gray'))
                            st.plotly_chart(fig, use_container_width=True)
                
                # -----------------------------------------------------------------
                # VARIANCE ANALYSIS
                # -----------------------------------------------------------------
                with st.expander(" Detailed Variance Analysis", expanded=False):
                    va1, va2 = st.columns(2)
                    
                    with va1:
                        st.markdown("**Largest Increases**")
                        pct_cols = [c for c in yoy_display.columns if '_%' in c]
                        if pct_cols:
                            var_col = pct_cols[0].replace('_%', '_$')
                            data_only = yoy_display[yoy_display[yoy_group_cols[0]] != 'TOTAL'].copy()
                            if var_col in data_only.columns:
                                top_inc = data_only.nlargest(5, var_col)
                                display_col = yoy_group_cols[-1] if len(yoy_group_cols) > 1 else yoy_group_cols[0]
                                for _, row in top_inc.iterrows():
                                    name = row[display_col] if display_col in row else row[yoy_group_cols[0]]
                                    val = row[var_col]
                                    pct = row[pct_cols[0]]
                                    st.markdown(f" **{name}**: ${val/1e6:+.2f}M ({pct:+.1f}%)")
                    
                    with va2:
                        st.markdown("**Largest Decreases**")
                        if pct_cols:
                            var_col = pct_cols[0].replace('_%', '_$')
                            data_only = yoy_display[yoy_display[yoy_group_cols[0]] != 'TOTAL'].copy()
                            if var_col in data_only.columns:
                                top_dec = data_only.nsmallest(5, var_col)
                                display_col = yoy_group_cols[-1] if len(yoy_group_cols) > 1 else yoy_group_cols[0]
                                for _, row in top_dec.iterrows():
                                    name = row[display_col] if display_col in row else row[yoy_group_cols[0]]
                                    val = row[var_col]
                                    pct = row[pct_cols[0]]
                                    st.markdown(f" **{name}**: ${val/1e6:+.2f}M ({pct:+.1f}%)")
                    
                    st.markdown("---")
                    st.markdown("**Category Trend Summary**")
                    if 'budget_data_enhanced' in st.session_state and not st.session_state.budget_data_enhanced.empty:
                        cat_trend = []
                        for cat in df['Account_Category'].unique():
                            cat_row = {'Category': cat}
                            for yr in sorted(years_to_show, reverse=True):
                                cat_row[f'FY{yr}'] = df[(df['Year'] == yr) & (df['Account_Category'] == cat)]['Amount'].sum()
                            if len(years_to_show) >= 2:
                                curr = cat_row.get(f'FY{max(years_to_show)}', 0)
                                prev = cat_row.get(f'FY{sorted(years_to_show)[-2]}', 0)
                                cat_row['YoY_%'] = ((curr - prev) / prev * 100) if prev > 0 else 0
                            cat_trend.append(cat_row)
                        
                        cat_df = pd.DataFrame(cat_trend).sort_values(f'FY{max(years_to_show)}', ascending=False)
                        st.dataframe(cat_df, column_config={
                            **{f'FY{yr}': st.column_config.NumberColumn(format='$%.0f') for yr in years_to_show},
                            'YoY_%': st.column_config.NumberColumn('YoY %', format='%.1f%%')
                        }, hide_index=True, use_container_width=True)
                
                # Export
                e1, e2, e3 = st.columns([1, 1, 4])
                with e1:
                    output = io.BytesIO()
                    yoy_display.to_excel(output, index=False)
                    st.download_button(" Excel", output.getvalue(), "yoy_analysis.xlsx", use_container_width=True)
                with e2:
                    st.download_button(" CSV", yoy_display.to_csv(index=False), "yoy_analysis.csv", use_container_width=True)
    
    with tab1:
        st.markdown("### Import Budget Data")
        
        import_method = st.radio("Import Method", [" Direct Entry", " Template Import", " Simple Import", " Database"], horizontal=True)
        
        # =================================================================
        # DIRECT ENTRY - Table-based budget entry
        # =================================================================
        if import_method == " Direct Entry":
            st.caption("Create budget entries directly in the application")
            
            # Initialize direct entry data stores
            # direct_entry_data = current working view
            # direct_entry_cc_data = Code Combination level data (preserved when switching)
            # direct_entry_detail_data = Detail level data (preserved when switching)
            if 'direct_entry_data' not in st.session_state:
                st.session_state.direct_entry_data = pd.DataFrame()
            if 'direct_entry_cc_data' not in st.session_state:
                st.session_state.direct_entry_cc_data = pd.DataFrame()
            if 'direct_entry_detail_data' not in st.session_state:
                st.session_state.direct_entry_detail_data = pd.DataFrame()
            if 'de_entry_level' not in st.session_state:
                st.session_state.de_entry_level = 'Code Combination'
            if 'de_last_entry_level' not in st.session_state:
                st.session_state.de_last_entry_level = 'Code Combination'
            if 'show_de_edit_dialog' not in st.session_state:
                st.session_state.show_de_edit_dialog = False
            
            # Initialize dialog flags - ensure only one can be open
            if 'de_show_load_dialog' not in st.session_state:
                st.session_state.de_show_load_dialog = False
            if 'de_show_save_dialog' not in st.session_state:
                st.session_state.de_show_save_dialog = False
            if 'de_save_dialog_opened' not in st.session_state:
                st.session_state.de_save_dialog_opened = False
            
            # Safety: if both dialogs are flagged, reset both (should never happen)
            if st.session_state.de_show_load_dialog and st.session_state.de_show_save_dialog:
                st.session_state.de_show_load_dialog = False
                st.session_state.de_show_save_dialog = False
            
            # Reset save dialog if it was already opened once (user clicked away)
            if st.session_state.de_save_dialog_opened and st.session_state.de_show_save_dialog:
                st.session_state.de_show_save_dialog = False
                st.session_state.de_save_dialog_opened = False
            
            # Define dimension options
            legal_entities = ['ES-001 XYZ LLC', 'ES-002 D&D Holdings', 'ES-003 WM Services', 'ES-004 Transportation', 'ES-005 Corporate']
            departments = ['1000 Executive', '2000 Finance', '3000 Operations', '3100 D&D Operations', '3200 WM Operations', 
                          '4000 Engineering', '5000 EHS', '6000 HR', '7000 IT', '8000 Project Controls', '9000 Business Dev']
            accounts = ['5000 Labor', '5100 Salaries', '5200 Wages', '5300 Overtime', '5400 Fringe Benefits',
                       '6000 Materials', '6100 Supplies', '6200 Equipment', '6300 Chemicals',
                       '7000 Subcontracts', '7100 Professional Services', '7200 Temporary Labor',
                       '8000 Travel', '8100 Lodging', '8200 Transportation', '8300 Per Diem',
                       '9000 Other', '9100 Training', '9200 Licensing', '9300 Insurance']
            projects = ['KEW-2025-001 Kewaunee D&D', 'TMI-2025-001 TMI-2 ISFSI', 'CLV-2025-001 Clive Ops', 'BCK-2025-001 Bear Creek', 'CORP-2025 Corporate']
            tasks = ['T001 Project Management', 'T002 Engineering Support', 'T003 Procurement Support', 'T004 Field Execution', 'T005 QA/QC', 'T006 Admin Support']
            work_packages = ['WP001 Mobilization', 'WP002 Site Prep', 'WP003 Decon', 'WP004 Demolition', 'WP005 Waste Packaging', 'WP006 Transport']
            processes = ['01 Planning', '02 Engineering', '03 Procurement', '04 Construction', '05 Testing', '06 Closeout']
            
            # -----------------------------------------------------------------
            # HEADER ROW: Load | Entry Level | Display Toggles | Actions
            # -----------------------------------------------------------------
            st.caption(" Load once  Enter budget at CC level  Add detail to allocate or add new  CC auto-updates")
            
            # -----------------------------------------------------------------
            # DEPARTMENT CONTEXT SELECTOR
            # -----------------------------------------------------------------
            # Check if org lookup is loaded
            has_dept_lookup = 'org_departments' in st.session_state and not st.session_state.org_departments.empty
            
            if 'de_dept_context' not in st.session_state:
                st.session_state.de_dept_context = None
            
            dept_ctx_col1, dept_ctx_col2, dept_ctx_col3 = st.columns([2, 2, 1])
            
            with dept_ctx_col1:
                if has_dept_lookup:
                    dept_options_list = get_department_options()
                    dept_context_options = ['All Departments'] + dept_options_list
                    
                    # Find current index
                    current_idx = 0
                    if st.session_state.de_dept_context and st.session_state.de_dept_context in dept_context_options:
                        current_idx = dept_context_options.index(st.session_state.de_dept_context)
                    
                    selected_dept_context = st.selectbox(
                        " Budget Entry For", 
                        dept_context_options, 
                        index=current_idx,
                        key="de_dept_context_select",
                        help="Select a department to filter and auto-fill entries"
                    )
                    
                    if selected_dept_context != 'All Departments':
                        st.session_state.de_dept_context = selected_dept_context
                    else:
                        st.session_state.de_dept_context = None
                else:
                    st.info(" Upload department data in Settings  Organization to enable department selection")
            
            with dept_ctx_col2:
                # Show auto-mapped info for selected department
                if st.session_state.de_dept_context and has_dept_lookup:
                    dept_num = st.session_state.de_dept_context.split()[0] if st.session_state.de_dept_context else ''
                    dept_info = lookup_department(dept_num)
                    if dept_info:
                        st.caption(f"**{dept_info.get('Legal_Entity_Name', '')}** | {dept_info.get('Organization', '')} | {dept_info.get('Division', '')} | {dept_info.get('Business_Unit', '')}")
            
            with dept_ctx_col3:
                if st.session_state.de_dept_context:
                    if st.button(" Clear", key="de_clear_dept_ctx", use_container_width=True):
                        st.session_state.de_dept_context = None
                        st.rerun()
            
            st.markdown("---")
            
            # -----------------------------------------------------------------
            # HEADER ROW: Load | Entry Level | Display Toggles | Actions
            # -----------------------------------------------------------------
            h0, h1, h2, h3, h4, h5, h6, h7 = st.columns([0.9, 1.2, 0.7, 0.7, 0.7, 0.6, 0.6, 0.9])
            
            with h0:
                if st.button(" Load", use_container_width=True, key="de_load_btn"):
                    st.session_state.de_show_load_dialog = True
                    st.session_state.de_show_save_dialog = False  # Close save dialog if open
                    st.rerun()
            
            # Load Dialog - use elif chain to ensure only one dialog at a time
            if st.session_state.get('de_show_load_dialog', False):
                @st.dialog(" Load Budget Data", width="large")
                def show_load_dialog():
                    # Check for saved versions and corporate versions (unified system)
                    saved_versions = st.session_state.get('saved_budget_versions', {})
                    unified_versions = st.session_state.get('unified_corporate_versions', {})
                    # Filter for Budget Planning corporate versions
                    corporate_versions = {k: v for k, v in unified_versions.items() 
                                         if v.get('page_type') == 'Budget Planning'}
                    
                    # Build list of corporate department contributions
                    corp_dept_options = []
                    for corp_id, corp_info in corporate_versions.items():
                        contributors = corp_info.get('contributors', {})
                        for dept_name, contrib in contributors.items():
                            corp_dept_options.append({
                                'display': f"{corp_info.get('name', corp_id)}  {dept_name}",
                                'corp_id': corp_id,
                                'corp_name': corp_info.get('name', corp_id),
                                'dept_name': dept_name,
                                'total': contrib.get('total', 0),
                                'lines': len(contrib.get('data', pd.DataFrame())) if isinstance(contrib.get('data'), pd.DataFrame) else 0,
                                'updated': contrib.get('saved_at', ''),
                            })
                    
                    # Source options
                    source_options = ["PY Actuals", "PY Budget"]
                    if corp_dept_options:
                        source_options.insert(0, "Corporate Contribution")
                    if saved_versions:
                        source_options.append("Standalone Version")
                    
                    load_source = st.radio("Source", source_options, key="de_load_source", horizontal=True)
                    
                    selected_corp_dept = None
                    selected_saved_version = None
                    
                    # Corporate Contribution selector
                    if load_source == "Corporate Contribution" and corp_dept_options:
                        st.markdown("---")
                        st.markdown("#####  Load Your Department's Contribution")
                        st.caption("Edit your portion of a corporate budget version")
                        
                        corp_dept_display = [opt['display'] for opt in corp_dept_options]
                        selected_display = st.selectbox("Select Department Contribution", corp_dept_display, key="de_load_corp_dept")
                        
                        # Find the selected option
                        for opt in corp_dept_options:
                            if opt['display'] == selected_display:
                                selected_corp_dept = opt
                                break
                        
                        if selected_corp_dept:
                            v1, v2, v3 = st.columns(3)
                            with v1:
                                st.metric("Total Budget", f"${selected_corp_dept['total']:,.0f}")
                            with v2:
                                st.metric("Lines", selected_corp_dept['lines'])
                            with v3:
                                updated = selected_corp_dept['updated']
                                st.metric("Last Updated", updated if updated else "Unknown")
                            
                            # Store the corp_id and dept for later use in save
                            st.session_state.de_loaded_from_corp = {
                                'corp_id': selected_corp_dept['corp_id'],
                                'corp_name': selected_corp_dept['corp_name'],
                                'dept_name': selected_corp_dept['dept_name'],
                            }
                    
                    # Show saved versions selector if that source is selected
                    elif load_source == "Standalone Version" and saved_versions:
                        st.markdown("---")
                        version_list = list(saved_versions.keys())
                        selected_saved_version = st.selectbox("Select Version", version_list, key="de_load_version_select")
                        
                        if selected_saved_version:
                            ver_info = saved_versions[selected_saved_version]
                            v1, v2, v3 = st.columns(3)
                            with v1:
                                st.metric("Total", f"${ver_info.get('total_budget', 0):,.0f}")
                            with v2:
                                st.metric("CC Lines", ver_info.get('cc_count', 0))
                            with v3:
                                st.metric("Detail Lines", ver_info.get('detail_count', 0))
                            st.caption(f"Source: {ver_info.get('source', 'unknown')} | Created: {ver_info.get('created', '').strftime('%Y-%m-%d') if hasattr(ver_info.get('created', ''), 'strftime') else 'unknown'}")
                            
                            # Clear any corporate load context
                            if 'de_loaded_from_corp' in st.session_state:
                                del st.session_state.de_loaded_from_corp
                    else:
                        # PY Actuals or PY Budget - clear corporate context
                        if 'de_loaded_from_corp' in st.session_state:
                            del st.session_state.de_loaded_from_corp
                    
                    st.markdown("---")
                    c1, c2 = st.columns(2)
                    with c1:
                        if st.button(" Load", type="primary", use_container_width=True, key="de_load_confirm"):
                            if load_source == "Corporate Contribution" and selected_corp_dept:
                                # Load from corporate contribution
                                corp_id = selected_corp_dept['corp_id']
                                dept_name = selected_corp_dept['dept_name']
                                contrib = corporate_versions[corp_id]['contributors'][dept_name]
                                ver_data = contrib.get('data', pd.DataFrame())
                                
                                # Handle both old and new data structures
                                if isinstance(ver_data, dict):
                                    # Old structure: data is a dict with cc_data key
                                    cc_df = ver_data.get('cc_data', pd.DataFrame())
                                    detail_df = ver_data.get('detail_data', pd.DataFrame())
                                elif isinstance(ver_data, pd.DataFrame):
                                    # New structure: data is the DataFrame directly
                                    cc_df = ver_data
                                    detail_df = contrib.get('detail_data', pd.DataFrame())
                                else:
                                    cc_df = pd.DataFrame()
                                    detail_df = pd.DataFrame()
                                
                                if isinstance(cc_df, pd.DataFrame) and not cc_df.empty:
                                    st.session_state.direct_entry_cc_data = cc_df.copy()
                                    st.session_state.direct_entry_data = cc_df.copy()
                                if isinstance(detail_df, pd.DataFrame) and not detail_df.empty:
                                    st.session_state.direct_entry_detail_data = detail_df.copy()
                                
                                st.session_state.de_show_load_dialog = False
                                corp_display_name = corporate_versions[corp_id].get('name', corp_id)
                                st.toast(f" Loaded '{dept_name}' from '{corp_display_name}'")
                                st.rerun()
                            elif load_source == "Standalone Version" and selected_saved_version:
                                # Load from saved version
                                ver_data = saved_versions[selected_saved_version].get('data', {})
                                cc_df = ver_data.get('cc_data', pd.DataFrame())
                                detail_df = ver_data.get('detail_data', pd.DataFrame())
                                
                                if not cc_df.empty:
                                    st.session_state.direct_entry_cc_data = cc_df.copy()
                                    st.session_state.direct_entry_data = cc_df.copy()
                                if not detail_df.empty:
                                    st.session_state.direct_entry_detail_data = detail_df.copy()
                                
                                st.session_state.de_show_load_dialog = False
                                st.toast(f" Loaded '{selected_saved_version}'")
                                st.rerun()
                            else:
                                # Load PY Actuals or PY Budget
                                np.random.seed(42 if 'Actuals' in load_source else 43)
                                
                                # Generate CODE COMBINATION data using real ES departments and accounts
                                cc_rows = []
                                # (Legal_Entity, Legal_Entity_Name, Organization, Division, Business_Unit, Department, Account, Account_Name, Category)
                                sample_combos = [
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11300  ZionSolutions', '51110', 'Labor Staff REG', 'Labor & Fringe Costs'),
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11300  ZionSolutions', '52100', 'Fringe Benefits', 'Labor & Fringe Costs'),
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11300  ZionSolutions', '60100', 'Materials', 'Materials & Supplies'),
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11307  ZS Waste Operations', '51110', 'Labor Staff REG', 'Labor & Fringe Costs'),
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11307  ZS Waste Operations', '60100', 'Materials', 'Materials & Supplies'),
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11308  ZS D&D and Engineering', '51110', 'Labor Staff REG', 'Labor & Fringe Costs'),
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11308  ZS D&D and Engineering', '70200', 'Professional Services', 'Professional Services'),
                                    ('210', 'Duratek Services, Inc', 'Waste Management', 'Services', 'LWP', '11100  LWP', '51110', 'Labor Staff REG', 'Labor & Fringe Costs'),
                                    ('210', 'Duratek Services, Inc', 'Waste Management', 'Services', 'LWP', '11100  LWP', '60100', 'Materials', 'Materials & Supplies'),
                                    ('210', 'Duratek Services, Inc', 'Waste Management', 'Services', 'LWP', '11100  LWP', '80100', 'Travel', 'Travel & Relocation'),
                                    ('210', 'Duratek Services, Inc', 'Waste Management', 'Services', 'LWP', '11109  LWP - DWM', '51110', 'Labor Staff REG', 'Labor & Fringe Costs'),
                                    ('210', 'Duratek Services, Inc', 'Corporate', 'DiscOps', 'Other', '11200  Non Utiliy Projects', '51110', 'Labor Staff REG', 'Labor & Fringe Costs'),
                                ]
                                
                                for le, le_name, org, div, bu, dept, acct, acct_name, cat in sample_combos:
                                    py_annual = round(np.random.uniform(100000, 500000), 0)
                                    row = {
                                        'Legal_Entity': le, 
                                        'Legal_Entity_Name': le_name,
                                        'Organization': org,
                                        'Division': div,
                                        'Business_Unit': bu,
                                        'Department': dept, 
                                        'Account': acct, 
                                        'Account_Name': acct_name,
                                        'Category': cat,
                                        'Description': f'{acct_name} - {dept.split("  ")[1] if "  " in dept else dept}',
                                        '_cc_key': f"{dept}|{acct}",
                                    }
                                    for month in MONTHS:
                                        row[f'PY_{month}'] = round(py_annual / 12 * np.random.uniform(0.85, 1.15), 0)
                                        row[month] = 0
                                    row['PY_Annual'] = sum(row[f'PY_{m}'] for m in MONTHS)
                                    row['Budget_Annual'] = 0
                                    row['_selected'] = False
                                    cc_rows.append(row)
                                
                                cc_df = pd.DataFrame(cc_rows)
                                
                                # Generate DETAIL data
                                detail_rows = []
                                # (Legal_Entity, Legal_Entity_Name, Organization, Division, Business_Unit, Department, Account, Account_Name, Project, Task, Vendor, Customer, PO, Category)
                                sample_details = [
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11300  ZionSolutions', '51110', 'Labor Staff REG', 'ZION-D&D-001', 'T001 PM', 'AECOM', 'DOE-EM', 'PO-001', 'Labor & Fringe Costs'),
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11300  ZionSolutions', '51110', 'Labor Staff REG', 'ZION-D&D-001', 'T002 Eng', '', 'DOE-EM', '', 'Labor & Fringe Costs'),
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11300  ZionSolutions', '60100', 'Materials', 'ZION-D&D-001', 'T004 Field', 'Grainger', 'DOE-EM', 'PO-003', 'Materials & Supplies'),
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11307  ZS Waste Operations', '51110', 'Labor Staff REG', 'ZION-WASTE-001', 'T001 PM', '', 'DOE-EM', '', 'Labor & Fringe Costs'),
                                    ('115', 'ZionSolutions, LLC', 'Decommissioning', 'Decommissioning', 'Zion', '11308  ZS D&D and Engineering', '70200', 'Professional Services', 'ZION-D&D-001', 'T002 Eng', 'Jacobs', 'DOE-EM', 'PO-010', 'Professional Services'),
                                    ('210', 'Duratek Services, Inc', 'Waste Management', 'Services', 'LWP', '11100  LWP', '51110', 'Labor Staff REG', 'LWP-OPS-001', 'T001 PM', '', 'Commercial', '', 'Labor & Fringe Costs'),
                                    ('210', 'Duratek Services, Inc', 'Waste Management', 'Services', 'LWP', '11100  LWP', '60100', 'Materials', 'LWP-OPS-001', 'T004 Field', 'HD Supply', 'Commercial', 'PO-020', 'Materials & Supplies'),
                                    ('210', 'Duratek Services, Inc', 'Waste Management', 'Services', 'LWP', '11100  LWP', '80100', 'Travel', 'LWP-OPS-001', 'T003 Procurement', '', 'Commercial', '', 'Travel & Relocation'),
                                    ('210', 'Duratek Services, Inc', 'Waste Management', 'Services', 'LWP', '11109  LWP - DWM', '51110', 'Labor Staff REG', 'DWM-2025-001', 'T001 PM', '', 'DOE-NE', '', 'Labor & Fringe Costs'),
                                ]
                                
                                for le, le_name, org, div, bu, dept, acct, acct_name, proj, task, vendor, cust, po, cat in sample_details:
                                    py_annual = round(np.random.uniform(30000, 150000), 0)
                                    row = {
                                        'Legal_Entity': le, 
                                        'Legal_Entity_Name': le_name,
                                        'Organization': org,
                                        'Division': div,
                                        'Business_Unit': bu,
                                        'Department': dept, 
                                        'Account': acct,
                                        'Account_Name': acct_name,
                                        'Project': proj, 'Task': task, 'Vendor': vendor, 'Customer': cust, 'PO': po,
                                        'Category': cat, 'Description': f'{task} - {proj}',
                                        '_cc_key': f"{dept}|{acct}", '_added_to_cc': False,
                                        'Needs_PR': False,  # New spend flag
                                    }
                                    for month in MONTHS:
                                        row[f'PY_{month}'] = round(py_annual / 12 * np.random.uniform(0.8, 1.2), 0)
                                        row[month] = 0
                                    row['PY_Annual'] = sum(row[f'PY_{m}'] for m in MONTHS)
                                    row['Budget_Annual'] = 0
                                    row['_selected'] = False
                                    detail_rows.append(row)
                                
                                detail_df = pd.DataFrame(detail_rows)
                                
                                # Store both
                                st.session_state.direct_entry_cc_data = cc_df
                                st.session_state.direct_entry_detail_data = detail_df
                                
                                # Set current view
                                current_level = st.session_state.get('de_entry_level', 'Code Combination')
                                if current_level == "Detail Level":
                                    st.session_state.direct_entry_data = detail_df.copy()
                                else:
                                    st.session_state.direct_entry_data = cc_df.copy()
                                
                                st.session_state.de_show_load_dialog = False
                                st.toast(f" Loaded CC: {len(cc_df)} | Detail: {len(detail_df)}")
                                st.rerun()
                    
                    with c2:
                        if st.button("Cancel", use_container_width=True, key="de_load_cancel"):
                            st.session_state.de_show_load_dialog = False
                            st.rerun()
                
                show_load_dialog()
            
            # Save Version Dialog - only open if load dialog is not open
            elif st.session_state.get('de_show_save_dialog', False):
                st.session_state.de_save_dialog_opened = True  # Mark that dialog was opened
                
                @st.dialog(" Save Budget Version", width="large")
                def show_save_dialog():
                    st.markdown("Save current budget data as a version for analysis")
                    
                    # First, sync current working data to appropriate store based on entry level
                    current_data = st.session_state.direct_entry_data
                    entry_level = st.session_state.get('de_entry_level', 'Code Combination')
                    
                    if not current_data.empty:
                        if entry_level == "Detail Level":
                            st.session_state.direct_entry_detail_data = current_data.copy()
                        else:
                            st.session_state.direct_entry_cc_data = current_data.copy()
                    
                    current_year = datetime.now().year
                    
                    # Get data to save
                    cc_data = st.session_state.direct_entry_cc_data
                    detail_data = st.session_state.direct_entry_detail_data
                    cc_count = len(cc_data) if not cc_data.empty else 0
                    detail_count = len(detail_data) if not detail_data.empty else 0
                    
                    # Count lines with Needs_PR checked
                    needs_pr_count = 0
                    if not detail_data.empty and 'Needs_PR' in detail_data.columns:
                        needs_pr_count = int(detail_data['Needs_PR'].sum())
                    
                    if cc_count > 0 and 'Budget_Annual' in cc_data.columns:
                        cc_total = cc_data['Budget_Annual'].sum()
                    elif not current_data.empty and 'Budget_Annual' in current_data.columns:
                        cc_total = current_data['Budget_Annual'].sum()
                    else:
                        cc_total = 0
                    
                    # Show data summary
                    if detail_count > 0:
                        st.caption(f" CC: {cc_count} lines | Detail: {detail_count} lines | **Needs PR: {needs_pr_count}**")
                    
                    # Get corporate versions (unified system, filtered for Budget Planning)
                    unified_versions = st.session_state.get('unified_corporate_versions', {})
                    corporate_versions = {k: v for k, v in unified_versions.items() 
                                         if v.get('page_type') == 'Budget Planning'}
                    saved_versions = st.session_state.get('saved_budget_versions', {})
                    
                    # Check if loaded from corporate version
                    loaded_from_corp = st.session_state.get('de_loaded_from_corp', None)
                    
                    # Check for department context selector
                    dept_context = st.session_state.get('de_dept_context', None)
                    
                    # Department identifier - prefer: 1) dept context, 2) loaded context, 3) detect from data
                    dept_default = ''
                    corp_default_idx = 0
                    
                    if dept_context:
                        # Use department context selector value
                        dept_default = dept_context
                    elif loaded_from_corp:
                        dept_default = loaded_from_corp.get('dept_name', '')
                        # Find the index of the corporate version in the list
                        corp_list = list(corporate_versions.keys())
                        if loaded_from_corp.get('corp_id') in corp_list:
                            corp_default_idx = corp_list.index(loaded_from_corp.get('corp_id'))
                    elif not cc_data.empty and 'Department' in cc_data.columns:
                        depts = cc_data['Department'].unique()
                        if len(depts) == 1:
                            dept_default = str(depts[0]).split()[0] if ' ' in str(depts[0]) else str(depts[0])
                    
                    # Show loaded context banner
                    if dept_context:
                        st.success(f" Saving budget for: **{dept_context}**")
                    elif loaded_from_corp:
                        st.success(f" Editing: **{loaded_from_corp.get('dept_name', '')}** from **{loaded_from_corp.get('corp_id', '')}**")
                    
                    st.markdown("---")
                    
                    # Department identifier
                    dept_col1, dept_col2 = st.columns([1, 2])
                    with dept_col1:
                        dept_name = st.text_input("Department/Unit Name", value=dept_default,
                                                   placeholder="e.g., D&D Operations, Engineering",
                                                   key="de_save_dept_name",
                                                   help="Identifies this budget's source in corporate rollup")
                    with dept_col2:
                        st.info(f"**Budget Summary:** {cc_count} lines | ${cc_total:,.0f}")
                    
                    st.markdown("---")
                    
                    # ===========================================
                    # CORPORATE ROLLUP SECTION
                    # ===========================================
                    st.markdown("####  Corporate Rollup")
                    st.caption("Add or update this budget in a company-wide version")
                    
                    # Show existing corporate versions or create new
                    corp_col1, corp_col2 = st.columns([1, 1])
                    
                    with corp_col1:
                        add_to_corporate = st.checkbox(" Add to Corporate Version", value=bool(corporate_versions), 
                                                        disabled=not corporate_versions, key="de_add_corporate")
                    
                    corporate_version_name = None
                    corp_is_locked = False
                    existing_contrib = None
                    
                    if add_to_corporate and corporate_versions:
                        with corp_col2:
                            # Show status in dropdown - no create new option
                            corp_options_display = []
                            corp_options_map = {}
                            for cid, cinfo in corporate_versions.items():
                                status = cinfo.get('status', 'Working')
                                ver_name = cinfo.get('name', cid)
                                status_icon = {'Working': '', 'Draft': '', 'In Review': '', 'Submitted': '', 'Locked': '', 'Approved': ''}.get(status, '')
                                display = f"{status_icon} {ver_name} ({status})"
                                corp_options_display.append(display)
                                corp_options_map[display] = cid
                            
                            # Use default index if loaded from corporate
                            selected_corp_display = st.selectbox("Select Corporate Version", corp_options_display, 
                                                                  index=corp_default_idx if corp_default_idx < len(corp_options_display) else 0,
                                                                  key="de_corp_select")
                            selected_corp = corp_options_map.get(selected_corp_display, None)
                        
                        if selected_corp:
                            corporate_version_name = selected_corp
                            if corporate_version_name in corporate_versions:
                                corp_info = corporate_versions[corporate_version_name]
                                corp_status = corp_info.get('status', 'Working')
                                corp_display_name = corp_info.get('name', corporate_version_name)
                                corp_is_locked = corp_status in ['Locked', 'Approved']
                                contributors = corp_info.get('contributors', {})
                                total_corp_budget = sum(c.get('total', 0) for c in contributors.values())
                                
                                # Check if this department already exists
                                if dept_name and dept_name in contributors:
                                    existing_contrib = contributors[dept_name]
                                
                                if corp_is_locked:
                                    st.error(f" **{corp_display_name}** is **{corp_status}** - cannot add contributions")
                                else:
                                    st.success(f" **{corp_display_name}** ({corp_status}) | {len(contributors)} contributors | ${total_corp_budget:,.0f} total")
                                
                                # Show existing contribution warning/info
                                if existing_contrib and not corp_is_locked:
                                    existing_total = existing_contrib.get('total', 0)
                                    existing_data = existing_contrib.get('data', pd.DataFrame())
                                    existing_lines = len(existing_data) if isinstance(existing_data, pd.DataFrame) else 0
                                    existing_updated = existing_contrib.get('saved_at', '')
                                    
                                    st.warning(f" **'{dept_name}'** already exists in this version:\n"
                                              f" Current: ${existing_total:,.0f} ({existing_lines} lines)\n"
                                              f" Last updated: {existing_updated}\n\n"
                                              f"**Saving will overwrite** the existing contribution.")
                                
                                # Show contributors
                                if contributors:
                                    with st.expander(f"Current Contributors ({len(contributors)})", expanded=False):
                                        for contrib_name, contrib_info in contributors.items():
                                            is_current = contrib_name == dept_name
                                            prefix = " " if is_current else " "
                                            contrib_data = contrib_info.get('data', pd.DataFrame())
                                            contrib_lines = len(contrib_data) if isinstance(contrib_data, pd.DataFrame) else 0
                                            st.caption(f"{prefix}{contrib_name}: ${contrib_info.get('total', 0):,.0f} ({contrib_lines} lines)")
                    elif not corporate_versions:
                        with corp_col2:
                            st.info("No corporate versions. Create one in Settings  Version Management.")
                    
                    st.markdown("---")
                    
                    # ===========================================
                    # STANDALONE VERSION SECTION
                    # ===========================================
                    st.markdown("####  Standalone Version (Optional)")
                    st.caption("Also save as a separate version for this department only")
                    
                    save_standalone = st.checkbox(" Also save standalone version", value=False, key="de_save_standalone")
                    
                    standalone_name = None
                    if save_standalone:
                        standalone_col1, standalone_col2 = st.columns(2)
                        with standalone_col1:
                            standalone_name = st.text_input("Standalone Version Name", 
                                                            value=f"{dept_name}_{current_year}B" if dept_name else f"{current_year}B",
                                                            key="de_standalone_name")
                        with standalone_col2:
                            standalone_desc = st.text_input("Description", key="de_standalone_desc")
                    
                    st.markdown("---")
                    
                    # ===========================================
                    # SAVE BUTTONS
                    # ===========================================
                    btn_col1, btn_col2 = st.columns(2)
                    
                    with btn_col1:
                        # Can't save to locked corporate version
                        can_save_corp = add_to_corporate and corporate_version_name and dept_name and not corp_is_locked
                        can_save = can_save_corp or (save_standalone and standalone_name)
                        
                        if corp_is_locked and add_to_corporate:
                            st.warning(" Cannot add to locked/approved version")
                        
                        # Show button text based on whether overwriting
                        save_btn_text = " Update" if existing_contrib else " Save"
                        
                        if st.button(save_btn_text, type="primary", use_container_width=True, disabled=not can_save):
                            # Initialize if needed
                            if 'saved_budget_versions' not in st.session_state:
                                st.session_state.saved_budget_versions = {}
                            if 'unified_corporate_versions' not in st.session_state:
                                st.session_state.unified_corporate_versions = {}
                            
                            save_data = {
                                'cc_data': cc_data.copy() if not cc_data.empty else pd.DataFrame(),
                                'detail_data': detail_data.copy() if not detail_data.empty else pd.DataFrame(),
                            }
                            
                            messages = []
                            
                            # Save to corporate version (only if not locked and version exists)
                            if can_save_corp and corporate_version_name in st.session_state.unified_corporate_versions:
                                corp_id = corporate_version_name
                                is_update = dept_name in st.session_state.unified_corporate_versions[corp_id].get('contributors', {})
                                
                                # Add/update this department's contribution (using unified structure)
                                st.session_state.unified_corporate_versions[corp_id]['contributors'][dept_name] = {
                                    'data': cc_data.copy() if not cc_data.empty else pd.DataFrame(),
                                    'total': cc_total,
                                    'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M'),
                                    'saved_by': 'User',
                                    'source': 'direct_entry',
                                    'detail_data': detail_data.copy() if not detail_data.empty else pd.DataFrame(),
                                }
                                
                                # Recalculate corporate totals
                                contributors = st.session_state.unified_corporate_versions[corp_id]['contributors']
                                st.session_state.unified_corporate_versions[corp_id]['total_amount'] = sum(c.get('total', 0) for c in contributors.values())
                                
                                corp_display_name = st.session_state.unified_corporate_versions[corp_id].get('name', corp_id)
                                action = "Updated" if is_update else "Added"
                                messages.append(f"{action} '{dept_name}' in '{corp_display_name}' (${cc_total:,.0f})")
                                
                                # Update loaded context to reflect new state
                                st.session_state.de_loaded_from_corp = {
                                    'corp_id': corp_id,
                                    'corp_name': corp_display_name,
                                    'dept_name': dept_name,
                                }
                            
                            # Save standalone version
                            if save_standalone and standalone_name:
                                version_id = standalone_name.replace(" ", "_").upper()
                                st.session_state.saved_budget_versions[version_id] = {
                                    'name': standalone_name,
                                    'description': standalone_desc if save_standalone else '',
                                    'data': save_data,
                                    'source': 'direct_entry',
                                    'created': datetime.now(),
                                    'fiscal_year': current_year,
                                    'cc_count': cc_count,
                                    'detail_count': detail_count,
                                    'total_budget': cc_total,
                                    'department': dept_name,
                                }
                                messages.append(f"Saved standalone '{standalone_name}'")
                            
                            st.session_state.de_show_save_dialog = False
                            st.toast(" " + " | ".join(messages))
                            st.rerun()
                    
                    with btn_col2:
                        if st.button("Cancel", use_container_width=True):
                            st.session_state.de_show_save_dialog = False
                            st.rerun()
                
                show_save_dialog()
            
            with h1:
                entry_level = st.selectbox(
                    "Entry Level",
                    ["Code Combination", "Detail Level"],
                    key="de_level_select",
                    label_visibility="collapsed",
                    help="Switch between Code Combination and Detail views. Data is preserved in both."
                )
                
                # Always keep de_entry_level in sync
                st.session_state.de_entry_level = entry_level
                
                # Detect if entry level changed
                last_level = st.session_state.de_last_entry_level
                level_changed = entry_level != last_level
                
                if level_changed:
                    # Save current data to appropriate store before switching
                    current_data = st.session_state.direct_entry_data
                    if not current_data.empty:
                        current_is_detail = any(c in current_data.columns for c in ['Project', 'Task', 'Vendor', 'PO'])
                        if current_is_detail:
                            st.session_state.direct_entry_detail_data = current_data.copy()
                        else:
                            st.session_state.direct_entry_cc_data = current_data.copy()
                    
                    # Load from target store
                    if entry_level == "Detail Level":
                        if not st.session_state.direct_entry_detail_data.empty:
                            st.session_state.direct_entry_data = st.session_state.direct_entry_detail_data.copy()
                        else:
                            st.session_state.direct_entry_data = pd.DataFrame()
                    else:  # Code Combination
                        if not st.session_state.direct_entry_cc_data.empty:
                            st.session_state.direct_entry_data = st.session_state.direct_entry_cc_data.copy()
                        else:
                            st.session_state.direct_entry_data = pd.DataFrame()
                    
                    st.session_state.de_last_entry_level = entry_level
                    st.rerun()
                
                # Show data status
                cc_count = len(st.session_state.direct_entry_cc_data) if not st.session_state.direct_entry_cc_data.empty else 0
                detail_count = len(st.session_state.direct_entry_detail_data) if not st.session_state.direct_entry_detail_data.empty else 0
                if cc_count > 0 or detail_count > 0:
                    st.caption(f"CC: {cc_count} | Detail: {detail_count}")
                
                st.session_state.de_entry_level = entry_level
            
            with h2:
                show_annual = st.checkbox("Annual", value=True, key="de_show_annual", help="Show annual total columns")
            
            with h3:
                show_py = st.checkbox("Prior Yr", value=True, key="de_show_py", help="Show prior year columns")
            
            with h4:
                show_variance = st.checkbox("Variance", value=False, key="de_show_var", help="Show variance columns")
            
            with h5:
                if st.button(" Add", type="primary", key="de_add_btn", use_container_width=True):
                    st.session_state.show_de_add_dialog = True
            
            with h6:
                if st.button("", key="de_clear_btn", use_container_width=True):
                    st.session_state.direct_entry_data = pd.DataFrame()
                    st.session_state.direct_entry_cc_data = pd.DataFrame()
                    st.session_state.direct_entry_detail_data = pd.DataFrame()
                    st.rerun()
            
            with h7:
                # Save Version button - only enabled if data exists
                has_data = not st.session_state.direct_entry_cc_data.empty or not st.session_state.direct_entry_data.empty
                if st.button(" Save", key="de_save_btn", use_container_width=True, disabled=not has_data):
                    # Sync current working data to appropriate store BEFORE opening dialog
                    current_data = st.session_state.direct_entry_data
                    if not current_data.empty:
                        # Determine if this is detail or CC data
                        is_detail = any(c in current_data.columns for c in ['Project', 'Task', 'Vendor', 'PO'])
                        if is_detail:
                            st.session_state.direct_entry_detail_data = current_data.copy()
                        else:
                            st.session_state.direct_entry_cc_data = current_data.copy()
                    
                    st.session_state.de_show_save_dialog = True
                    st.session_state.de_save_dialog_opened = False  # Reset so dialog can show
                    st.session_state.de_show_load_dialog = False  # Close load dialog if open
                    st.rerun()
            
            # -----------------------------------------------------------------
            # ADD LINE DIALOG
            # -----------------------------------------------------------------
            @st.dialog(" Add Budget Line", width="large")
            def show_add_line_dialog():
                # Check if org lookup tables are loaded
                has_dept_lookup = 'org_departments' in st.session_state and not st.session_state.org_departments.empty
                has_acct_lookup = 'org_accounts' in st.session_state and not st.session_state.org_accounts.empty
                
                # Dimension options - use org tables if available, else use defaults
                if has_dept_lookup:
                    dept_options = get_department_options()
                    legal_entities = sorted(st.session_state.org_departments['Legal Entity Name'].dropna().unique().tolist()) if 'Legal Entity Name' in st.session_state.org_departments.columns else []
                else:
                    dept_options = ['1000 Executive', '2000 Finance', '3000 Operations', '3100 D&D Operations', '3200 WM Operations', 
                                  '4000 Engineering', '5000 EHS', '6000 HR', '7000 IT', '8000 Project Controls', '9000 Business Dev']
                    legal_entities = ['ES-001 XYZ LLC', 'ES-002 D&D Holdings', 'ES-003 WM Services', 'ES-004 Transportation', 'ES-005 Corporate']
                
                if has_acct_lookup:
                    acct_options = get_account_options()
                    categories = sorted(st.session_state.org_accounts['Account Category'].dropna().unique().tolist()) if 'Account Category' in st.session_state.org_accounts.columns else ['Labor', 'Materials', 'Subcontracts', 'Travel', 'Equipment', 'Other']
                else:
                    acct_options = ['5000 Labor', '5100 Salaries', '5200 Wages', '5300 Overtime', '5400 Fringe Benefits',
                               '6000 Materials', '6100 Supplies', '6200 Equipment', '6300 Chemicals',
                               '7000 Subcontracts', '7100 Professional Services', '7200 Temporary Labor',
                               '8000 Travel', '8100 Lodging', '8200 Transportation', '8300 Per Diem',
                               '9000 Other', '9100 Training', '9200 Licensing', '9300 Insurance']
                    categories = ['Labor', 'Materials', 'Subcontracts', 'Travel', 'Equipment', 'Other']
                
                projects = ['KEW-2025-001 Kewaunee D&D', 'TMI-2025-001 TMI-2 ISFSI', 'CLV-2025-001 Clive Ops', 'BCK-2025-001 Bear Creek']
                tasks = ['T001 Project Management', 'T002 Engineering Support', 'T003 Procurement', 'T004 Field Execution', 'T005 QA/QC']
                work_packages = ['', 'WP-001 Planning', 'WP-002 Design', 'WP-003 Procurement', 'WP-004 Construction', 'WP-005 Testing']
                processes = ['', 'PRC-01 Planning', 'PRC-02 Engineering', 'PRC-03 Procurement', 'PRC-04 Construction', 'PRC-05 Testing', 'PRC-06 Closeout']
                sub_processes = ['', 'SUB-01 Resource Planning', 'SUB-02 Design Review', 'SUB-03 Vendor Mgmt', 'SUB-04 Demo', 'SUB-05 Transport']
                vendors = ['', 'AECOM', 'Jacobs', 'Fluor', 'Bechtel', 'Grainger', 'HD Supply', 'Fastenal', 'Other']
                customers = ['', 'DOE-EM', 'DOE-NE', 'NRC', 'Commercial', 'Utility', 'State Agency']
                
                st.markdown(f"**Entry Level:** {entry_level}")
                
                # Check for department context
                dept_context = st.session_state.get('de_dept_context', None)
                
                # Show lookup status
                if has_dept_lookup or has_acct_lookup:
                    status_parts = []
                    if has_dept_lookup:
                        status_parts.append(f" {len(dept_options)} depts")
                    if has_acct_lookup:
                        status_parts.append(f" {len(acct_options)} accts")
                    st.caption("Using org data: " + " | ".join(status_parts))
                
                # Show department context notice
                if dept_context:
                    st.info(f" Adding to: **{dept_context}**")
                
                # ==========================================
                # DIMENSION SELECTIONS
                # ==========================================
                m_col1, m_col2 = st.columns(2)
                
                with m_col1:
                    # Legal Entity
                    if entry_level == "Code Combination":
                        m_le = st.selectbox("Legal Entity", [''] + legal_entities if legal_entities else legal_entities, key="modal_le")
                    else:
                        m_le = st.selectbox("Legal Entity", [''] + legal_entities, key="modal_dl_le")
                    
                    # Department - pre-select if context is set
                    dept_select_options = [''] + dept_options if dept_options else dept_options
                    dept_default_idx = 0
                    if dept_context and dept_context in dept_select_options:
                        dept_default_idx = dept_select_options.index(dept_context)
                    
                    m_dept = st.selectbox("Department", dept_select_options, 
                                          index=dept_default_idx,
                                          key="modal_dept" if entry_level == "Code Combination" else "modal_dl_dept",
                                          disabled=bool(dept_context))  # Disable if context is set
                    
                    # If context is set but user somehow cleared selection, use context
                    if dept_context and not m_dept:
                        m_dept = dept_context
                    
                    # Account
                    m_acct = st.selectbox("Account", [''] + acct_options if acct_options else acct_options, 
                                          key="modal_acct" if entry_level == "Code Combination" else "modal_dl_acct")
                
                # ==========================================
                # AUTO-MAPPING (after selections are made)
                # ==========================================
                auto_org = ''
                auto_division = ''
                auto_bu = ''
                auto_le_name = ''
                auto_cat = ''
                auto_acct_name = ''
                auto_acct_type = ''
                
                # Auto-map from department selection
                if m_dept and has_dept_lookup:
                    dept_num = m_dept.split()[0] if m_dept else ''
                    dept_info = lookup_department(dept_num)
                    if dept_info:
                        auto_org = dept_info.get('Organization', '')
                        auto_division = dept_info.get('Division', '')
                        auto_bu = dept_info.get('Business_Unit', '')
                        auto_le_name = dept_info.get('Legal_Entity_Name', '')
                
                # Auto-map from account selection
                if m_acct and has_acct_lookup:
                    acct_num = m_acct.split()[0] if m_acct else ''
                    acct_info = lookup_account(acct_num)
                    if acct_info:
                        auto_cat = acct_info.get('Account_Category', '')
                        auto_acct_name = acct_info.get('Account_Name', '')
                        auto_acct_type = acct_info.get('Account_Type', '')
                
                # ==========================================
                # SHOW AUTO-MAPPED INFO & REMAINING FIELDS
                # ==========================================
                with m_col1:
                    # Show auto-mapped department info
                    if auto_org or auto_division or auto_bu:
                        st.caption(f" **Org:** {auto_org} | **Div:** {auto_division} | **BU:** {auto_bu}")
                    
                    # Show auto-mapped account info
                    if auto_cat or auto_acct_type:
                        st.caption(f" **Category:** {auto_cat} | **Type:** {auto_acct_type}")
                    
                    # Category selector with auto-fill
                    default_cat_idx = 0
                    if auto_cat and auto_cat in categories:
                        default_cat_idx = categories.index(auto_cat)
                    m_cat = st.selectbox("Category", categories, index=default_cat_idx, 
                                          key="modal_cat" if entry_level == "Code Combination" else "modal_dl_cat")
                    
                    # Detail Level additional fields in column 1
                    if entry_level == "Detail Level":
                        m_proj = st.selectbox("Project", [''] + projects, key="modal_proj")
                        m_task = st.selectbox("Task", [''] + tasks, key="modal_task")
                        m_wp = st.selectbox("Work Package", work_packages, key="modal_wp")
                
                with m_col2:
                    # Description
                    m_desc = st.text_input("Description", key="modal_desc" if entry_level == "Code Combination" else "modal_dl_desc")
                    
                    # Detail Level additional fields in column 2
                    if entry_level == "Detail Level":
                        m_process = st.selectbox("Process", processes, key="modal_process")
                        m_subprocess = st.selectbox("Sub-Process", sub_processes, key="modal_subprocess")
                        m_vendor = st.selectbox("Vendor", vendors, key="modal_vendor")
                        m_customer = st.selectbox("Customer", customers, key="modal_customer")
                        m_po = st.text_input("PO Number", key="modal_po", placeholder="PO-2025-XXX")
                    
                    m_pattern = st.selectbox("Entry Pattern", ["Annual (Spread)", "Quarterly", "Monthly", " Calculator"], key="modal_pattern")
                    
                    if m_pattern == "Annual (Spread)":
                        m_annual = st.number_input("Budget Amount ($)", min_value=0.0, step=1000.0, key="modal_annual")
                        m_monthly = {m: m_annual / 12 for m in MONTHS}
                    elif m_pattern == " Calculator":
                        # Calculation builder
                        st.markdown("**Build Your Calculation**")
                        st.caption("Create a formula using rates, quantities, and time periods")
                        
                        calc_type = st.radio("Calculation Type", 
                            ["Rate  Quantity  Months", "Hourly Rate  Hours  Headcount", "Unit Cost  Units", "Custom Formula"],
                            key="calc_type", horizontal=True)
                        
                        if calc_type == "Rate  Quantity  Months":
                            cc1, cc2, cc3 = st.columns(3)
                            with cc1:
                                calc_rate = st.number_input("Rate ($)", min_value=0.0, value=0.0, step=100.0, key="calc_rate")
                            with cc2:
                                calc_qty = st.number_input("Quantity", min_value=0.0, value=1.0, step=1.0, key="calc_qty")
                            with cc3:
                                calc_months = st.number_input("Months", min_value=1, max_value=12, value=12, step=1, key="calc_months")
                            calc_result = calc_rate * calc_qty * calc_months
                            calc_formula = f"${calc_rate:,.2f}  {calc_qty:,.0f}  {calc_months} months"
                            
                        elif calc_type == "Hourly Rate  Hours  Headcount":
                            cc1, cc2, cc3, cc4 = st.columns(4)
                            with cc1:
                                calc_hourly = st.number_input("Hourly Rate ($)", min_value=0.0, value=0.0, step=5.0, key="calc_hourly")
                            with cc2:
                                calc_hours = st.number_input("Hours/Week", min_value=0.0, value=40.0, step=1.0, key="calc_hours")
                            with cc3:
                                calc_weeks = st.number_input("Weeks/Year", min_value=1, max_value=52, value=52, step=1, key="calc_weeks")
                            with cc4:
                                calc_hc = st.number_input("Headcount", min_value=1, value=1, step=1, key="calc_hc")
                            calc_result = calc_hourly * calc_hours * calc_weeks * calc_hc
                            calc_formula = f"${calc_hourly:,.2f}/hr  {calc_hours:,.0f} hrs  {calc_weeks} wks  {calc_hc} FTE"
                            
                        elif calc_type == "Unit Cost  Units":
                            cc1, cc2 = st.columns(2)
                            with cc1:
                                calc_unit_cost = st.number_input("Unit Cost ($)", min_value=0.0, value=0.0, step=10.0, key="calc_unit_cost")
                            with cc2:
                                calc_units = st.number_input("Number of Units", min_value=0.0, value=1.0, step=1.0, key="calc_units")
                            calc_result = calc_unit_cost * calc_units
                            calc_formula = f"${calc_unit_cost:,.2f}  {calc_units:,.0f} units"
                            
                        else:  # Custom Formula
                            st.caption("Enter values and operations. Example: Base salary + Benefits + Overhead")
                            cfc1, cfc2, cfc3 = st.columns(3)
                            with cfc1:
                                cf_val1 = st.number_input("Value 1", min_value=0.0, value=0.0, step=100.0, key="cf_val1")
                                cf_label1 = st.text_input("Label 1", value="Base", key="cf_label1")
                            with cfc2:
                                cf_op = st.selectbox("Operation", ["+", "-", "", ""], key="cf_op")
                                cf_val2 = st.number_input("Value 2", min_value=0.0, value=0.0, step=100.0, key="cf_val2")
                                cf_label2 = st.text_input("Label 2", value="Adjustment", key="cf_label2")
                            with cfc3:
                                cf_op2 = st.selectbox("Operation 2", ["+", "-", "", "", "None"], key="cf_op2")
                                if cf_op2 != "None":
                                    cf_val3 = st.number_input("Value 3", min_value=0.0, value=0.0, step=100.0, key="cf_val3")
                                    cf_label3 = st.text_input("Label 3", value="Other", key="cf_label3")
                                else:
                                    cf_val3 = 0
                                    cf_label3 = ""
                            
                            # Calculate based on operations
                            if cf_op == "+":
                                interim = cf_val1 + cf_val2
                            elif cf_op == "-":
                                interim = cf_val1 - cf_val2
                            elif cf_op == "":
                                interim = cf_val1 * cf_val2
                            else:  # 
                                interim = cf_val1 / cf_val2 if cf_val2 != 0 else 0
                            
                            if cf_op2 == "None":
                                calc_result = interim
                            elif cf_op2 == "+":
                                calc_result = interim + cf_val3
                            elif cf_op2 == "-":
                                calc_result = interim - cf_val3
                            elif cf_op2 == "":
                                calc_result = interim * cf_val3
                            else:  # 
                                calc_result = interim / cf_val3 if cf_val3 != 0 else interim
                            
                            calc_formula = f"{cf_label1} (${cf_val1:,.0f}) {cf_op} {cf_label2} (${cf_val2:,.0f})"
                            if cf_op2 != "None":
                                calc_formula += f" {cf_op2} {cf_label3} (${cf_val3:,.0f})"
                        
                        # Show calculation result
                        st.markdown("---")
                        st.markdown(f"**Formula:** {calc_formula}")
                        st.success(f"**Calculated Annual Budget: ${calc_result:,.2f}**")
                        
                        # Spread options
                        spread_method = st.radio("Spread Method", ["Even (12)", "Front-loaded", "Back-loaded", "Seasonal"], 
                                                horizontal=True, key="calc_spread")
                        
                        if spread_method == "Even (12)":
                            m_monthly = {m: calc_result / 12 for m in MONTHS}
                        elif spread_method == "Front-loaded":
                            # More in Q1-Q2, less in Q3-Q4
                            weights = [0.12, 0.11, 0.10, 0.09, 0.09, 0.08, 0.08, 0.08, 0.07, 0.07, 0.06, 0.05]
                            m_monthly = {m: calc_result * w for m, w in zip(MONTHS, weights)}
                        elif spread_method == "Back-loaded":
                            # Less in Q1-Q2, more in Q3-Q4
                            weights = [0.05, 0.06, 0.07, 0.07, 0.08, 0.08, 0.08, 0.09, 0.09, 0.10, 0.11, 0.12]
                            m_monthly = {m: calc_result * w for m, w in zip(MONTHS, weights)}
                        else:  # Seasonal
                            # Higher in summer months
                            weights = [0.06, 0.06, 0.07, 0.08, 0.10, 0.12, 0.12, 0.11, 0.09, 0.08, 0.06, 0.05]
                            m_monthly = {m: calc_result * w for m, w in zip(MONTHS, weights)}
                        
                    elif m_pattern == "Quarterly":
                        qc1, qc2 = st.columns(2)
                        with qc1:
                            mq1 = st.number_input("Q1", min_value=0.0, step=1000.0, key="modal_q1")
                            mq2 = st.number_input("Q2", min_value=0.0, step=1000.0, key="modal_q2")
                        with qc2:
                            mq3 = st.number_input("Q3", min_value=0.0, step=1000.0, key="modal_q3")
                            mq4 = st.number_input("Q4", min_value=0.0, step=1000.0, key="modal_q4")
                        m_monthly = {
                            'Jan': mq1/3, 'Feb': mq1/3, 'Mar': mq1/3,
                            'Apr': mq2/3, 'May': mq2/3, 'Jun': mq2/3,
                            'Jul': mq3/3, 'Aug': mq3/3, 'Sep': mq3/3,
                            'Oct': mq4/3, 'Nov': mq4/3, 'Dec': mq4/3
                        }
                    else:
                        m_monthly = {}
                
                # Monthly detail if selected
                if m_pattern == "Monthly":
                    st.markdown("**Monthly Amounts**")
                    mc = st.columns(6)
                    m_monthly = {}
                    for i, month in enumerate(MONTHS):
                        with mc[i % 6]:
                            m_monthly[month] = st.number_input(month[:3], min_value=0.0, step=100.0, key=f"modal_m_{month}")
                
                # Preview
                st.markdown("---")
                preview_total = sum(m_monthly.values())
                st.caption(f"Budget Total: **${preview_total:,.0f}**")
                
                # Add button
                if st.button(" Add to Budget", type="primary", use_container_width=True):
                    # Use auto-filled category if available, otherwise use selected
                    final_cat = auto_cat if auto_cat else m_cat
                    
                    new_row = {
                        'Description': m_desc, 
                        'Category': final_cat, 
                        'Budget_Annual': preview_total, 
                        'PY_Annual': 0, 
                        '_selected': False,
                        # Auto-mapped organization fields
                        'Organization': auto_org,
                        'Division': auto_division,
                        'Business_Unit': auto_bu,
                        'Legal_Entity_Name': auto_le_name,
                        'Account_Name': auto_acct_name,
                    }
                    
                    if entry_level == "Code Combination":
                        new_row['Legal_Entity'] = m_le
                        new_row['Department'] = m_dept
                        new_row['Account'] = m_acct
                        new_row['_cc_key'] = f"{m_dept}|{m_acct}"
                    else:
                        new_row['Legal_Entity'] = m_le if m_le else ''
                        new_row['Department'] = m_dept
                        new_row['Account'] = m_acct
                        new_row['Project'] = m_proj if m_proj else ''
                        new_row['Task'] = m_task if m_task else ''
                        new_row['Work_Package'] = m_wp if m_wp else ''
                        new_row['Process'] = m_process if m_process else ''
                        new_row['Sub_Process'] = m_subprocess if m_subprocess else ''
                        new_row['Vendor'] = m_vendor if m_vendor else ''
                        new_row['Customer'] = m_customer if m_customer else ''
                        new_row['PO'] = m_po if m_po else ''
                        new_row['_cc_key'] = f"{m_dept}|{m_acct}"
                        new_row['_added_to_cc'] = False  # New detail lines not yet added to CC
                        new_row['Needs_PR'] = False  # Default - user can enable
                    
                    for month, amt in m_monthly.items():
                        new_row[month] = round(amt, 0)
                        new_row[f'PY_{month}'] = 0
                    
                    new_df = pd.DataFrame([new_row])
                    if st.session_state.direct_entry_data.empty:
                        st.session_state.direct_entry_data = new_df
                    else:
                        st.session_state.direct_entry_data = pd.concat([st.session_state.direct_entry_data, new_df], ignore_index=True)
                    
                    # Sync to appropriate data store
                    if entry_level == "Detail Level":
                        if st.session_state.direct_entry_detail_data.empty:
                            st.session_state.direct_entry_detail_data = new_df.copy()
                        else:
                            st.session_state.direct_entry_detail_data = pd.concat([st.session_state.direct_entry_detail_data, new_df], ignore_index=True)
                    else:
                        if st.session_state.direct_entry_cc_data.empty:
                            st.session_state.direct_entry_cc_data = new_df.copy()
                        else:
                            st.session_state.direct_entry_cc_data = pd.concat([st.session_state.direct_entry_cc_data, new_df], ignore_index=True)
                    
                    st.success(f"Added line: ${preview_total:,.0f}")
                    st.rerun()
            
            # Show dialog if triggered
            if 'show_de_add_dialog' in st.session_state and st.session_state.show_de_add_dialog:
                show_add_line_dialog()
                st.session_state.show_de_add_dialog = False
            
            st.markdown("---")
            
            # -----------------------------------------------------------------
            # MAIN DATA TABLE
            # -----------------------------------------------------------------
            if st.session_state.direct_entry_data.empty:
                st.info(" No budget entries yet. Click ** Add** or ** Load** to get started.")
                
                # Quick start cards
                qs1, qs2, qs3 = st.columns(3)
                with qs1:
                    st.markdown("""
                    <div style="padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px;">
                    <h4> Load Prior Year</h4>
                    <p style="font-size: 0.9em;">Import structure from FY2024 actuals with monthly comparison</p>
                    </div>
                    """, unsafe_allow_html=True)
                with qs2:
                    st.markdown("""
                    <div style="padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px;">
                    <h4> Add Lines</h4>
                    <p style="font-size: 0.9em;">Manually add budget lines with vendor/customer tracking</p>
                    </div>
                    """, unsafe_allow_html=True)
                with qs3:
                    st.markdown("""
                    <div style="padding: 15px; border: 1px solid #e0e0e0; border-radius: 8px;">
                    <h4> Toggle Views</h4>
                    <p style="font-size: 0.9em;">Show/hide Annual, Prior Year, and Variance columns</p>
                    </div>
                    """, unsafe_allow_html=True)
            else:
                # -----------------------------------------------------------------
                # DATA TABLE WITH IMMEDIATE EDIT HANDLING
                # -----------------------------------------------------------------
                
                # Get the source data
                source_df = st.session_state.direct_entry_data.copy()
                
                # Ensure _selected column exists for row selection
                if '_selected' not in source_df.columns:
                    source_df['_selected'] = False
                
                # Determine columns - expanded list for detail level
                month_budget_cols = [m for m in MONTHS if m in source_df.columns]
                month_py_cols = [f'PY_{m}' for m in MONTHS if f'PY_{m}' in source_df.columns]
                
                # All possible dimension columns (order matters) - includes org hierarchy
                all_dim_cols = ['Legal_Entity', 'Legal_Entity_Name', 'Organization', 'Division', 'Business_Unit',
                                'Department', 'Account', 'Account_Name', 'Category', 'Project', 'Task', 
                                'Work_Package', 'Process', 'Sub_Process', 'Vendor', 'Customer', 'PO', 'Description']
                dim_cols = [c for c in all_dim_cols if c in source_df.columns]
                
                # Use entry_level selector to determine view type (not column checking)
                is_detail_view = st.session_state.get('de_entry_level', 'Code Combination') == "Detail Level"
                
                # -----------------------------------------------------------------
                # FILTERS
                # -----------------------------------------------------------------
                # Auto-apply department context filter if set
                dept_context = st.session_state.get('de_dept_context', None)
                if dept_context and 'Department' in source_df.columns:
                    source_df = source_df[source_df['Department'] == dept_context].copy()
                    if source_df.empty:
                        st.info(f"No data for department: {dept_context}. Load data or clear the department filter.")
                
                with st.expander(" Filters", expanded=False):
                    # First row: Org hierarchy filters
                    filter_row1 = st.columns(4)
                    filtered_df = source_df.copy()
                    
                    # Organization filter
                    if 'Organization' in source_df.columns:
                        with filter_row1[0]:
                            org_options = ['All'] + sorted([o for o in source_df['Organization'].dropna().unique().tolist() if o])
                            selected_org = st.selectbox("Organization", org_options, key="de_filter_org")
                            if selected_org != 'All':
                                filtered_df = filtered_df[filtered_df['Organization'] == selected_org]
                    
                    # Division filter  
                    if 'Division' in source_df.columns:
                        with filter_row1[1]:
                            div_options = ['All'] + sorted([d for d in source_df['Division'].dropna().unique().tolist() if d])
                            selected_div = st.selectbox("Division", div_options, key="de_filter_div")
                            if selected_div != 'All':
                                filtered_df = filtered_df[filtered_df['Division'] == selected_div]
                    
                    # Business Unit filter
                    if 'Business_Unit' in source_df.columns:
                        with filter_row1[2]:
                            bu_options = ['All'] + sorted([b for b in source_df['Business_Unit'].dropna().unique().tolist() if b])
                            selected_bu = st.selectbox("Business Unit", bu_options, key="de_filter_bu")
                            if selected_bu != 'All':
                                filtered_df = filtered_df[filtered_df['Business_Unit'] == selected_bu]
                    
                    # Department filter in 4th column (disabled if context is set)
                    if 'Department' in source_df.columns:
                        with filter_row1[3]:
                            dept_options = ['All'] + sorted(source_df['Department'].dropna().unique().tolist())
                            selected_dept = st.selectbox("Department", dept_options, key="de_filter_dept")
                            if selected_dept != 'All':
                                filtered_df = filtered_df[filtered_df['Department'] == selected_dept]
                    
                    # Second row: Account/Category filters
                    filter_row2 = st.columns(4)
                    
                    # Account filter
                    if 'Account' in source_df.columns:
                        with filter_row2[0]:
                            acct_options = ['All'] + sorted(source_df['Account'].dropna().unique().tolist())
                            selected_acct = st.selectbox("Account", acct_options, key="de_filter_acct")
                            if selected_acct != 'All':
                                filtered_df = filtered_df[filtered_df['Account'] == selected_acct]
                    
                    # Category filter
                    if 'Category' in source_df.columns:
                        with filter_row2[1]:
                            cat_options = ['All'] + sorted(source_df['Category'].dropna().unique().tolist())
                            selected_cat = st.selectbox("Category", cat_options, key="de_filter_cat")
                            if selected_cat != 'All':
                                filtered_df = filtered_df[filtered_df['Category'] == selected_cat]
                    
                    # Detail-specific filters
                    if is_detail_view:
                        if 'Project' in source_df.columns:
                            with filter_row2[2]:
                                proj_options = ['All'] + sorted(source_df['Project'].dropna().unique().tolist())
                                selected_proj = st.selectbox("Project", proj_options, key="de_filter_proj")
                                if selected_proj != 'All':
                                    filtered_df = filtered_df[filtered_df['Project'] == selected_proj]
                        
                        if 'Task' in source_df.columns:
                            with filter_row2[3]:
                                task_options = ['All'] + sorted([t for t in source_df['Task'].dropna().unique().tolist() if t])
                                selected_task = st.selectbox("Task", task_options, key="de_filter_task")
                                if selected_task != 'All':
                                    filtered_df = filtered_df[filtered_df['Task'] == selected_task]
                        
                        # Third row for remaining detail filters
                        filter_row3 = st.columns(4)
                        if 'Vendor' in source_df.columns:
                            with filter_row3[0]:
                                vendor_options = ['All'] + sorted([v for v in source_df['Vendor'].dropna().unique().tolist() if v])
                                selected_vendor = st.selectbox("Vendor", vendor_options, key="de_filter_vendor")
                                if selected_vendor != 'All':
                                    filtered_df = filtered_df[filtered_df['Vendor'] == selected_vendor]
                        
                        if 'Customer' in source_df.columns:
                            with filter_row3[1]:
                                cust_options = ['All'] + sorted([c for c in source_df['Customer'].dropna().unique().tolist() if c])
                                selected_cust = st.selectbox("Customer", cust_options, key="de_filter_cust")
                                if selected_cust != 'All':
                                    filtered_df = filtered_df[filtered_df['Customer'] == selected_cust]
                        
                        if 'PO' in source_df.columns:
                            with filter_row3[2]:
                                po_options = ['All'] + sorted([p for p in source_df['PO'].dropna().unique().tolist() if p])
                                selected_po = st.selectbox("PO", po_options, key="de_filter_po")
                                if selected_po != 'All':
                                    filtered_df = filtered_df[filtered_df['PO'] == selected_po]
                    
                    # Show filter status
                    if len(filtered_df) != len(source_df):
                        st.caption(f"Showing {len(filtered_df)} of {len(source_df)} rows")
                
                # Use filtered_df for display but keep source_df for full data operations
                working_df = filtered_df.copy()
                
                # Build display columns based on toggles and entry level
                if is_detail_view:
                    # Show ALL dimension columns for detail view
                    display_cols = [c for c in dim_cols if c in working_df.columns]
                else:
                    # Code combination view - show key columns including org hierarchy
                    cc_cols = ['Legal_Entity', 'Legal_Entity_Name', 'Organization', 'Division', 'Business_Unit',
                               'Department', 'Account', 'Account_Name', 'Category', 'Description']
                    display_cols = [c for c in cc_cols if c in working_df.columns]
                
                if show_annual:
                    if show_py:
                        display_cols.append('PY_Annual')
                    display_cols.append('Budget_Annual')
                    if show_variance and show_py:
                        display_cols += ['Var_$', 'Var_%']
                
                # Add monthly columns
                for m in MONTHS:
                    if show_py and f'PY_{m}' in source_df.columns:
                        display_cols.append(f'PY_{m}')
                    if m in source_df.columns:
                        display_cols.append(m)
                    if show_variance and show_py:
                        display_cols.append(f'Var_{m}')
                        display_cols.append(f'Var%_{m}')
                
                # Ensure calculated columns exist in source and working
                for df in [source_df, working_df]:
                    if 'Budget_Annual' not in df.columns:
                        df['Budget_Annual'] = df[[m for m in MONTHS if m in df.columns]].sum(axis=1) if month_budget_cols else 0
                    if 'PY_Annual' not in df.columns:
                        df['PY_Annual'] = df[[f'PY_{m}' for m in MONTHS if f'PY_{m}' in df.columns]].sum(axis=1) if month_py_cols else 0
                    df['Var_$'] = df['Budget_Annual'] - df['PY_Annual']
                    df['Var_%'] = df.apply(lambda row: round((row['Var_$'] / row['PY_Annual'] * 100), 1) if row['PY_Annual'] != 0 else 0, axis=1)
                    
                    # Monthly variances
                    for m in MONTHS:
                        py_col = f'PY_{m}'
                        if py_col in df.columns and m in df.columns:
                            df[f'Var_{m}'] = df[m] - df[py_col]
                            df[f'Var%_{m}'] = df.apply(
                                lambda row, m=m: round((row[f'Var_{m}'] / row[f'PY_{m}'] * 100), 1) if row[f'PY_{m}'] != 0 else 0, axis=1)
                        else:
                            df[f'Var_{m}'] = 0
                            df[f'Var%_{m}'] = 0
                
                # Create display dataframe from working_df (filtered)
                # display_cols should already have dim_cols + annual + monthly columns
                display_df = working_df.copy()  # Start with all columns
                
                # Summary metrics row (from working_df - shows filtered totals)
                total_budget = working_df['Budget_Annual'].sum()
                total_py = working_df['PY_Annual'].sum()
                total_var = total_budget - total_py
                total_var_pct = (total_var / total_py * 100) if total_py != 0 else 0
                line_count = len(working_df)
                
                # View type indicator
                has_preserved_detail = 'direct_entry_detail_data' in st.session_state and not st.session_state.direct_entry_detail_data.empty
                view_type = " Detail Level" if is_detail_view else " Code Combination"
                
                sm0, sm1, sm2, sm3, sm4, sm5 = st.columns([1.2, 1, 1, 1, 0.8, 1])
                with sm0:
                    st.markdown(f"**{view_type}**")
                    if not is_detail_view and has_preserved_detail:
                        detail_count = len(st.session_state.direct_entry_detail_data)
                        st.caption(f" {detail_count} detail lines")
                with sm1:
                    st.metric("Budget Total", f"${total_budget:,.0f}")
                with sm2:
                    st.metric("Prior Year", f"${total_py:,.0f}")
                with sm3:
                    st.metric("Variance $", f"${total_var:+,.0f}", delta=f"{total_var_pct:+.1f}%")
                with sm4:
                    st.metric("Lines", line_count)
                with sm5:
                    # Show allocation status for CC view only
                    if not is_detail_view and has_preserved_detail:
                        detail_df = st.session_state.direct_entry_detail_data
                        # Detail is breakdown of CC - sum all detail budget
                        detail_total = detail_df['Budget_Annual'].sum() if 'Budget_Annual' in detail_df.columns else 0
                        allocated_pct = (detail_total / total_budget * 100) if total_budget > 0 else 0
                        st.metric("Allocated", f"{allocated_pct:.0f}%", delta=f"${detail_total:,.0f}")
                    elif 'Category' in source_df.columns and not source_df.empty:
                        cat_summary = source_df.groupby('Category')['Budget_Annual'].sum()
                        top_cat = cat_summary.idxmax() if not cat_summary.empty else 'N/A'
                        st.metric("Top Category", top_cat)
                    else:
                        st.metric("Monthly Avg", f"${total_budget/12:,.0f}" if total_budget > 0 else "$0")
                
                st.markdown("---")
                
                # -----------------------------------------------------------------
                # ALLOCATION STATUS (when viewing Detail with CC data)
                # Detail is a BREAKDOWN of CC budget (like templates)
                # -----------------------------------------------------------------
                cc_data = st.session_state.direct_entry_cc_data
                detail_data = st.session_state.direct_entry_detail_data
                
                if is_detail_view and not cc_data.empty:
                    # CC = Total budget (source of truth)
                    cc_budget = cc_data['Budget_Annual'].sum() if 'Budget_Annual' in cc_data.columns else 0
                    
                    # Detail = Breakdown of CC (use detail_data from session state for accuracy)
                    detail_total = detail_data['Budget_Annual'].sum() if not detail_data.empty and 'Budget_Annual' in detail_data.columns else 0
                    
                    # Unallocated = CC - Detail
                    unallocated = cc_budget - detail_total
                    
                    # Status indicator
                    if cc_budget == 0:
                        status_icon = ""  # No CC budget yet
                        status_text = "No CC budget entered"
                    elif unallocated > 0:
                        status_icon = ""  # Under-allocated
                        status_text = "Under-allocated"
                    elif unallocated < 0:
                        status_icon = ""  # Over-allocated
                        status_text = "Over-allocated"
                    else:
                        status_icon = ""  # Fully allocated
                        status_text = "Fully allocated"
                    
                    alloc_pct = (detail_total / cc_budget * 100) if cc_budget > 0 else 0
                    
                    alloc_summary = f"{status_icon} CC Budget: ${cc_budget:,.0f} | Detail: ${detail_total:,.0f} ({alloc_pct:.0f}%) | Unallocated: ${unallocated:,.0f}"
                    with st.expander(alloc_summary, expanded=False):
                        st.caption(f"""
                        **{status_text}**
                        - **CC Budget** = Total budget (set at Code Combination level)
                        - **Detail** = Breakdown of CC budget by project/task/vendor
                        - **Unallocated** = CC budget not yet broken down
                        
                        *To add more budget, switch to CC level first.*
                        """)
                        
                        # Show CC breakdown by Dept/Account
                        if 'Department' in cc_data.columns and 'Account' in cc_data.columns:
                            cc_summary = cc_data.copy()
                            if '_cc_key' not in cc_summary.columns:
                                cc_summary['_cc_key'] = cc_summary['Department'].astype(str) + '|' + cc_summary['Account'].astype(str)
                            
                            cc_summary = cc_summary.groupby(['_cc_key', 'Department', 'Account']).agg({
                                'Budget_Annual': 'sum'
                            }).reset_index()
                            
                            # Get detail totals by CC key (simple sum - no _is_allocated flag)
                            if not detail_data.empty and 'Department' in detail_data.columns:
                                detail_sum = detail_data.copy()
                                if '_cc_key' not in detail_sum.columns:
                                    detail_sum['_cc_key'] = detail_sum['Department'].astype(str) + '|' + detail_sum['Account'].astype(str)
                                
                                detail_summary = detail_sum.groupby('_cc_key').agg({
                                    'Budget_Annual': 'sum'
                                }).reset_index()
                                detail_summary.columns = ['_cc_key', 'Detail']
                                
                                merged = cc_summary.merge(detail_summary, on='_cc_key', how='left')
                                merged['Detail'] = merged['Detail'].fillna(0)
                                merged['Unallocated'] = merged['Budget_Annual'] - merged['Detail']
                                
                                if not merged.empty:
                                    merged['Combo'] = merged['Department'].str[:20] + ' | ' + merged['Account'].str[:15]
                                    st.dataframe(
                                        merged[['Combo', 'Budget_Annual', 'Detail', 'Unallocated']].rename(columns={
                                            'Combo': 'Code Combination',
                                            'Budget_Annual': 'CC Budget',
                                            'Detail': 'Detail',
                                            'Unallocated': 'Unalloc'
                                        }),
                                        hide_index=True,
                                        use_container_width=True,
                                        height=150,
                                        column_config={
                                            'CC Budget': st.column_config.NumberColumn(format="$%.0f"),
                                            'Detail': st.column_config.NumberColumn(format="$%.0f"),
                                            'Unalloc': st.column_config.NumberColumn(format="$%.0f")
                                        }
                                    )
                    st.markdown("---")
                
                # Add selection column to source_df for row selection
                if '_selected' not in source_df.columns:
                    source_df['_selected'] = False
                
                # Calculate selected count from current session state (BEFORE editor)
                pre_selected_count = source_df['_selected'].sum() if '_selected' in source_df.columns else 0
                pre_selected_indices = source_df[source_df['_selected'] == True].index.tolist() if pre_selected_count > 0 else []
                
                # -----------------------------------------------------------------
                # ROW TOOLBAR (above table, compact) - only show when rows selected
                # -----------------------------------------------------------------
                if pre_selected_count > 0:
                    row_info = f"Row {pre_selected_indices[0]+1}" if pre_selected_count == 1 else f"{int(pre_selected_count)} rows"
                    
                    # Same 9-column layout for both views
                    tb1, tb2, tb3, tb4, tb5, tb6, tb7, tb8, tb9 = st.columns([1.2, 1.1, 0.9, 0.8, 0.8, 0.9, 0.9, 0.8, 0.9])
                    
                    # Helper to sync data to correct store (detail only - CC updated explicitly)
                    def sync_data_store(df):
                        st.session_state.direct_entry_data = df
                        if is_detail_view:
                            st.session_state.direct_entry_detail_data = df.copy()
                        else:
                            st.session_state.direct_entry_cc_data = df.copy()
                    
                    with tb1:
                        st.markdown(f"** {row_info}**")
                    
                    with tb2:
                        if is_detail_view:
                            # Detail view - Add/Remove from CC buttons
                            # Check selected rows state
                            sel_df = source_df[source_df['_selected'] == True]
                            all_already_added = False
                            any_added = False
                            if '_added_to_cc' in sel_df.columns:
                                all_already_added = sel_df['_added_to_cc'].all()
                                any_added = sel_df['_added_to_cc'].any()
                            
                            # Show  CC if any selected rows haven't been added yet
                            if not all_already_added:
                                if st.button(" CC", key="de_addtocc_tb", help="Add selected amount to CC budget"):
                                    cc_df = st.session_state.direct_entry_cc_data.copy()
                                    detail_df = st.session_state.direct_entry_data.copy()
                                    
                                    # Ensure _added_to_cc column exists
                                    if '_added_to_cc' not in detail_df.columns:
                                        detail_df['_added_to_cc'] = False
                                    
                                    selected_mask = detail_df['_selected'] == True
                                    # Only process rows not already added
                                    not_added_mask = detail_df['_added_to_cc'] != True
                                    rows_to_add = detail_df[selected_mask & not_added_mask]
                                    
                                    if not rows_to_add.empty and not cc_df.empty:
                                        # Ensure _cc_key exists
                                        if '_cc_key' not in cc_df.columns:
                                            cc_df['_cc_key'] = cc_df['Department'].astype(str) + '|' + cc_df['Account'].astype(str)
                                        
                                        # Add selected detail amounts to matching CC rows
                                        for idx, row in rows_to_add.iterrows():
                                            cc_key = row.get('_cc_key', f"{row.get('Department', '')}|{row.get('Account', '')}")
                                            mask = cc_df['_cc_key'] == cc_key
                                            if mask.any():
                                                # Add to CC budget
                                                cc_df.loc[mask, 'Budget_Annual'] = cc_df.loc[mask, 'Budget_Annual'] + row.get('Budget_Annual', 0)
                                                # Also add monthly values
                                                for m in MONTHS:
                                                    if m in cc_df.columns and m in row.index:
                                                        cc_df.loc[mask, m] = cc_df.loc[mask, m] + row[m]
                                            
                                            # Mark this detail line as added to CC
                                            detail_df.at[idx, '_added_to_cc'] = True
                                        
                                        # Recalculate variance
                                        cc_df['Var_$'] = cc_df['Budget_Annual'] - cc_df['PY_Annual']
                                        
                                        # Save CC
                                        st.session_state.direct_entry_cc_data = cc_df
                                        
                                        # Clear selection and save detail
                                        detail_df['_selected'] = False
                                        st.session_state.direct_entry_data = detail_df
                                        st.session_state.direct_entry_detail_data = detail_df.copy()
                                        
                                        st.toast(f"Added {len(rows_to_add)} line(s) to CC budget")
                                        st.rerun()
                            
                            # Show  CC if any selected rows have been added (to undo)
                            elif any_added:
                                if st.button(" CC", key="de_removefromcc_tb", help="Remove selected amount from CC budget"):
                                    cc_df = st.session_state.direct_entry_cc_data.copy()
                                    detail_df = st.session_state.direct_entry_data.copy()
                                    
                                    selected_mask = detail_df['_selected'] == True
                                    # Only process rows that have been added
                                    added_mask = detail_df['_added_to_cc'] == True
                                    rows_to_remove = detail_df[selected_mask & added_mask]
                                    
                                    if not rows_to_remove.empty and not cc_df.empty:
                                        # Ensure _cc_key exists
                                        if '_cc_key' not in cc_df.columns:
                                            cc_df['_cc_key'] = cc_df['Department'].astype(str) + '|' + cc_df['Account'].astype(str)
                                        
                                        # Subtract selected detail amounts from matching CC rows
                                        for idx, row in rows_to_remove.iterrows():
                                            cc_key = row.get('_cc_key', f"{row.get('Department', '')}|{row.get('Account', '')}")
                                            mask = cc_df['_cc_key'] == cc_key
                                            if mask.any():
                                                # Subtract from CC budget
                                                cc_df.loc[mask, 'Budget_Annual'] = cc_df.loc[mask, 'Budget_Annual'] - row.get('Budget_Annual', 0)
                                                # Also subtract monthly values
                                                for m in MONTHS:
                                                    if m in cc_df.columns and m in row.index:
                                                        cc_df.loc[mask, m] = cc_df.loc[mask, m] - row[m]
                                            
                                            # Mark this detail line as NOT added to CC
                                            detail_df.at[idx, '_added_to_cc'] = False
                                        
                                        # Recalculate variance
                                        cc_df['Var_$'] = cc_df['Budget_Annual'] - cc_df['PY_Annual']
                                        
                                        # Save CC
                                        st.session_state.direct_entry_cc_data = cc_df
                                        
                                        # Clear selection and save detail
                                        detail_df['_selected'] = False
                                        st.session_state.direct_entry_data = detail_df
                                        st.session_state.direct_entry_detail_data = detail_df.copy()
                                        
                                        st.toast(f"Removed {len(rows_to_remove)} line(s) from CC budget")
                                        st.rerun()
                        else:
                            # CC view - View Detail button
                            has_detail = not st.session_state.direct_entry_detail_data.empty
                            if st.button(" Detail", key="de_viewdetail_tb", help="View detail breakdown", disabled=(not has_detail or pre_selected_count != 1)):
                                if pre_selected_count == 1:
                                    sel_row = source_df.iloc[pre_selected_indices[0]]
                                    st.session_state.de_show_detail_modal = True
                                    st.session_state.de_detail_dept = sel_row.get('Department', '')
                                    st.session_state.de_detail_acct = sel_row.get('Account', '')
                                    st.session_state.de_detail_budget = sel_row.get('Budget_Annual', 0)
                                    st.session_state.de_detail_py = sel_row.get('PY_Annual', 0)
                                    st.rerun()
                    
                    with tb3:
                        # Duplicate button for both views
                        if st.button(" Dup", key="de_dup_tb3", help="Duplicate row"):
                            dup_df = st.session_state.direct_entry_data.copy()
                            selected_rows = dup_df[dup_df['_selected'] == True].copy()
                            for col in selected_rows.columns:
                                if col.startswith('PY_') or col == 'PY_Annual':
                                    selected_rows[col] = 0
                            selected_rows['_selected'] = False
                            # Reset _added_to_cc for duplicates (they haven't been added to CC yet)
                            if '_added_to_cc' in selected_rows.columns:
                                selected_rows['_added_to_cc'] = False
                            dup_df['_selected'] = False
                            insert_pos = max(pre_selected_indices) + 1 if pre_selected_indices else len(dup_df)
                            dup_df = pd.concat([dup_df.iloc[:insert_pos], selected_rows, dup_df.iloc[insert_pos:]], ignore_index=True)
                            sync_data_store(dup_df)
                            st.rerun()
                    
                    with tb4:
                        if st.button("", key="de_up_tb4", help="Move up"):
                            if pre_selected_indices and min(pre_selected_indices) > 0:
                                move_df = st.session_state.direct_entry_data.copy()
                                for idx in pre_selected_indices:
                                    if idx > 0:
                                        move_df.iloc[idx-1], move_df.iloc[idx] = move_df.iloc[idx].copy(), move_df.iloc[idx-1].copy()
                                sync_data_store(move_df.reset_index(drop=True))
                                st.rerun()
                    
                    with tb5:
                        if st.button("", key="de_down_tb5", help="Move down"):
                            if pre_selected_indices and max(pre_selected_indices) < len(source_df) - 1:
                                move_df = st.session_state.direct_entry_data.copy()
                                for idx in reversed(pre_selected_indices):
                                    if idx < len(move_df) - 1:
                                        move_df.iloc[idx], move_df.iloc[idx+1] = move_df.iloc[idx+1].copy(), move_df.iloc[idx].copy()
                                sync_data_store(move_df.reset_index(drop=True))
                                st.rerun()
                    
                    with tb6:
                        if st.button(" Edit", key="de_edit_tb6", help="Edit fields", disabled=(pre_selected_count != 1)):
                            st.session_state.show_de_edit_dialog = True
                            st.rerun()
                            st.rerun()
                    
                    with tb7:
                        if st.button(" CopyPY", key="de_copypy_tb2", help="Copy PYBudget"):
                            copy_df = st.session_state.direct_entry_data.copy()
                            mask = copy_df['_selected'] == True
                            for m in MONTHS:
                                if f'PY_{m}' in copy_df.columns:
                                    copy_df.loc[mask, m] = copy_df.loc[mask, f'PY_{m}']
                            copy_df.loc[mask, 'Budget_Annual'] = copy_df.loc[mask, [m for m in MONTHS if m in copy_df.columns]].sum(axis=1)
                            copy_df['_selected'] = False
                            sync_data_store(copy_df)
                            st.rerun()
                    
                    with tb8:
                        if st.button(" Del", key="de_del_tb2", help="Delete selected"):
                            del_df = st.session_state.direct_entry_data.copy()
                            del_df = del_df[del_df['_selected'] != True].reset_index(drop=True)
                            sync_data_store(del_df)
                            st.rerun()
                    
                    with tb9:
                        if st.button(" Clear", key="de_clrsel_tb2", help="Clear selection"):
                            clr_df = st.session_state.direct_entry_data.copy()
                            clr_df['_selected'] = False
                            st.session_state.direct_entry_data = clr_df
                            st.rerun()
                
                # -----------------------------------------------------------------
                # VIEW DETAIL MODAL (for CC view)
                # -----------------------------------------------------------------
                if st.session_state.get('de_show_detail_modal', False) and not is_detail_view:
                    @st.dialog(" Detail Breakdown", width="large")
                    def show_detail_modal_inline():
                        dept = st.session_state.get('de_detail_dept', '')
                        acct = st.session_state.get('de_detail_acct', '')
                        cc_budget = st.session_state.get('de_detail_budget', 0)
                        cc_py = st.session_state.get('de_detail_py', 0)
                        
                        st.markdown(f"### {dept} | {acct}")
                        detail_data = st.session_state.get('direct_entry_detail_data', pd.DataFrame())
                        
                        if not detail_data.empty and 'Department' in detail_data.columns:
                            filtered = detail_data[(detail_data['Department'] == dept) & (detail_data['Account'] == acct)].copy()
                            if not filtered.empty:
                                # Ensure variance columns exist
                                if 'Budget_Annual' in filtered.columns and 'PY_Annual' in filtered.columns:
                                    filtered['Var_$'] = filtered['Budget_Annual'] - filtered['PY_Annual']
                                    filtered['Var_%'] = filtered.apply(
                                        lambda row: round((row['Var_$'] / row['PY_Annual'] * 100), 1) if row['PY_Annual'] != 0 else 0, axis=1
                                    )
                                
                                det_budget = filtered['Budget_Annual'].sum() if 'Budget_Annual' in filtered.columns else 0
                                det_py = filtered['PY_Annual'].sum() if 'PY_Annual' in filtered.columns else 0
                                det_var = det_budget - det_py
                                det_var_pct = (det_var / det_py * 100) if det_py != 0 else 0
                                
                                # Unallocated = CC - Detail
                                unallocated = cc_budget - det_budget
                                alloc_pct = (det_budget / cc_budget * 100) if cc_budget > 0 else 0
                                
                                # Summary metrics
                                c1, c2, c3, c4 = st.columns(4)
                                c1.metric("CC Budget", f"${cc_budget:,.0f}")
                                c2.metric("Detail", f"${det_budget:,.0f}", delta=f"{alloc_pct:.0f}%")
                                c3.metric("Unallocated", f"${unallocated:,.0f}")
                                c4.metric("Variance", f"${det_var:,.0f}", delta=f"{det_var_pct:+.1f}%")
                                
                                st.markdown("---")
                                
                                # Build display columns - include ALL detail fields
                                display_cols = []
                                for col in ['Project', 'Task', 'Vendor', 'Customer', 'PO', 'Description']:
                                    if col in filtered.columns:
                                        display_cols.append(col)
                                
                                display_cols.extend(['Budget_Annual', 'PY_Annual', 'Var_$', 'Var_%'])
                                
                                # Only include columns that exist
                                display_cols = [c for c in display_cols if c in filtered.columns]
                                
                                st.dataframe(
                                    filtered[display_cols].rename(columns={
                                        'Budget_Annual': 'Budget',
                                        'PY_Annual': 'PY',
                                        'Var_$': 'Var $',
                                        'Var_%': 'Var %'
                                    }),
                                    hide_index=True,
                                    use_container_width=True,
                                    column_config={
                                        'Budget': st.column_config.NumberColumn(format="$%.0f"),
                                        'PY': st.column_config.NumberColumn(format="$%.0f"),
                                        'Var $': st.column_config.NumberColumn(format="$%.0f"),
                                        'Var %': st.column_config.NumberColumn(format="%.1f%%"),
                                    }
                                )
                                
                                # Summary row
                                st.caption(f"**Totals:** Budget: ${det_budget:,.0f} | PY: ${det_py:,.0f} | Var: ${det_var:,.0f} ({det_var_pct:+.1f}%)")
                            else:
                                st.info("No detail lines for this combination")
                        else:
                            st.info("No detail data loaded")
                    
                    show_detail_modal_inline()
                    st.session_state.de_show_detail_modal = False
                
                # -----------------------------------------------------------------
                # EDIT DIALOG
                # -----------------------------------------------------------------
                if st.session_state.get('show_de_edit_dialog', False):
                    @st.dialog(" Edit Line", width="large")
                    def show_edit_dialog():
                        edit_df = st.session_state.direct_entry_data
                        sel_idx = edit_df[edit_df['_selected'] == True].index.tolist()
                        if not sel_idx:
                            st.warning("No row selected")
                            return
                        row_idx = sel_idx[0]
                        row = edit_df.iloc[row_idx]
                        
                        st.markdown(f"**Editing Row {row_idx + 1}**")
                        
                        def get_val(col):
                            v = row.get(col, '')
                            return str(v) if pd.notna(v) else ''
                        
                        def get_num(col):
                            v = row.get(col, 0)
                            return float(v) if pd.notna(v) else 0
                        
                        # Build options with current value included
                        def build_opts(base_opts, current_val):
                            opts = [''] + base_opts
                            if current_val and current_val not in opts:
                                opts.append(current_val)
                            return opts
                        
                        def get_idx(opts, val):
                            return opts.index(val) if val in opts else 0
                        
                        # Base options
                        le_base = ['ES-001', 'ES-002', 'ES-003', 'ES-004', 'ES-005']
                        dept_base = ['1000 Executive', '2000 Finance', '3000 Operations', '3100 D&D Operations', 
                                    '3200 WM Operations', '4000 Engineering', '5000 EHS']
                        acct_base = ['5000 Labor', '5100 Salaries', '5200 Wages', '6000 Materials', 
                                    '7000 Subcontracts', '7100 Professional Services', '8000 Travel', '9000 Other']
                        cat_base = ['Labor', 'Materials', 'Subcontracts', 'Travel', 'Equipment', 'Other']
                        proj_base = ['KEW-2025-001', 'TMI-2025-001', 'CLV-2025-001', 'SRS-2025-001']
                        task_base = ['T001 PM', 'T002 Eng', 'T003 Proc', 'T004 Field', 'T005 QA/QC']
                        vendor_base = ['AECOM', 'Jacobs', 'Fluor', 'Bechtel', 'Grainger', 'HD Supply']
                        cust_base = ['DOE-EM', 'DOE-NE', 'NRC', 'Commercial', 'Utility']
                        
                        # Show fields based on current view level
                        st.caption("**Dimensions**")
                        
                        if is_detail_view:
                            # Detail view - show all fields in 3 columns
                            c1, c2, c3 = st.columns(3)
                            with c1:
                                le_opts = build_opts(le_base, get_val('Legal_Entity'))
                                new_le = st.selectbox("Legal Entity", le_opts, index=get_idx(le_opts, get_val('Legal_Entity')), key="ed_le")
                                
                                dept_opts = build_opts(dept_base, get_val('Department'))
                                new_dept = st.selectbox("Department", dept_opts, index=get_idx(dept_opts, get_val('Department')), key="ed_dept")
                                
                                acct_opts = build_opts(acct_base, get_val('Account'))
                                new_acct = st.selectbox("Account", acct_opts, index=get_idx(acct_opts, get_val('Account')), key="ed_acct")
                                
                                cat_opts = build_opts(cat_base, get_val('Category'))
                                new_cat = st.selectbox("Category", cat_opts, index=get_idx(cat_opts, get_val('Category')), key="ed_cat")
                            
                            with c2:
                                proj_opts = build_opts(proj_base, get_val('Project'))
                                new_proj = st.selectbox("Project", proj_opts, index=get_idx(proj_opts, get_val('Project')), key="ed_proj")
                                
                                task_opts = build_opts(task_base, get_val('Task'))
                                new_task = st.selectbox("Task", task_opts, index=get_idx(task_opts, get_val('Task')), key="ed_task")
                                
                                vendor_opts = build_opts(vendor_base, get_val('Vendor'))
                                new_vendor = st.selectbox("Vendor", vendor_opts, index=get_idx(vendor_opts, get_val('Vendor')), key="ed_vendor")
                                
                                cust_opts = build_opts(cust_base, get_val('Customer'))
                                new_cust = st.selectbox("Customer", cust_opts, index=get_idx(cust_opts, get_val('Customer')), key="ed_cust")
                            
                            with c3:
                                new_po = st.text_input("PO Number", value=get_val('PO'), key="ed_po")
                                new_desc = st.text_input("Description", value=get_val('Description'), key="ed_desc")
                        else:
                            # CC view - show only core fields
                            c1, c2 = st.columns(2)
                            with c1:
                                le_opts = build_opts(le_base, get_val('Legal_Entity'))
                                new_le = st.selectbox("Legal Entity", le_opts, index=get_idx(le_opts, get_val('Legal_Entity')), key="ed_le_cc")
                                
                                dept_opts = build_opts(dept_base, get_val('Department'))
                                new_dept = st.selectbox("Department", dept_opts, index=get_idx(dept_opts, get_val('Department')), key="ed_dept_cc")
                            
                            with c2:
                                acct_opts = build_opts(acct_base, get_val('Account'))
                                new_acct = st.selectbox("Account", acct_opts, index=get_idx(acct_opts, get_val('Account')), key="ed_acct_cc")
                                
                                cat_opts = build_opts(cat_base, get_val('Category'))
                                new_cat = st.selectbox("Category", cat_opts, index=get_idx(cat_opts, get_val('Category')), key="ed_cat_cc")
                            
                            new_desc = st.text_input("Description", value=get_val('Description'), key="ed_desc_cc")
                            # Set detail fields to existing values or empty
                            new_proj = get_val('Project')
                            new_task = get_val('Task')
                            new_vendor = get_val('Vendor')
                            new_cust = get_val('Customer')
                            new_po = get_val('PO')
                        
                        st.markdown("---")
                        st.caption("**Budget Amounts**")
                        
                        # Budget entry method toggle
                        entry_method = st.radio(
                            "Entry Method",
                            ["12-Month Spread", "Monthly Detail"],
                            horizontal=True,
                            key="ed_entry_method"
                        )
                        
                        current_annual = get_num('Budget_Annual')
                        monthly_values = {}
                        
                        if entry_method == "12-Month Spread":
                            # Single annual amount spread evenly
                            spread_total = st.number_input(
                                "Annual Budget",
                                value=float(current_annual),
                                min_value=0.0,
                                step=1000.0,
                                key="ed_spread_total"
                            )
                            monthly_amt = spread_total / 12
                            st.caption(f"Monthly: ${monthly_amt:,.0f}  12 = ${spread_total:,.0f}")
                            for m in MONTHS:
                                monthly_values[m] = monthly_amt
                        else:
                            # Individual month entry
                            mcols = st.columns(6)
                            for i, m in enumerate(MONTHS):
                                with mcols[i % 6]:
                                    monthly_values[m] = st.number_input(
                                        m[:3],
                                        value=float(get_num(m)),
                                        min_value=0.0,
                                        step=100.0,
                                        key=f"ed_m_{m}"
                                    )
                            total = sum(monthly_values.values())
                            st.caption(f"Total: ${total:,.0f}")
                        
                        st.markdown("---")
                        
                        if st.button(" Save Changes", type="primary", use_container_width=True):
                            upd = st.session_state.direct_entry_data.copy()
                            
                            # Update dimension fields
                            if 'Legal_Entity' in upd.columns: upd.at[row_idx, 'Legal_Entity'] = new_le
                            if 'Department' in upd.columns: upd.at[row_idx, 'Department'] = new_dept
                            if 'Account' in upd.columns: upd.at[row_idx, 'Account'] = new_acct
                            if 'Category' in upd.columns: upd.at[row_idx, 'Category'] = new_cat
                            if 'Description' in upd.columns: upd.at[row_idx, 'Description'] = new_desc
                            
                            if is_detail_view:
                                if 'Project' in upd.columns: upd.at[row_idx, 'Project'] = new_proj
                                if 'Task' in upd.columns: upd.at[row_idx, 'Task'] = new_task
                                if 'Vendor' in upd.columns: upd.at[row_idx, 'Vendor'] = new_vendor
                                if 'Customer' in upd.columns: upd.at[row_idx, 'Customer'] = new_cust
                                if 'PO' in upd.columns: upd.at[row_idx, 'PO'] = new_po
                                # Update cc_key
                                if '_cc_key' in upd.columns:
                                    upd.at[row_idx, '_cc_key'] = f"{new_dept}|{new_acct}"
                            
                            # Update monthly values
                            for m, val in monthly_values.items():
                                if m in upd.columns:
                                    upd.at[row_idx, m] = round(val, 0)
                            
                            # Recalculate annual
                            budget_cols = [m for m in MONTHS if m in upd.columns]
                            if budget_cols:
                                upd.at[row_idx, 'Budget_Annual'] = sum(upd.at[row_idx, m] for m in budget_cols)
                            
                            # Calculate variance
                            py_annual = upd.at[row_idx, 'PY_Annual'] if 'PY_Annual' in upd.columns else 0
                            upd.at[row_idx, 'Var_$'] = upd.at[row_idx, 'Budget_Annual'] - py_annual
                            upd.at[row_idx, 'Var_%'] = round((upd.at[row_idx, 'Var_$'] / py_annual * 100), 1) if py_annual != 0 else 0
                            
                            upd.at[row_idx, '_selected'] = False
                            st.session_state.direct_entry_data = upd
                            
                            # Sync to appropriate data store
                            if is_detail_view:
                                st.session_state.direct_entry_detail_data = upd.copy()
                            else:
                                st.session_state.direct_entry_cc_data = upd.copy()
                            
                            st.session_state.show_de_edit_dialog = False
                            st.rerun()
                    
                    show_edit_dialog()
                    st.session_state.show_de_edit_dialog = False
                
                # Column config
                col_config = {
                    '_selected': st.column_config.CheckboxColumn('', default=False, width="small"),
                    'PY_Annual': st.column_config.NumberColumn('PY Total', format="$%.0f"),
                    'Budget_Annual': st.column_config.NumberColumn('Budget', format="$%.0f"),
                    'Var_$': st.column_config.NumberColumn('Var $', format="%.0f"),
                    'Var_%': st.column_config.NumberColumn('Var %', format="%.1f"),
                    '_added_to_cc': st.column_config.CheckboxColumn('CC', default=False, width="small", disabled=True, help="Added to CC budget"),
                    'Needs_PR': st.column_config.CheckboxColumn('Needs PR', default=False, width="small", help="Check if this line needs a Purchase Request (new spend)"),
                }
                
                # Dimension column configs for better display
                col_config['Legal_Entity'] = st.column_config.TextColumn('Legal Entity', width="medium")
                col_config['Department'] = st.column_config.TextColumn('Dept', width="medium")
                col_config['Account'] = st.column_config.TextColumn('Account', width="medium")
                col_config['Category'] = st.column_config.TextColumn('Category', width="small")
                col_config['Project'] = st.column_config.TextColumn('Project', width="small")
                col_config['Task'] = st.column_config.TextColumn('Task', width="small")
                col_config['Work_Package'] = st.column_config.TextColumn('WP', width="small")
                col_config['Process'] = st.column_config.TextColumn('Process', width="small")
                col_config['Sub_Process'] = st.column_config.TextColumn('Sub-Proc', width="small")
                col_config['Vendor'] = st.column_config.TextColumn('Vendor', width="small")
                col_config['Customer'] = st.column_config.TextColumn('Customer', width="small")
                col_config['PO'] = st.column_config.TextColumn('PO', width="small")
                col_config['Description'] = st.column_config.TextColumn('Desc', width="medium")
                
                # Monthly column configs
                for m in MONTHS:
                    col_config[f'PY_{m}'] = st.column_config.NumberColumn(f'PY-{m[:3]}', format="$%.0f", width="small")
                    col_config[m] = st.column_config.NumberColumn(f'{m[:3]}', format="$%.0f", width="small")
                    col_config[f'Var_{m}'] = st.column_config.NumberColumn(f'V$-{m[:3]}', format="%.0f", width="small")
                    col_config[f'Var%_{m}'] = st.column_config.NumberColumn(f'V%-{m[:3]}', format="%.1f", width="small")
                
                # Disabled columns (everything except budget months and selection)
                disabled_cols = ['PY_Annual', 'Budget_Annual', 'Var_$', 'Var_%', '_added_to_cc']
                disabled_cols += [f'PY_{m}' for m in MONTHS]
                disabled_cols += [f'Var_{m}' for m in MONTHS]
                disabled_cols += [f'Var%_{m}' for m in MONTHS]
                
                # Check if filters are active
                filters_active = len(working_df) != len(source_df)
                
                # Add _selected to display columns at the start
                # For detail view, also add _added_to_cc indicator and Needs_PR checkbox
                if is_detail_view and '_added_to_cc' in source_df.columns:
                    # Initialize Needs_PR if not present
                    if 'Needs_PR' not in source_df.columns:
                        source_df['Needs_PR'] = False
                    if 'Needs_PR' not in working_df.columns:
                        working_df['Needs_PR'] = source_df['Needs_PR'].values[:len(working_df)] if len(source_df) >= len(working_df) else False
                    if 'Needs_PR' not in display_df.columns:
                        display_df['Needs_PR'] = working_df['Needs_PR'].values if len(working_df) == len(display_df) else False
                    
                    display_cols_with_select = ['_selected', 'Needs_PR', '_added_to_cc'] + display_cols
                    # Ensure _added_to_cc exists in working_df
                    if '_added_to_cc' not in working_df.columns:
                        working_df['_added_to_cc'] = False
                    if '_added_to_cc' not in display_df.columns:
                        display_df['_added_to_cc'] = working_df['_added_to_cc'].values if len(working_df) == len(display_df) else False
                elif is_detail_view:
                    # Detail view but no _added_to_cc yet (first load)
                    # Initialize _added_to_cc and Needs_PR
                    if '_added_to_cc' not in source_df.columns:
                        source_df['_added_to_cc'] = False
                        working_df['_added_to_cc'] = False
                        display_df['_added_to_cc'] = False
                    if 'Needs_PR' not in source_df.columns:
                        source_df['Needs_PR'] = False
                        working_df['Needs_PR'] = False
                        display_df['Needs_PR'] = False
                    display_cols_with_select = ['_selected', 'Needs_PR', '_added_to_cc'] + display_cols
                else:
                    display_cols_with_select = ['_selected'] + display_cols
                
                # Ensure _selected column exists
                if '_selected' not in working_df.columns:
                    working_df['_selected'] = False
                if '_selected' not in source_df.columns:
                    source_df['_selected'] = False
                
                display_df['_selected'] = working_df['_selected'].values if len(working_df) == len(display_df) else False
                
                # When filters are active, disable row adding to avoid confusion
                if filters_active:
                    st.warning(f" Filters active - showing {len(working_df)} of {len(source_df)} rows. Clear filters to add rows.")
                
                # Data editor with key for state management
                edited_df = st.data_editor(
                    display_df[display_cols_with_select] if '_selected' in display_df.columns else display_df,
                    use_container_width=True,
                    num_rows="fixed" if filters_active else "dynamic",  # Disable row adding when filtered
                    column_config=col_config,
                    disabled=disabled_cols,
                    hide_index=True,
                    height=450,
                    key="de_budget_editor"
                )
                
                # Check for changes and update immediately
                has_changes = False
                selection_changed = False
                updated_df = source_df.copy()
                
                # Editable dimension columns (text fields that user can edit) - includes org hierarchy
                editable_dim_cols = ['Legal_Entity', 'Legal_Entity_Name', 'Organization', 'Division', 'Business_Unit',
                                    'Department', 'Account', 'Account_Name', 'Category', 'Project', 'Task',
                                    'Work_Package', 'Process', 'Sub_Process', 'Vendor', 'Customer', 'PO', 'Description']
                
                # FIRST check: Row count changed (user added/deleted a row)
                row_count_changed = len(edited_df) != len(working_df)
                
                if row_count_changed and not filters_active:
                    # User added or deleted a row - rebuild completely from edited_df
                    has_changes = True
                    updated_df = edited_df.copy()
                    
                    # Ensure all required columns exist
                    for m in MONTHS:
                        if m not in updated_df.columns:
                            updated_df[m] = 0.0
                        if f'PY_{m}' not in updated_df.columns:
                            updated_df[f'PY_{m}'] = 0.0
                    if 'PY_Annual' not in updated_df.columns:
                        updated_df['PY_Annual'] = 0.0
                    if 'Budget_Annual' not in updated_df.columns:
                        updated_df['Budget_Annual'] = 0.0
                    if '_selected' not in updated_df.columns:
                        updated_df['_selected'] = False
                    # Preserve _is_allocated column with default False for new rows
                    if '_is_allocated' not in updated_df.columns:
                        updated_df['_is_allocated'] = False
                        
                elif filters_active:
                    # Filters are active - map edits back to source using index
                    filtered_indices = working_df.index.tolist()
                    
                    for i, (edit_idx, edit_row) in enumerate(edited_df.iterrows()):
                        if i < len(filtered_indices):
                            source_idx = filtered_indices[i]
                            
                            # Check dimension columns
                            for dim_col in editable_dim_cols:
                                if dim_col in edited_df.columns and dim_col in working_df.columns:
                                    old_val = str(working_df.iloc[i][dim_col]) if pd.notna(working_df.iloc[i][dim_col]) else ''
                                    new_val = str(edit_row[dim_col]) if pd.notna(edit_row[dim_col]) else ''
                                    if old_val != new_val:
                                        has_changes = True
                                        updated_df.at[source_idx, dim_col] = edit_row[dim_col]
                            
                            # Check budget values
                            for m in MONTHS:
                                if m in edited_df.columns and m in working_df.columns:
                                    old_val = working_df.iloc[i][m]
                                    new_val = edit_row[m]
                                    if old_val != new_val:
                                        has_changes = True
                                        updated_df.at[source_idx, m] = new_val
                            
                            # Check selection
                            if '_selected' in edited_df.columns and '_selected' in working_df.columns:
                                old_sel = working_df.iloc[i]['_selected']
                                new_sel = edit_row['_selected']
                                if old_sel != new_sel:
                                    selection_changed = True
                                    updated_df.at[source_idx, '_selected'] = new_sel
                            
                            # Check Needs_PR checkbox
                            if 'Needs_PR' in edited_df.columns and 'Needs_PR' in working_df.columns:
                                old_pr = working_df.iloc[i]['Needs_PR']
                                new_pr = edit_row['Needs_PR']
                                if old_pr != new_pr:
                                    has_changes = True
                                    updated_df.at[source_idx, 'Needs_PR'] = new_pr
                else:
                    # No filters and same row count - check for value/selection changes
                    # Check selections
                    if '_selected' in edited_df.columns and '_selected' in working_df.columns:
                        for i in range(len(edited_df)):
                            if edited_df.iloc[i]['_selected'] != working_df.iloc[i]['_selected']:
                                selection_changed = True
                                updated_df.iloc[i, updated_df.columns.get_loc('_selected')] = edited_df.iloc[i]['_selected']
                    
                    # Check Needs_PR checkbox
                    if 'Needs_PR' in edited_df.columns and 'Needs_PR' in working_df.columns:
                        for i in range(len(edited_df)):
                            if edited_df.iloc[i]['Needs_PR'] != working_df.iloc[i]['Needs_PR']:
                                has_changes = True
                                updated_df.iloc[i, updated_df.columns.get_loc('Needs_PR')] = edited_df.iloc[i]['Needs_PR']
                    
                    # Check dimension columns
                    for dim_col in editable_dim_cols:
                        if dim_col in edited_df.columns and dim_col in working_df.columns:
                            for i in range(len(edited_df)):
                                old_val = str(working_df.iloc[i][dim_col]) if pd.notna(working_df.iloc[i][dim_col]) else ''
                                new_val = str(edited_df.iloc[i][dim_col]) if pd.notna(edited_df.iloc[i][dim_col]) else ''
                                if old_val != new_val:
                                    has_changes = True
                                    updated_df.iloc[i, updated_df.columns.get_loc(dim_col)] = edited_df.iloc[i][dim_col]
                    
                    # Check budget values
                    for m in MONTHS:
                        if m in edited_df.columns and m in working_df.columns:
                            for i in range(len(edited_df)):
                                if edited_df.iloc[i][m] != working_df.iloc[i][m]:
                                    has_changes = True
                                    updated_df.iloc[i, updated_df.columns.get_loc(m)] = edited_df.iloc[i][m]
                
                # If value changes detected, recalculate and save immediately
                if has_changes:
                    # Recalculate totals
                    budget_cols = [m for m in MONTHS if m in updated_df.columns]
                    py_cols = [f'PY_{m}' for m in MONTHS if f'PY_{m}' in updated_df.columns]
                    
                    if budget_cols:
                        updated_df['Budget_Annual'] = updated_df[budget_cols].sum(axis=1)
                    if py_cols:
                        updated_df['PY_Annual'] = updated_df[py_cols].sum(axis=1)
                    
                    updated_df['Var_$'] = updated_df['Budget_Annual'] - updated_df['PY_Annual']
                    updated_df['Var_%'] = updated_df.apply(
                        lambda row: round((row['Var_$'] / row['PY_Annual'] * 100), 1) if row['PY_Annual'] != 0 else 0, axis=1)
                    
                    # Monthly variances
                    for m in MONTHS:
                        py_col = f'PY_{m}'
                        if py_col in updated_df.columns and m in updated_df.columns:
                            updated_df[f'Var_{m}'] = updated_df[m] - updated_df[py_col]
                            updated_df[f'Var%_{m}'] = updated_df.apply(
                                lambda row, m=m: round((row[f'Var_{m}'] / row[f'PY_{m}'] * 100), 1) if row[f'PY_{m}'] != 0 else 0, axis=1)
                    
                    # Save immediately
                    st.session_state.direct_entry_data = updated_df
                    
                    # Sync to appropriate data store based on current view type
                    if is_detail_view:
                        st.session_state.direct_entry_detail_data = updated_df.copy()
                    else:
                        st.session_state.direct_entry_cc_data = updated_df.copy()
                    
                    # Rerun to show updated values
                    st.rerun()
                    
                elif selection_changed:
                    # Save selection state and rerun to update toolbar
                    st.session_state.direct_entry_data = updated_df
                    st.rerun()
                
                # Count selected rows for display
                selected_count = updated_df['_selected'].sum() if '_selected' in updated_df.columns else 0
                
                # Note: Detail drill-down is now in the toolbar above ( Detail button)
                
                # -----------------------------------------------------------------
                # ROLLUP SUMMARY
                # -----------------------------------------------------------------
                df = source_df  # Use source_df for rollup display
                with st.expander(" Budget Rollup Summary", expanded=False):
                    roll_col1, roll_col2 = st.columns(2)
                    
                    with roll_col1:
                        st.markdown("**By Category**")
                        if 'Category' in df.columns:
                            cat_rollup = df.groupby('Category').agg({
                                'PY_Annual': 'sum',
                                'Budget_Annual': 'sum',
                                'Var_$': 'sum'
                            }).reset_index()
                            cat_rollup['Var_%'] = cat_rollup.apply(
                                lambda row: (row['Var_$'] / row['PY_Annual'] * 100) if row['PY_Annual'] != 0 else 0, axis=1)
                            cat_rollup = cat_rollup.sort_values('Budget_Annual', ascending=False)
                            
                            # Format for display
                            cat_display = cat_rollup.copy()
                            cat_display['PY_Annual'] = cat_display['PY_Annual'].apply(lambda x: f"${x:,.0f}")
                            cat_display['Budget_Annual'] = cat_display['Budget_Annual'].apply(lambda x: f"${x:,.0f}")
                            cat_display['Var_$'] = cat_display['Var_$'].apply(lambda x: f"${x:+,.0f}")
                            cat_display['Var_%'] = cat_display['Var_%'].apply(lambda x: f"{x:+.1f}%")
                            st.dataframe(cat_display, hide_index=True, use_container_width=True)
                        else:
                            st.caption("Add Category column to see rollup")
                    
                    with roll_col2:
                        st.markdown("**By Department**")
                        if 'Department' in df.columns:
                            dept_rollup = df.groupby('Department').agg({
                                'PY_Annual': 'sum',
                                'Budget_Annual': 'sum',
                                'Var_$': 'sum'
                            }).reset_index()
                            dept_rollup['Var_%'] = dept_rollup.apply(
                                lambda row: (row['Var_$'] / row['PY_Annual'] * 100) if row['PY_Annual'] != 0 else 0, axis=1)
                            dept_rollup = dept_rollup.sort_values('Budget_Annual', ascending=False)
                            
                            dept_display = dept_rollup.copy()
                            dept_display['PY_Annual'] = dept_display['PY_Annual'].apply(lambda x: f"${x:,.0f}")
                            dept_display['Budget_Annual'] = dept_display['Budget_Annual'].apply(lambda x: f"${x:,.0f}")
                            dept_display['Var_$'] = dept_display['Var_$'].apply(lambda x: f"${x:+,.0f}")
                            dept_display['Var_%'] = dept_display['Var_%'].apply(lambda x: f"{x:+.1f}%")
                            st.dataframe(dept_display, hide_index=True, use_container_width=True)
                        else:
                            st.caption("Add Department column to see rollup")
                    
                    # Monthly trend chart
                    st.markdown("**Monthly Trend: Prior Year vs Budget**")
                    chart_df = st.session_state.direct_entry_data
                    chart_budget_cols = [m for m in MONTHS if m in chart_df.columns]
                    chart_py_cols = [f'PY_{m}' for m in MONTHS if f'PY_{m}' in chart_df.columns]
                    if chart_budget_cols and chart_py_cols:
                        monthly_py = [chart_df[f'PY_{m}'].sum() for m in MONTHS if f'PY_{m}' in chart_df.columns]
                        monthly_budget = [chart_df[m].sum() for m in MONTHS if m in chart_df.columns]
                        
                        fig = go.Figure()
                        fig.add_trace(go.Bar(name='Prior Year', x=MONTHS, y=[v/1e6 for v in monthly_py], marker_color='#94a3b8'))
                        fig.add_trace(go.Bar(name='Budget', x=MONTHS, y=[v/1e6 for v in monthly_budget], marker_color='#3b82f6'))
                        fig.update_layout(barmode='group', height=250, yaxis_title='$M', 
                                         legend=dict(orientation='h', yanchor='bottom', y=1.02))
                        st.plotly_chart(fig, use_container_width=True)
                
                # -----------------------------------------------------------------
                # ACTION BUTTONS
                # -----------------------------------------------------------------
                st.markdown("---")
                
                # Show selection info
                if selected_count > 0:
                    st.info(f" {int(selected_count)} row(s) selected")
                
                # Row 1: Primary actions
                act1, act2, act3, act4, act5, act6 = st.columns(6)
                
                with act1:
                    if st.button(" To Analysis", type="primary", key="de_to_analysis", use_container_width=True, help="Load into Budget Analysis"):
                        # Convert to enhanced format
                        budget_rows = []
                        save_df = st.session_state.direct_entry_data
                        
                        for _, row in save_df.iterrows():
                            for month in MONTHS:
                                if month in row and row[month] > 0:
                                    budget_row = {
                                        'Business_Unit': row.get('Legal_Entity', row.get('Department', '')).split()[0] if row.get('Legal_Entity') or row.get('Department') else 'BU01',
                                        'Business_Unit_Name': row.get('Legal_Entity', row.get('Department', 'Default')),
                                        'Cost_Center': row.get('Department', '').split()[0] if row.get('Department') else 'CC01',
                                        'Cost_Center_Name': row.get('Department', 'Default'),
                                        'Account_Category': row.get('Category', row.get('Account', '').split()[1] if ' ' in str(row.get('Account', '')) else 'Other'),
                                        'GL_Account': row.get('Account', '').split()[0] if row.get('Account') else 'GL01',
                                        'GL_Account_Name': row.get('Description', row.get('Account', '')),
                                        'Month': month,
                                        'Month_Num': MONTHS.index(month) + 1,
                                        'Year': str(datetime.now().year),
                                        'Amount': row[month],
                                        'Project': row.get('Project', ''),
                                        'Task': row.get('Task', ''),
                                        'Work_Package': row.get('Work_Package', ''),
                                        'Process': row.get('Process', ''),
                                        'Sub_Process': row.get('Sub_Process', ''),
                                        'Vendor': row.get('Vendor', ''),
                                        'Customer': row.get('Customer', ''),
                                        'PO': row.get('PO', '')
                                    }
                                    budget_rows.append(budget_row)
                        
                        if budget_rows:
                            st.session_state.budget_data_enhanced = pd.DataFrame(budget_rows)
                            st.toast(f" Loaded {len(budget_rows)} records to Budget Analysis")
                        else:
                            st.warning("No budget data to load (all values are zero)")
                
                with act2:
                    output = io.BytesIO()
                    export_df = st.session_state.direct_entry_data.drop(columns=['_selected'], errors='ignore')
                    export_df.to_excel(output, index=False)
                    output.seek(0)
                    st.download_button(
                        " Excel",
                        data=output,
                        file_name=f"budget_entry_{datetime.now().strftime('%Y%m%d')}.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        use_container_width=True
                    )
                
                with act3:
                    export_df = st.session_state.direct_entry_data.drop(columns=['_selected'], errors='ignore')
                    st.download_button(
                        " CSV",
                        data=export_df.to_csv(index=False),
                        file_name=f"budget_entry_{datetime.now().strftime('%Y%m%d')}.csv",
                        mime="text/csv",
                        use_container_width=True
                    )
                
                with act4:
                    # Copy PY to Budget - works on selected rows if any, otherwise all
                    btn_label = f" Copy PY ({int(selected_count)})" if selected_count > 0 else " Copy All PY"
                    if st.button(btn_label, key="de_copy_py", use_container_width=True, 
                                help="Copy Prior Year to Budget for selected rows (or all if none selected)"):
                        copy_df = st.session_state.direct_entry_data.copy()
                        
                        # Determine which rows to copy
                        if selected_count > 0 and '_selected' in copy_df.columns:
                            # Only copy selected rows
                            mask = copy_df['_selected'] == True
                            for m in MONTHS:
                                py_col = f'PY_{m}'
                                if py_col in copy_df.columns:
                                    copy_df.loc[mask, m] = copy_df.loc[mask, py_col]
                            copy_df.loc[mask, 'Budget_Annual'] = copy_df.loc[mask, [m for m in MONTHS if m in copy_df.columns]].sum(axis=1)
                            copy_df.loc[mask, 'Var_$'] = 0
                            copy_df.loc[mask, 'Var_%'] = 0
                            # Clear selection after copy
                            copy_df['_selected'] = False
                            msg = f"Copied PY to Budget for {int(selected_count)} selected rows!"
                        else:
                            # Copy all rows
                            for m in MONTHS:
                                py_col = f'PY_{m}'
                                if py_col in copy_df.columns:
                                    copy_df[m] = copy_df[py_col].copy()
                            copy_df['Budget_Annual'] = copy_df[[m for m in MONTHS if m in copy_df.columns]].sum(axis=1)
                            copy_df['Var_$'] = 0
                            copy_df['Var_%'] = 0
                            msg = "Copied Prior Year to Budget for all rows!"
                        
                        st.session_state.direct_entry_data = copy_df
                        if is_detail_view:
                            st.session_state.direct_entry_detail_data = copy_df.copy()
                        st.success(msg)
                        st.rerun()
                
                with act5:
                    # Select all / Clear selection
                    if selected_count > 0:
                        if st.button(" Clear Sel", key="de_clear_sel", use_container_width=True):
                            clear_df = st.session_state.direct_entry_data.copy()
                            clear_df['_selected'] = False
                            st.session_state.direct_entry_data = clear_df
                            st.rerun()
                    else:
                        if st.button(" Select All", key="de_select_all", use_container_width=True):
                            select_df = st.session_state.direct_entry_data.copy()
                            select_df['_selected'] = True
                            st.session_state.direct_entry_data = select_df
                            st.rerun()
                
                with act6:
                    if st.button(" Clear All", key="de_clear_all", use_container_width=True):
                        st.session_state.direct_entry_data = pd.DataFrame()
                        st.rerun()
        
        elif import_method == " Template Import":
            st.caption("Use saved templates to import and convert messy Excel files")
            
            # Reset Direct Entry dialog flags when switching away
            st.session_state.de_show_load_dialog = False
            st.session_state.de_show_save_dialog = False
            
            # -----------------------------------------------------------------
            # DEPARTMENT CONTEXT SELECTOR FOR TEMPLATE IMPORT
            # -----------------------------------------------------------------
            has_dept_lookup = 'org_departments' in st.session_state and not st.session_state.org_departments.empty
            
            if 'ti_dept_context' not in st.session_state:
                st.session_state.ti_dept_context = None
            
            ti_dept_ctx_col1, ti_dept_ctx_col2, ti_dept_ctx_col3 = st.columns([2, 2, 1])
            
            with ti_dept_ctx_col1:
                if has_dept_lookup:
                    dept_options_list = get_department_options()
                    dept_context_options = ['All Departments'] + dept_options_list
                    
                    # Find current index
                    current_idx = 0
                    if st.session_state.ti_dept_context and st.session_state.ti_dept_context in dept_context_options:
                        current_idx = dept_context_options.index(st.session_state.ti_dept_context)
                    
                    selected_dept_context = st.selectbox(
                        " Import Budget For", 
                        dept_context_options, 
                        index=current_idx,
                        key="ti_dept_context_select",
                        help="Select a department - imported data will be tagged with this department"
                    )
                    
                    if selected_dept_context != 'All Departments':
                        st.session_state.ti_dept_context = selected_dept_context
                    else:
                        st.session_state.ti_dept_context = None
                else:
                    st.info(" Upload department data in Settings  Organization to enable department selection")
            
            with ti_dept_ctx_col2:
                # Show auto-mapped info for selected department
                if st.session_state.ti_dept_context and has_dept_lookup:
                    dept_num = st.session_state.ti_dept_context.split()[0] if st.session_state.ti_dept_context else ''
                    dept_info = lookup_department(dept_num)
                    if dept_info:
                        st.caption(f"**{dept_info.get('Legal_Entity_Name', '')}** | {dept_info.get('Organization', '')} | {dept_info.get('Division', '')} | {dept_info.get('Business_Unit', '')}")
            
            with ti_dept_ctx_col3:
                if st.session_state.ti_dept_context:
                    if st.button(" Clear", key="ti_clear_dept_ctx", use_container_width=True):
                        st.session_state.ti_dept_context = None
                        st.rerun()
            
            st.markdown("---")
            
            # Show saved versions if available
            saved_versions = st.session_state.get('saved_budget_versions', {})
            if saved_versions:
                with st.expander(" Load Saved Version", expanded=False):
                    sv_col1, sv_col2, sv_col3 = st.columns([2, 1, 1])
                    with sv_col1:
                        version_list = list(saved_versions.keys())
                        selected_version = st.selectbox("Version", version_list, key="ti_version_select")
                    
                    if selected_version:
                        ver_info = saved_versions[selected_version]
                        with sv_col2:
                            st.metric("Total", f"${ver_info.get('total_budget', 0):,.0f}")
                        with sv_col3:
                            if st.button(" Load", type="primary", key="ti_load_version"):
                                # Load raw_data if available
                                ver_data = ver_info.get('data', {})
                                raw_data = ver_data.get('raw_data', pd.DataFrame())
                                
                                if not raw_data.empty:
                                    st.session_state.editable_budget_data = raw_data.copy()
                                    st.session_state.editable_budget_data['_row_id'] = range(len(raw_data))
                                    st.session_state.editable_budget_data['_parent_id'] = None
                                    st.session_state.editable_budget_data['_is_detail'] = False
                                    st.toast(f" Loaded '{selected_version}'")
                                    st.rerun()
                                else:
                                    st.warning("No template data in this version")
            
            # Initialize template storage
            if 'budget_templates' not in st.session_state:
                st.session_state.budget_templates = {}
            
            if 'advanced_templates' not in st.session_state:
                st.session_state.advanced_templates = {
                    'Kewaunee Roll Up': {
                        'id': 'kew_rollup_001',
                        'name': 'Kewaunee Roll Up',
                        'description': 'Kewaunee project budget roll-up format with monthly columns',
                        'created_by': 'System',
                        'created_date': datetime.now().strftime('%Y-%m-%d'),
                        'sheet_name': 'Roll Up',
                        'label_column': 0,
                        'month_columns': {1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr', 5: 'May', 6: 'Jun', 
                                         7: 'Jul', 8: 'Aug', 9: 'Sep', 10: 'Oct', 11: 'Nov', 12: 'Dec'},
                        'total_column': 13,
                        'row_config': {
                            15: {'include': True, 'label': 'Labor', 'category': 'Labor', 'type': 'detail'},
                            17: {'include': True, 'label': 'Fringe', 'category': 'Labor', 'type': 'detail'},
                            24: {'include': True, 'label': 'Staff Aug - Labor', 'category': 'Subcontracts', 'type': 'detail'},
                            25: {'include': True, 'label': 'Staff Aug - Travel', 'category': 'Travel', 'type': 'detail'},
                            26: {'include': True, 'label': 'Travel', 'category': 'Travel', 'type': 'detail'},
                            28: {'include': True, 'label': 'Facilities & Equipment', 'category': 'Materials', 'type': 'detail'},
                            29: {'include': True, 'label': 'Materials & Supplies', 'category': 'Materials', 'type': 'detail'},
                            30: {'include': True, 'label': 'Professional Services', 'category': 'Subcontracts', 'type': 'detail'},
                            31: {'include': True, 'label': 'Miscellaneous Expenses', 'category': 'Other', 'type': 'detail'},
                            33: {'include': True, 'label': 'Depreciation', 'category': 'Overhead', 'type': 'detail'},
                        },
                        'skip_patterns': ['Total', 'Net ', 'Intercompany', 'Elimination', 'ARO', '---', 'EBITDA'],
                        'project_info': {'row': 1, 'col': 1, 'field': 'Project_Code'},
                        'metadata': {'project_name_row': 2, 'project_name_col': 1},
                        'field_mapping': {
                            'Department': 'template_name',  # Use template/project name as department
                            'Account': 'row_label',  # Use row label as account
                            'Category': 'row_label',  # Category comes from row_config
                            'Description': 'row_label',
                            'Project': 'template_name',
                        }
                    }
                }
            
            if 'template_preview_data' not in st.session_state:
                st.session_state.template_preview_data = None
            
            all_templates = {**st.session_state.budget_templates, **st.session_state.advanced_templates}
            
            if not all_templates:
                st.warning("No templates available. Create a template in Administration  Templates.")
            else:
                # Three-column layout
                col1, col2, col3 = st.columns([1, 1.1, 1.1])
                
                with col1:
                    st.markdown("** Select Template**")
                    selected_template = st.selectbox("Template", options=list(all_templates.keys()), key="template_selector", label_visibility="collapsed")
                    st.caption(f"{len(all_templates)} templates available")
                    
                    if selected_template:
                        template = all_templates[selected_template]
                        is_advanced = selected_template in st.session_state.advanced_templates
                        with st.expander(" Details", expanded=False):
                            st.caption(f"Type: {'Advanced' if is_advanced else 'Standard'}")
                            if is_advanced:
                                st.caption(f"Sheet: {template.get('sheet_name', 'First')}")
                                st.caption(f"Rows: {len(template.get('row_config', {}))}")
                
                with col2:
                    st.markdown("** Upload File**")
                    uploaded_file = st.file_uploader("Upload", type=['xlsx', 'xls', 'csv'], key="template_file_upload", label_visibility="collapsed")
                
                with col3:
                    st.markdown("** Status**")
                    status_placeholder = st.empty()
                    if not (selected_template and uploaded_file):
                        status_placeholder.caption("Upload a file to process")
                
                if selected_template:
                    template = all_templates[selected_template]
                    is_advanced = selected_template in st.session_state.advanced_templates
                    
                    if uploaded_file:
                        try:
                            if is_advanced:
                                # Advanced template processing
                                sheet_name = template.get('sheet_name', 0)
                                try:
                                    raw_df = pd.read_excel(uploaded_file, sheet_name=sheet_name, header=None)
                                except:
                                    raw_df = pd.read_excel(uploaded_file, sheet_name=0, header=None)
                                
                                with st.expander(" Raw Data Preview", expanded=False):
                                    st.dataframe(raw_df.head(20), use_container_width=True)
                                
                                # Extract data based on row configuration
                                converted_data = []
                                label_col = template.get('label_column', 0)
                                month_cols = template.get('month_columns', {})
                                row_config = template.get('row_config', {})
                                
                                # Get project info if configured
                                project_code = 'Unknown'
                                if template.get('project_info'):
                                    pi = template['project_info']
                                    try:
                                        project_code = str(raw_df.iloc[pi['row'], pi['col']])
                                    except:
                                        pass
                                
                                # Process each configured row
                                for row_num, config in row_config.items():
                                    if not config.get('include', True):
                                        continue
                                    
                                    try:
                                        row_data = raw_df.iloc[row_num]
                                        label = config.get('label', row_data[label_col])
                                        category = config.get('category', 'Other')
                                        
                                        # Extract monthly values
                                        for col_idx, month_name in month_cols.items():
                                            try:
                                                amount = float(row_data[col_idx]) if pd.notna(row_data[col_idx]) else 0
                                            except:
                                                amount = 0
                                            
                                            month_num = MONTHS.index(month_name) + 1 if month_name in MONTHS else list(month_cols.values()).index(month_name) + 1
                                            
                                            converted_data.append({
                                                'Business_Unit': project_code,
                                                'Cost_Center': label,
                                                'Account_Category': category,
                                                'GL_Account': f"ROW-{row_num}",
                                                'Month_Num': month_num,
                                                'Month': month_name if month_name in MONTHS else MONTHS[month_num-1],
                                                'Amount': amount,
                                                'Year': datetime.now().year
                                            })
                                    except Exception as e:
                                        st.warning(f"Row {row_num}: {str(e)}")
                                
                                if converted_data:
                                    converted_df = pd.DataFrame(converted_data)
                                    st.session_state.template_upload_result = converted_df
                                    
                                    # Update status in col3
                                    with col3:
                                        total_amt = converted_df['Amount'].sum()
                                        st.success(f" Processed: {len(converted_df)} records")
                                        st.metric("Total", f"${total_amt:,.0f}")
                                        # Show saved version status if any
                                        if 'saved_versions' in st.session_state and st.session_state.saved_versions:
                                            latest_ver = list(st.session_state.saved_versions.keys())[-1]
                                            st.caption(f" Last saved: {latest_ver}")
                                    
                                    # Summary
                                    st.markdown("####  Summary & Visualization")
                                    
                                    # Two main columns: Tables on left, Charts on right
                                    left_col, right_col = st.columns([1, 2.5])
                                    
                                    with left_col:
                                        st.markdown("**By Cost Center:**")
                                        cc_sum = converted_df.groupby('Cost_Center')['Amount'].sum().reset_index()
                                        cc_sum = cc_sum.sort_values('Amount', ascending=False)
                                        cc_sum['Amount'] = cc_sum['Amount'].apply(lambda x: f"${x:,.0f}")
                                        st.dataframe(cc_sum, use_container_width=True, hide_index=True, height=180)
                                        
                                        st.markdown("**By Category:**")
                                        cat_sum = converted_df.groupby('Account_Category')['Amount'].sum().reset_index()
                                        cat_sum = cat_sum.sort_values('Amount', ascending=False)
                                        cat_sum['Amount'] = cat_sum['Amount'].apply(lambda x: f"${x:,.0f}")
                                        st.dataframe(cat_sum, use_container_width=True, hide_index=True, height=150)
                                    
                                    with right_col:
                                        # Filter at top of charts section
                                        cost_centers = ['All'] + sorted(converted_df['Cost_Center'].unique().tolist())
                                        selected_cc_filter = st.selectbox("Filter Charts by Cost Center", cost_centers, key="cc_filter")
                                        
                                        # Apply filter
                                        if selected_cc_filter != 'All':
                                            chart_df = converted_df[converted_df['Cost_Center'] == selected_cc_filter]
                                            filter_label = f" ({selected_cc_filter[:20]}...)" if len(selected_cc_filter) > 20 else f" ({selected_cc_filter})"
                                        else:
                                            chart_df = converted_df
                                            filter_label = ""
                                        
                                        cat_colors = {
                                            'Labor': '#0052C1', 'Subcontracts': '#00A9E0', 'Materials': '#28a745',
                                            'Travel': '#ffc107', 'Overhead': '#6c757d', 'Other': '#dc3545', 'Revenue': '#17a2b8'
                                        }
                                        
                                        # Two charts side by side
                                        chart_col1, chart_col2 = st.columns(2)
                                        
                                        with chart_col1:
                                            st.markdown(f"**Monthly Totals{filter_label}:**")
                                            monthly_sum = chart_df.groupby('Month_Num')['Amount'].sum().reset_index()
                                            monthly_sum['Month'] = monthly_sum['Month_Num'].apply(lambda x: MONTHS[x-1][:3])
                                            
                                            fig = go.Figure()
                                            fig.add_trace(go.Bar(
                                                x=monthly_sum['Month'], 
                                                y=monthly_sum['Amount']/1e6, 
                                                marker_color='#0052C1',
                                                text=monthly_sum['Amount'].apply(lambda x: f"${x/1e6:.1f}M"),
                                                textposition='outside'
                                            ))
                                            fig.update_layout(
                                                height=250, 
                                                yaxis_title='$M',
                                                showlegend=False,
                                                margin=dict(t=10, b=30, l=40, r=10)
                                            )
                                            st.plotly_chart(fig, use_container_width=True)
                                        
                                        with chart_col2:
                                            st.markdown(f"**Category Waterfall{filter_label}:**")
                                            
                                            cat_totals = chart_df.groupby('Account_Category')['Amount'].sum().sort_values(ascending=False)
                                            
                                            waterfall_x = list(cat_totals.index) + ['Total']
                                            waterfall_y = list(cat_totals.values / 1e6) + [cat_totals.sum() / 1e6]
                                            waterfall_measure = ['relative'] * len(cat_totals) + ['total']
                                            
                                            fig2 = go.Figure(go.Waterfall(
                                                x=waterfall_x, y=waterfall_y, measure=waterfall_measure,
                                                text=[f"${v:.1f}M" for v in waterfall_y], textposition='outside',
                                                connector={"line": {"color": "rgb(63, 63, 63)"}},
                                                increasing={"marker": {"color": "#0052C1"}},
                                                decreasing={"marker": {"color": "#dc3545"}},
                                                totals={"marker": {"color": "#28a745"}}
                                            ))
                                            fig2.update_layout(height=250, yaxis_title='$M', showlegend=False, margin=dict(t=10, b=30, l=40, r=10))
                                            st.plotly_chart(fig2, use_container_width=True)
                                        
                                        # Monthly by Category breakdown below the two charts
                                        with st.expander(" Monthly by Category Breakdown", expanded=False):
                                            monthly_cat = chart_df.groupby(['Month_Num', 'Account_Category'])['Amount'].sum().reset_index()
                                            monthly_cat['Month'] = monthly_cat['Month_Num'].apply(lambda x: MONTHS[x-1][:3])
                                            
                                            fig3 = go.Figure()
                                            for cat in monthly_cat['Account_Category'].unique():
                                                cat_data = monthly_cat[monthly_cat['Account_Category'] == cat]
                                                fig3.add_trace(go.Bar(name=cat, x=cat_data['Month'], y=cat_data['Amount']/1e6, marker_color=cat_colors.get(cat, '#999999')))
                                            
                                            fig3.update_layout(barmode='stack', height=280, yaxis_title='$M', legend=dict(orientation='h', yanchor='bottom', y=1.02))
                                            st.plotly_chart(fig3, use_container_width=True)
                                    
                                    # Full data preview with editable table
                                    st.markdown("---")
                                    st.markdown("####  Extracted Data - Edit & Customize")
                                    
                                    # Initialize editable data in session state
                                    if 'editable_budget_data' not in st.session_state:
                                        st.session_state.editable_budget_data = converted_df.copy()
                                        st.session_state.editable_budget_data['_row_id'] = range(len(converted_df))
                                        st.session_state.editable_budget_data['_parent_id'] = None
                                        st.session_state.editable_budget_data['_is_detail'] = False
                                        st.session_state.custom_detail_fields = []
                                        st.session_state.selected_parent_row = None
                                    
                                    # Clean top section layout
                                    # Single row: Edit Mode | View Mode | Add buttons
                                    ctrl_col1, ctrl_col2, ctrl_col3 = st.columns([1.2, 3, 2])
                                    
                                    with ctrl_col1:
                                        show_editable = st.checkbox(" Edit Mode", value=False, key="enable_edit")
                                    
                                    with ctrl_col2:
                                        view_mode = st.radio("View", [" Columns (Monthly)", " Hierarchical", " Rows (Detail)"], key="view_mode", horizontal=True, label_visibility="collapsed")
                                    
                                    with ctrl_col3:
                                        btn_col1, btn_col2, btn_col3 = st.columns(3)
                                        with btn_col1:
                                            if st.button(" Line Item", key="new_line_btn", use_container_width=True):
                                                st.session_state.show_new_line_dialog = True
                                                st.rerun()
                                        with btn_col2:
                                            if st.button(" Field", key="add_field_btn_top", use_container_width=True):
                                                st.session_state.show_add_field_dialog = True
                                                st.rerun()
                                        with btn_col3:
                                            if st.button(" Reset", key="reset_edit", use_container_width=True):
                                                st.session_state.editable_budget_data = converted_df.copy()
                                                st.session_state.editable_budget_data['_row_id'] = range(len(converted_df))
                                                st.session_state.editable_budget_data['_parent_id'] = None
                                                st.session_state.editable_budget_data['_is_detail'] = False
                                                st.session_state.custom_detail_fields = []
                                                st.rerun()
                                    
                                    # Show current custom fields if any
                                    if st.session_state.custom_detail_fields:
                                        st.caption(f" Custom fields: {', '.join(st.session_state.custom_detail_fields)}")
                                    
                                    working_df = st.session_state.editable_budget_data.copy()
                                    
                                    # Calculate grand total for percentages
                                    grand_total = working_df['Amount'].sum()
                                    
                                    # Dialog function for line item details
                                    @st.dialog(" Line Item Analysis", width="large")
                                    def show_line_detail_dialog(popup_cc, popup_cat, line_data, working_df, grand_total, parent_summary):
                                        line_total = line_data['Amount'].sum()
                                        line_pct_of_grand = (line_total / grand_total * 100) if grand_total > 0 else 0
                                        
                                        # Monthly breakdown
                                        monthly_data = line_data.groupby('Month_Num')['Amount'].sum()
                                        
                                        st.markdown(f"### {popup_cc}")
                                        st.caption(f"Category: {popup_cat}")
                                        
                                        # Key metrics
                                        pop_col1, pop_col2, pop_col3, pop_col4 = st.columns(4)
                                        
                                        with pop_col1:
                                            st.metric("Total Amount", f"${line_total:,.0f}")
                                        with pop_col2:
                                            st.metric("% of Budget", f"{line_pct_of_grand:.1f}%")
                                        with pop_col3:
                                            avg_monthly = line_total / 12 if line_total else 0
                                            st.metric("Avg Monthly", f"${avg_monthly:,.0f}")
                                        with pop_col4:
                                            # Rank among all lines
                                            all_lines = parent_summary.sort_values('Amount', ascending=False)
                                            rank_num = list(all_lines['Cost_Center']).index(popup_cc) + 1 if popup_cc in list(all_lines['Cost_Center']) else "N/A"
                                            st.metric("Rank", f"#{rank_num} of {len(all_lines)}")
                                        
                                        st.markdown("---")
                                        
                                        # Monthly chart
                                        st.markdown("** Monthly Distribution**")
                                        monthly_df = pd.DataFrame({
                                            'Month': [MONTHS[i-1][:3] for i in range(1, 13)],
                                            'Amount': [monthly_data.get(i, 0) for i in range(1, 13)]
                                        })
                                        
                                        fig = go.Figure()
                                        fig.add_trace(go.Bar(
                                            x=monthly_df['Month'],
                                            y=monthly_df['Amount']/1e6,
                                            marker_color='#0052C1',
                                            text=monthly_df['Amount'].apply(lambda x: f"${x/1e6:.2f}M" if x >= 1e6 else f"${x/1e3:.0f}K"),
                                            textposition='outside'
                                        ))
                                        fig.update_layout(height=280, yaxis_title='$ Millions', margin=dict(t=10, b=10, l=40, r=10))
                                        st.plotly_chart(fig, use_container_width=True)
                                        
                                        # Allocation breakdown
                                        st.markdown("---")
                                        alloc_col1, alloc_col2 = st.columns(2)
                                        
                                        with alloc_col1:
                                            st.markdown("** Budget Allocation**")
                                            # Category total and percentage
                                            cat_total = parent_summary[parent_summary['Account_Category'] == popup_cat]['Amount'].sum()
                                            pct_of_cat = (line_total / cat_total * 100) if cat_total > 0 else 0
                                            
                                            st.markdown(f"**% of Total Budget:** {line_pct_of_grand:.1f}%")
                                            st.progress(min(line_pct_of_grand / 100, 1.0))
                                            
                                            st.markdown(f"**% of {popup_cat} Category:** {pct_of_cat:.1f}%")
                                            st.progress(min(pct_of_cat / 100, 1.0))
                                        
                                        with alloc_col2:
                                            st.markdown("** Timing Analysis**")
                                            # Find peak and low months
                                            if not monthly_df['Amount'].empty and monthly_df['Amount'].sum() > 0:
                                                peak_idx = monthly_df['Amount'].idxmax()
                                                low_idx = monthly_df['Amount'].idxmin()
                                                peak_month = monthly_df.loc[peak_idx, 'Month']
                                                low_month = monthly_df.loc[low_idx, 'Month']
                                                peak_amt = monthly_df.loc[peak_idx, 'Amount']
                                                low_amt = monthly_df.loc[low_idx, 'Amount']
                                                
                                                st.markdown(f"**Peak Month:** {peak_month} (${peak_amt:,.0f})")
                                                st.markdown(f"**Low Month:** {low_month} (${low_amt:,.0f})")
                                                
                                                variance = (peak_amt - low_amt) / avg_monthly * 100 if avg_monthly > 0 else 0
                                                st.markdown(f"**Monthly Variance:** {variance:.0f}%")
                                        
                                        # Detail rows if any
                                        if '_parent_cc' in working_df.columns:
                                            detail_for_line = working_df[working_df['_parent_cc'] == popup_cc]
                                            if not detail_for_line.empty:
                                                st.markdown("---")
                                                st.markdown("** Detail Breakdown**")
                                                
                                                detail_summary = detail_for_line.groupby(['Cost_Center', '_detail_type']).agg({
                                                    'Amount': 'sum',
                                                    '_display_amount': lambda x: x.sum() if x.notna().any() else 0
                                                }).reset_index()
                                                
                                                # Table header
                                                det_hdr = st.columns([3, 1.5, 1, 1.5])
                                                with det_hdr[0]:
                                                    st.markdown("**Description**")
                                                with det_hdr[1]:
                                                    st.markdown("**Amount**")
                                                with det_hdr[2]:
                                                    st.markdown("**% of Line**")
                                                with det_hdr[3]:
                                                    st.markdown("**Type**")
                                                
                                                for _, det in detail_summary.iterrows():
                                                    det_cc = det['Cost_Center']
                                                    det_type = det.get('_detail_type', 'unknown')
                                                    det_amt = det['Amount'] if det['Amount'] > 0 else det.get('_display_amount', 0)
                                                    det_pct = (det_amt / line_total * 100) if line_total > 0 else 0
                                                    
                                                    det_cols = st.columns([3, 1.5, 1, 1.5])
                                                    with det_cols[0]:
                                                        icon = "" if det_type == 'incremental' else ""
                                                        clean_name = det_cc.replace('   ', '').replace(f'{popup_cc} - ', '')
                                                        st.markdown(f"{icon} {clean_name}")
                                                    with det_cols[1]:
                                                        st.markdown(f"${det_amt:,.0f}")
                                                    with det_cols[2]:
                                                        st.markdown(f"{det_pct:.1f}%")
                                                    with det_cols[3]:
                                                        if det_type == 'incremental':
                                                            st.markdown(" Added")
                                                        else:
                                                            st.markdown(" Breakdown")
                                                
                                                # Summary
                                                inc_total = detail_summary[detail_summary['_detail_type'] == 'incremental']['Amount'].sum()
                                                brk_total = detail_summary[detail_summary['_display_amount'].notna()]['_display_amount'].sum()
                                                
                                                st.caption(f"Added costs: ${inc_total:,.0f} | Allocated breakdown: ${brk_total:,.0f}")
                                    
                                    # Dialog function for Add Detail
                                    @st.dialog(" Add Detail", width="large")
                                    def show_add_detail_dialog(parent_cc, parent_cat, parent_total, parent_gl, project_code):
                                        month_order = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
                                        
                                        st.markdown(f"### Add Detail to: {parent_cc}")
                                        st.caption(f"Category: {parent_cat} | Current Total: ${parent_total:,.0f}")
                                        
                                        st.markdown("---")
                                        
                                        # Tabs for different add modes
                                        add_tab1, add_tab2, add_tab3 = st.tabs([
                                            " Add to Total", 
                                            " Breakdown (Info Only)",
                                            " All 12 Months"
                                        ])
                                        
                                        with add_tab1:
                                            st.markdown("**Add NEW cost that increases the line total**")
                                            st.caption("Use this when you have additional costs to add (e.g., new equipment, additional vendor)")
                                            
                                            inc_col1, inc_col2 = st.columns(2)
                                            with inc_col1:
                                                inc_description = st.text_input("Description", placeholder="e.g., Equipment X, Vendor ABC", key="dlg_inc_desc")
                                                inc_month = st.selectbox("Month", month_order, key="dlg_inc_month")
                                            with inc_col2:
                                                inc_amount = st.number_input("Amount ($)", value=0.0, min_value=0.0, key="dlg_inc_amt")
                                                st.markdown(f"**New Line Total:** ${parent_total + inc_amount:,.0f}")
                                                st.markdown(f"**Change:** +${inc_amount:,.0f}")
                                            
                                            if st.button(" Add Incremental Cost", type="primary", key="dlg_add_inc"):
                                                if inc_description and inc_amount > 0:
                                                    new_row = {
                                                        'Business_Unit': project_code,
                                                        'Cost_Center': f"{parent_cc} - {inc_description}",
                                                        'Account_Category': parent_cat,
                                                        'GL_Account': f"{parent_gl}-INC",
                                                        'Month_Num': month_order.index(inc_month) + 1,
                                                        'Month': inc_month,
                                                        'Amount': inc_amount,
                                                        'Year': datetime.now().year,
                                                        '_row_id': len(st.session_state.editable_budget_data),
                                                        '_parent_cc': parent_cc,
                                                        '_is_detail': True,
                                                        '_detail_type': 'incremental'
                                                    }
                                                    st.session_state.editable_budget_data = pd.concat([
                                                        st.session_state.editable_budget_data,
                                                        pd.DataFrame([new_row])
                                                    ], ignore_index=True)
                                                    st.session_state.detail_added_success = f"Added ${inc_amount:,.0f} to {parent_cc}"
                                                    st.rerun()
                                                else:
                                                    st.warning("Enter description and amount > 0")
                                        
                                        with add_tab2:
                                            st.markdown("**Break out EXISTING costs into detail (no change to total)**")
                                            st.caption("Use this to show what makes up a line item (e.g., show vendors that make up Professional Services)")
                                            
                                            brk_col1, brk_col2 = st.columns(2)
                                            with brk_col1:
                                                brk_description = st.text_input("Description", placeholder="e.g., Vendor XYZ portion", key="dlg_brk_desc")
                                                brk_month = st.selectbox("Month", month_order, key="dlg_brk_month")
                                            with brk_col2:
                                                brk_amount = st.number_input("Allocated Amount ($)", value=0.0, key="dlg_brk_amt")
                                                pct_of_line = (brk_amount / parent_total * 100) if parent_total > 0 else 0
                                                st.markdown(f"**% of Line:** {pct_of_line:.1f}%")
                                                st.caption("*This is informational only - total unchanged*")
                                            
                                            if st.button(" Add Breakdown", key="dlg_add_brk"):
                                                if brk_description:
                                                    new_row = {
                                                        'Business_Unit': project_code,
                                                        'Cost_Center': f"   {brk_description}",
                                                        'Account_Category': parent_cat,
                                                        'GL_Account': f"{parent_gl}-DTL",
                                                        'Month_Num': month_order.index(brk_month) + 1,
                                                        'Month': brk_month,
                                                        'Amount': 0,
                                                        '_display_amount': brk_amount,
                                                        'Year': datetime.now().year,
                                                        '_row_id': len(st.session_state.editable_budget_data),
                                                        '_parent_cc': parent_cc,
                                                        '_is_detail': True,
                                                        '_detail_type': 'breakdown'
                                                    }
                                                    st.session_state.editable_budget_data = pd.concat([
                                                        st.session_state.editable_budget_data,
                                                        pd.DataFrame([new_row])
                                                    ], ignore_index=True)
                                                    st.session_state.detail_added_success = f"Added breakdown for {parent_cc} (total unchanged)"
                                                    st.rerun()
                                                else:
                                                    st.warning("Enter a description")
                                        
                                        with add_tab3:
                                            st.markdown("**Quick add same amount for all 12 months**")
                                            
                                            quick_col1, quick_col2 = st.columns(2)
                                            with quick_col1:
                                                quick_desc = st.text_input("Description", key="dlg_quick_desc")
                                                quick_type = st.radio("Type", ["Add to Total", "Breakdown Only"], key="dlg_quick_type", horizontal=True)
                                            with quick_col2:
                                                quick_monthly = st.number_input("Monthly Amount ($)", value=0.0, key="dlg_quick_monthly")
                                                annual_total = quick_monthly * 12
                                                st.markdown(f"**Annual Total:** ${annual_total:,.0f}")
                                                if quick_type == "Add to Total":
                                                    st.markdown(f"**New Line Total:** ${parent_total + annual_total:,.0f}")
                                                else:
                                                    st.caption("*No change to totals*")
                                            
                                            if st.button(" Add 12 Months", type="primary", key="dlg_quick_add"):
                                                if quick_desc:
                                                    new_rows = []
                                                    for i, month in enumerate(month_order):
                                                        new_row = {
                                                            'Business_Unit': project_code,
                                                            'Cost_Center': f"{parent_cc} - {quick_desc}" if quick_type == "Add to Total" else f"   {quick_desc}",
                                                            'Account_Category': parent_cat,
                                                            'GL_Account': f"{parent_gl}-{'INC' if quick_type == 'Add to Total' else 'DTL'}",
                                                            'Month_Num': i + 1,
                                                            'Month': month,
                                                            'Amount': quick_monthly if quick_type == "Add to Total" else 0,
                                                            '_display_amount': quick_monthly,
                                                            'Year': datetime.now().year,
                                                            '_row_id': len(st.session_state.editable_budget_data) + i,
                                                            '_parent_cc': parent_cc,
                                                            '_is_detail': True,
                                                            '_detail_type': 'incremental' if quick_type == "Add to Total" else 'breakdown'
                                                        }
                                                        new_rows.append(new_row)
                                                    
                                                    st.session_state.editable_budget_data = pd.concat([
                                                        st.session_state.editable_budget_data,
                                                        pd.DataFrame(new_rows)
                                                    ], ignore_index=True)
                                                    st.session_state.detail_added_success = f"Added 12 months for {quick_desc}"
                                                    st.rerun()
                                                else:
                                                    st.warning("Enter a description")
                                    
                                    # Dialog function for Delete confirmation
                                    @st.dialog(" Confirm Delete", width="small")
                                    def show_delete_confirm_dialog(rows_to_delete, total_amount):
                                        st.markdown("### Are you sure you want to delete?")
                                        st.markdown("---")
                                        
                                        if len(rows_to_delete) == 1:
                                            st.markdown(f"**Line Item:** {rows_to_delete[0]}")
                                            st.markdown(f"**Total Amount:** ${total_amount:,.0f}")
                                        else:
                                            st.markdown(f"**{len(rows_to_delete)} line items:**")
                                            for row in rows_to_delete[:5]:  # Show first 5
                                                st.markdown(f" {row}")
                                            if len(rows_to_delete) > 5:
                                                st.markdown(f"*...and {len(rows_to_delete) - 5} more*")
                                            st.markdown(f"**Combined Total:** ${total_amount:,.0f}")
                                        
                                        st.markdown("---")
                                        st.warning(" This action cannot be undone!")
                                        
                                        col1, col2 = st.columns(2)
                                        with col1:
                                            if st.button(" Yes, Delete", type="primary", use_container_width=True):
                                                st.session_state.editable_budget_data = st.session_state.editable_budget_data[
                                                    ~st.session_state.editable_budget_data['Cost_Center'].isin(rows_to_delete)
                                                ]
                                                st.session_state.delete_success = f"Deleted {len(rows_to_delete)} line(s)"
                                                st.session_state.show_delete_confirm = None  # Clear to close dialog
                                                st.rerun()
                                        with col2:
                                            if st.button("Cancel", use_container_width=True):
                                                st.session_state.show_delete_confirm = None
                                                st.rerun()
                                    
                                    # Dialog function for New Line Item
                                    @st.dialog(" Add New Line Item", width="large")
                                    def show_new_line_dialog(project_code):
                                        st.markdown("Add a new budget line item")
                                        st.markdown("---")
                                        
                                        month_order = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
                                        
                                        col1, col2 = st.columns(2)
                                        
                                        with col1:
                                            new_cost_center = st.text_input("Cost Center / Line Item Name", key="dlg_new_cc")
                                            new_category = st.selectbox("Category", ['Labor', 'Subcontracts', 'Materials', 'Travel', 'Overhead', 'Other'], key="dlg_new_cat")
                                            new_gl = st.text_input("GL Account / Code", value="NEW-001", key="dlg_new_gl")
                                        
                                        with col2:
                                            add_mode = st.radio("Add Mode", ["Single Month", "All 12 Months"], key="dlg_add_mode", horizontal=True)
                                            
                                            if add_mode == "Single Month":
                                                new_month = st.selectbox("Month", month_order, key="dlg_new_month")
                                                new_amount = st.number_input("Amount ($)", value=0.0, min_value=0.0, key="dlg_new_amt")
                                            else:
                                                new_amount = st.number_input("Monthly Amount ($)", value=0.0, min_value=0.0, key="dlg_new_monthly")
                                                st.caption(f"Annual Total: ${new_amount * 12:,.0f}")
                                        
                                        st.markdown("---")
                                        
                                        if st.button(" Add Line Item", type="primary", use_container_width=True):
                                            if new_cost_center:
                                                if add_mode == "Single Month":
                                                    new_row = {
                                                        'Business_Unit': project_code,
                                                        'Cost_Center': new_cost_center,
                                                        'Account_Category': new_category,
                                                        'GL_Account': new_gl,
                                                        'Month_Num': month_order.index(new_month) + 1,
                                                        'Month': new_month,
                                                        'Amount': new_amount,
                                                        'Year': datetime.now().year,
                                                        '_row_id': len(st.session_state.editable_budget_data),
                                                        '_parent_cc': None,
                                                        '_is_detail': False
                                                    }
                                                    st.session_state.editable_budget_data = pd.concat([
                                                        st.session_state.editable_budget_data,
                                                        pd.DataFrame([new_row])
                                                    ], ignore_index=True)
                                                    st.session_state.new_line_success = f"Added: {new_cost_center}"
                                                else:
                                                    new_rows = []
                                                    for i, month in enumerate(month_order):
                                                        new_row = {
                                                            'Business_Unit': project_code,
                                                            'Cost_Center': new_cost_center,
                                                            'Account_Category': new_category,
                                                            'GL_Account': new_gl,
                                                            'Month_Num': i + 1,
                                                            'Month': month,
                                                            'Amount': new_amount,
                                                            'Year': datetime.now().year,
                                                            '_row_id': len(st.session_state.editable_budget_data) + i,
                                                            '_parent_cc': None,
                                                            '_is_detail': False
                                                        }
                                                        new_rows.append(new_row)
                                                    st.session_state.editable_budget_data = pd.concat([
                                                        st.session_state.editable_budget_data,
                                                        pd.DataFrame(new_rows)
                                                    ], ignore_index=True)
                                                    st.session_state.new_line_success = f"Added: {new_cost_center} (12 months)"
                                                st.rerun()
                                            else:
                                                st.warning("Please enter a Cost Center name")
                                    
                                    # Dialog function for Add Field
                                    @st.dialog(" Add Custom Field", width="small")
                                    def show_add_field_dialog():
                                        st.markdown("Add a custom field to track additional details")
                                        st.markdown("---")
                                        
                                        new_field_name = st.text_input("Field Name", placeholder="e.g., Vendor, Employee, Task", key="dlg_field_name")
                                        
                                        st.caption("Examples: Vendor, Employee, Task, Notes, PO Number")
                                        
                                        if st.session_state.custom_detail_fields:
                                            st.markdown(f"**Existing fields:** {', '.join(st.session_state.custom_detail_fields)}")
                                        
                                        st.markdown("---")
                                        
                                        if st.button(" Add Field", type="primary", use_container_width=True):
                                            if new_field_name and new_field_name not in st.session_state.editable_budget_data.columns:
                                                st.session_state.editable_budget_data[new_field_name] = ""
                                                if new_field_name not in st.session_state.custom_detail_fields:
                                                    st.session_state.custom_detail_fields.append(new_field_name)
                                                st.session_state.field_added_success = f"Added field: {new_field_name}"
                                                st.rerun()
                                            elif new_field_name in st.session_state.editable_budget_data.columns:
                                                st.warning("Field already exists")
                                            else:
                                                st.warning("Please enter a field name")
                                    
                                    # Dialog function for View Changes
                                    @st.dialog(" Change Details", width="large")
                                    def show_changes_dialog():
                                        if 'changes_data' not in st.session_state:
                                            st.warning("No change data available")
                                            return
                                        
                                        data = st.session_state.changes_data
                                        orig_total = data['orig_total']
                                        edit_total = data['edit_total']
                                        diff = data['diff']
                                        orig_rows = data['orig_rows']
                                        curr_rows = data['curr_rows']
                                        row_diff = data['row_diff']
                                        final_df = data['final_df']
                                        converted_df = data['converted_df']
                                        
                                        st.markdown("### Summary of Changes")
                                        st.markdown("---")
                                        
                                        # Original vs Current comparison
                                        comp_col1, comp_col2, comp_col3 = st.columns(3)
                                        with comp_col1:
                                            st.metric("Original Total", f"${orig_total:,.0f}")
                                            st.metric("Original Rows", orig_rows)
                                        with comp_col2:
                                            st.metric("Current Total", f"${edit_total:,.0f}")
                                            st.metric("Current Rows", curr_rows)
                                        with comp_col3:
                                            st.metric("Difference", f"${diff:,.0f}", delta=f"{diff/orig_total*100:.1f}%" if orig_total > 0 else "N/A")
                                            st.metric("Rows Added", row_diff)
                                        
                                        st.markdown("---")
                                        
                                        # Show new/added rows
                                        if '_is_detail' in final_df.columns:
                                            new_detail_rows = final_df[final_df['_is_detail'] == True]
                                            if len(new_detail_rows) > 0:
                                                st.markdown("**Added Detail Rows:**")
                                                display_cols = ['Cost_Center', 'Account_Category', 'Month', 'Amount']
                                                display_cols = [c for c in display_cols if c in new_detail_rows.columns]
                                                st.dataframe(new_detail_rows[display_cols].head(20), use_container_width=True, hide_index=True)
                                                if len(new_detail_rows) > 20:
                                                    st.caption(f"...and {len(new_detail_rows) - 20} more rows")
                                        
                                        # Show totals by category comparison
                                        st.markdown("**Totals by Category:**")
                                        orig_cat = converted_df.groupby('Account_Category')['Amount'].sum().reset_index()
                                        orig_cat.columns = ['Category', 'Original']
                                        curr_cat = final_df.groupby('Account_Category')['Amount'].sum().reset_index()
                                        curr_cat.columns = ['Category', 'Current']
                                        
                                        comparison = orig_cat.merge(curr_cat, on='Category', how='outer').fillna(0)
                                        comparison['Change'] = comparison['Current'] - comparison['Original']
                                        comparison['Original'] = comparison['Original'].apply(lambda x: f"${x:,.0f}")
                                        comparison['Current'] = comparison['Current'].apply(lambda x: f"${x:,.0f}")
                                        comparison['Change'] = comparison['Change'].apply(lambda x: f"${x:+,.0f}")
                                        st.dataframe(comparison, use_container_width=True, hide_index=True)
                                    
                                    # Check if dialogs should be shown - use elif to ensure only ONE opens
                                    if 'show_detail_dialog' in st.session_state and st.session_state.show_detail_dialog:
                                        dialog_data = st.session_state.show_detail_dialog
                                        st.session_state.show_detail_dialog = None  # Clear BEFORE opening
                                        show_line_detail_dialog(
                                            dialog_data['popup_cc'],
                                            dialog_data['popup_cat'],
                                            dialog_data['line_data'],
                                            working_df,
                                            grand_total,
                                            dialog_data['parent_summary']
                                        )
                                    
                                    elif 'show_add_detail_dialog' in st.session_state and st.session_state.show_add_detail_dialog:
                                        dialog_data = st.session_state.show_add_detail_dialog
                                        st.session_state.show_add_detail_dialog = None  # Clear BEFORE opening
                                        show_add_detail_dialog(
                                            dialog_data['cc'],
                                            dialog_data['cat'],
                                            dialog_data['total'],
                                            dialog_data['gl'],
                                            dialog_data['project_code']
                                        )
                                    
                                    elif 'show_delete_confirm' in st.session_state and st.session_state.show_delete_confirm:
                                        dialog_data = st.session_state.show_delete_confirm
                                        show_delete_confirm_dialog(
                                            dialog_data['rows'],
                                            dialog_data['total']
                                        )
                                    
                                    elif 'show_new_line_dialog' in st.session_state and st.session_state.show_new_line_dialog:
                                        st.session_state.show_new_line_dialog = False  # Clear BEFORE opening
                                        show_new_line_dialog(project_code)
                                    
                                    elif 'show_add_field_dialog' in st.session_state and st.session_state.show_add_field_dialog:
                                        st.session_state.show_add_field_dialog = False  # Clear BEFORE opening
                                        show_add_field_dialog()
                                    
                                    elif 'show_changes_dialog' in st.session_state and st.session_state.show_changes_dialog:
                                        st.session_state.show_changes_dialog = False  # Clear BEFORE opening
                                        show_changes_dialog()
                                    
                                    # Show success messages if any
                                    if 'detail_added_success' in st.session_state and st.session_state.detail_added_success:
                                        st.success(f" {st.session_state.detail_added_success}")
                                        st.session_state.detail_added_success = None
                                    
                                    if 'delete_success' in st.session_state and st.session_state.delete_success:
                                        st.success(f" {st.session_state.delete_success}")
                                        st.session_state.delete_success = None
                                    
                                    if 'new_line_success' in st.session_state and st.session_state.new_line_success:
                                        st.success(f" {st.session_state.new_line_success}")
                                        st.session_state.new_line_success = None
                                    
                                    if 'field_added_success' in st.session_state and st.session_state.field_added_success:
                                        st.success(f" {st.session_state.field_added_success}")
                                        st.session_state.field_added_success = None
                                    
                                    if view_mode == " Hierarchical":
                                        # Hierarchical collapsible view
                                        st.markdown("#####  Hierarchical View (Click to Expand)")
                                        st.caption("Expand line items to see detail breakdowns. Click  for detailed analysis.")
                                        
                                        # Initialize expanded state
                                        if 'expanded_lines' not in st.session_state:
                                            st.session_state.expanded_lines = set()
                                        if 'show_detail_dialog' not in st.session_state:
                                            st.session_state.show_detail_dialog = None
                                        
                                        # Group by Cost Center (parent lines)
                                        parent_lines = working_df[working_df.get('_is_detail', False) == False].copy() if '_is_detail' in working_df.columns else working_df.copy()
                                        
                                        # Aggregate parent lines
                                        parent_summary = parent_lines.groupby(['Cost_Center', 'Account_Category']).agg({
                                            'Amount': 'sum',
                                            'GL_Account': 'first'
                                        }).reset_index()
                                        parent_summary = parent_summary.sort_values('Amount', ascending=False)
                                        
                                        # Get detail rows
                                        detail_rows = working_df[working_df.get('_is_detail', False) == True] if '_is_detail' in working_df.columns else pd.DataFrame()
                                        
                                        # Month order for display
                                        month_order = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
                                        
                                        # Header row
                                        header_cols = st.columns([0.3, 2.5, 1, 1, 1, 1, 0.5])
                                        with header_cols[0]:
                                            st.markdown("****")
                                        with header_cols[1]:
                                            st.markdown("**Cost Center**")
                                        with header_cols[2]:
                                            st.markdown("**Category**")
                                        with header_cols[3]:
                                            st.markdown("**Amount**")
                                        with header_cols[4]:
                                            st.markdown("**% of Total**")
                                        with header_cols[5]:
                                            st.markdown("**Details**")
                                        with header_cols[6]:
                                            st.markdown("**Info**")
                                        
                                        st.markdown("---")
                                        
                                        # Render each parent line with expandable details
                                        for idx, parent_row in parent_summary.iterrows():
                                            parent_cc = parent_row['Cost_Center']
                                            parent_cat = parent_row['Account_Category']
                                            parent_amount = parent_row['Amount']
                                            parent_pct = (parent_amount / grand_total * 100) if grand_total > 0 else 0
                                            
                                            # Check for detail rows under this parent
                                            if '_parent_cc' in detail_rows.columns:
                                                child_rows = detail_rows[detail_rows['_parent_cc'] == parent_cc]
                                            else:
                                                child_rows = pd.DataFrame()
                                            
                                            has_details = len(child_rows) > 0
                                            line_key = f"{parent_cc}_{parent_cat}"
                                            is_expanded = line_key in st.session_state.expanded_lines
                                            
                                            # Parent row
                                            row_cols = st.columns([0.3, 2.5, 1, 1, 1, 1, 0.5])
                                            
                                            with row_cols[0]:
                                                if has_details:
                                                    expand_label = "" if is_expanded else ""
                                                    if st.button(expand_label, key=f"exp_{line_key}", help="Expand/Collapse"):
                                                        if is_expanded:
                                                            st.session_state.expanded_lines.discard(line_key)
                                                        else:
                                                            st.session_state.expanded_lines.add(line_key)
                                                        st.rerun()
                                                else:
                                                    st.markdown("")
                                            
                                            with row_cols[1]:
                                                st.markdown(f"**{parent_cc}**")
                                            
                                            with row_cols[2]:
                                                cat_colors = {'Labor': '', 'Subcontracts': '', 'Materials': '', 
                                                             'Travel': '', 'Overhead': '', 'Other': '', 'Revenue': ''}
                                                st.markdown(f"{cat_colors.get(parent_cat, '')} {parent_cat}")
                                            
                                            with row_cols[3]:
                                                st.markdown(f"**${parent_amount:,.0f}**")
                                            
                                            with row_cols[4]:
                                                # Progress bar for percentage
                                                st.progress(min(parent_pct / 100, 1.0))
                                                st.caption(f"{parent_pct:.1f}%")
                                            
                                            with row_cols[5]:
                                                if has_details:
                                                    detail_count = len(child_rows['Cost_Center'].unique())
                                                    inc_count = len(child_rows[child_rows.get('_detail_type', '') == 'incremental']) if '_detail_type' in child_rows.columns else 0
                                                    brk_count = len(child_rows[child_rows.get('_detail_type', '') == 'breakdown']) if '_detail_type' in child_rows.columns else 0
                                                    st.caption(f" {detail_count} items")
                                                else:
                                                    st.caption("")
                                            
                                            with row_cols[6]:
                                                if st.button("", key=f"info_{line_key}", help="View Details"):
                                                    # Get data for this line
                                                    line_data = working_df[working_df['Cost_Center'] == parent_cc]
                                                    st.session_state.show_detail_dialog = {
                                                        'popup_cc': parent_cc,
                                                        'popup_cat': parent_cat,
                                                        'line_data': line_data,
                                                        'parent_summary': parent_summary
                                                    }
                                                    st.rerun()
                                            
                                            # Show detail rows if expanded
                                            if is_expanded and has_details:
                                                # Group child rows by their cost center
                                                child_summary = child_rows.groupby(['Cost_Center', '_detail_type']).agg({
                                                    'Amount': 'sum',
                                                    '_display_amount': 'sum' if '_display_amount' in child_rows.columns else 'first'
                                                }).reset_index()
                                                
                                                for _, child in child_summary.iterrows():
                                                    child_cc = child['Cost_Center']
                                                    child_type = child.get('_detail_type', 'incremental')
                                                    child_amount = child['Amount']
                                                    display_amt = child.get('_display_amount', child_amount)
                                                    if pd.isna(display_amt):
                                                        display_amt = child_amount
                                                    child_pct_of_parent = (display_amt / parent_amount * 100) if parent_amount > 0 else 0
                                                    
                                                    detail_cols = st.columns([0.3, 2.5, 1, 1, 1, 1, 0.5])
                                                    
                                                    with detail_cols[0]:
                                                        st.markdown("")  # Indent
                                                    
                                                    with detail_cols[1]:
                                                        if child_type == 'breakdown':
                                                            st.markdown(f"<span style='color: #222; margin-left: 20px;'> {child_cc.replace('   ', '')}</span>", unsafe_allow_html=True)
                                                        else:
                                                            st.markdown(f"<span style='color: #0066cc; margin-left: 20px;'>+ {child_cc}</span>", unsafe_allow_html=True)
                                                    
                                                    with detail_cols[2]:
                                                        if child_type == 'breakdown':
                                                            st.caption(" Breakdown")
                                                        else:
                                                            st.caption(" Added")
                                                    
                                                    with detail_cols[3]:
                                                        if child_type == 'breakdown':
                                                            st.markdown(f"*${display_amt:,.0f}*")
                                                        else:
                                                            st.markdown(f"${child_amount:,.0f}")
                                                    
                                                    with detail_cols[4]:
                                                        st.caption(f"{child_pct_of_parent:.1f}% of line")
                                                    
                                                    with detail_cols[5]:
                                                        st.caption("")
                                                    
                                                    with detail_cols[6]:
                                                        st.caption("")
                                                
                                                st.markdown("")  # Spacing after expanded section
                                        
                                        # Summary row
                                        st.markdown("---")
                                        summary_cols = st.columns([0.3, 2.5, 1, 1, 1, 1, 0.5])
                                        with summary_cols[1]:
                                            st.markdown("**TOTAL**")
                                        with summary_cols[3]:
                                            st.markdown(f"**${grand_total:,.0f}**")
                                        with summary_cols[4]:
                                            st.markdown("**100%**")
                                    
                                    elif view_mode == " Columns (Monthly)":
                                        # Pivot to show months as columns with row selection
                                        st.markdown("##### Monthly View (Months as Columns)")
                                        
                                        # Initialize session state
                                        if 'show_add_detail_dialog' not in st.session_state:
                                            st.session_state.show_add_detail_dialog = None
                                        if 'show_delete_confirm' not in st.session_state:
                                            st.session_state.show_delete_confirm = None
                                        if 'pivot_key_counter' not in st.session_state:
                                            st.session_state.pivot_key_counter = 0
                                        
                                        # Determine grouping columns
                                        group_cols = ['Business_Unit', 'Cost_Center', 'Account_Category', 'GL_Account']
                                        group_cols += [f for f in st.session_state.custom_detail_fields if f in working_df.columns]
                                        
                                        # Pivot the data
                                        pivot_df = working_df.pivot_table(
                                            index=[c for c in group_cols if c in working_df.columns],
                                            columns='Month',
                                            values='Amount',
                                            aggfunc='sum',
                                            fill_value=0
                                        ).reset_index()
                                        
                                        # Reorder month columns
                                        month_order = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
                                        existing_months = [m for m in month_order if m in pivot_df.columns]
                                        other_cols = [c for c in pivot_df.columns if c not in month_order]
                                        pivot_df = pivot_df[other_cols + existing_months]
                                        
                                        # Add Total column
                                        if existing_months:
                                            pivot_df['Total'] = pivot_df[existing_months].sum(axis=1)
                                        
                                        # Add selection column
                                        pivot_df.insert(0, 'Select', False)
                                        
                                        # Action bar ABOVE the table
                                        action_bar = st.container()
                                        
                                        # Configure columns
                                        column_config = {
                                            'Select': st.column_config.CheckboxColumn('', default=False, width='small')
                                        }
                                        for col in existing_months + ['Total']:
                                            column_config[col] = st.column_config.NumberColumn(
                                                col,
                                                format="$%.0f",
                                                width='small'
                                            )
                                        
                                        # Show data editor with selection (use key counter to allow reset)
                                        edited_pivot = st.data_editor(
                                            pivot_df,
                                            use_container_width=True,
                                            hide_index=True,
                                            column_config=column_config,
                                            disabled=['Total'] if not show_editable else ['Total'],
                                            key=f"pivot_selector_{st.session_state.pivot_key_counter}"
                                        )
                                        
                                        # Get selected rows
                                        selected_indices = edited_pivot[edited_pivot['Select'] == True].index.tolist()
                                        selected_rows_data = edited_pivot[edited_pivot['Select'] == True]
                                        
                                        # Populate action bar (above table)
                                        with action_bar:
                                            if len(selected_indices) > 0:
                                                # Get selected row info
                                                selected_cc = selected_rows_data['Cost_Center'].iloc[0] if len(selected_rows_data) == 1 else None
                                                selected_cat = selected_rows_data['Account_Category'].iloc[0] if len(selected_rows_data) == 1 else None
                                                selected_total = selected_rows_data['Total'].sum()
                                                rows_to_delete = selected_rows_data['Cost_Center'].tolist()
                                                
                                                # Selection info and actions
                                                sel_col1, sel_col2, sel_col3, sel_col4, sel_col5 = st.columns([2.5, 1, 1, 1, 1])
                                                
                                                with sel_col1:
                                                    if len(selected_indices) == 1:
                                                        st.info(f" **{selected_cc}** (${selected_total:,.0f})")
                                                    else:
                                                        st.info(f" **{len(selected_indices)} rows selected** (${selected_total:,.0f})")
                                                
                                                with sel_col2:
                                                    if len(selected_indices) == 1:
                                                        if st.button(" Add Detail", key="add_detail_btn", type="primary", use_container_width=True):
                                                            st.session_state.show_add_detail_dialog = {
                                                                'cc': selected_cc,
                                                                'cat': selected_cat,
                                                                'total': selected_total,
                                                                'gl': selected_rows_data['GL_Account'].iloc[0] if 'GL_Account' in selected_rows_data.columns else 'NEW',
                                                                'project_code': project_code
                                                            }
                                                            st.rerun()
                                                
                                                with sel_col3:
                                                    if len(selected_indices) == 1:
                                                        if st.button(" View", key="view_detail_btn", use_container_width=True):
                                                            line_data = working_df[working_df['Cost_Center'] == selected_cc]
                                                            parent_summary = pivot_df[['Cost_Center', 'Account_Category', 'Total']].copy()
                                                            parent_summary.columns = ['Cost_Center', 'Account_Category', 'Amount']
                                                            st.session_state.show_detail_dialog = {
                                                                'popup_cc': selected_cc,
                                                                'popup_cat': selected_cat,
                                                                'line_data': line_data,
                                                                'parent_summary': parent_summary
                                                            }
                                                            st.rerun()
                                                
                                                with sel_col4:
                                                    if st.button(" Delete", key="delete_rows_btn", use_container_width=True):
                                                        st.session_state.show_delete_confirm = {
                                                            'rows': rows_to_delete,
                                                            'total': selected_total
                                                        }
                                                        st.rerun()
                                                
                                                with sel_col5:
                                                    if st.button(" Clear", key="clear_selection", use_container_width=True):
                                                        st.session_state.pivot_key_counter += 1
                                                        st.rerun()
                                            else:
                                                # No selection - show helper text
                                                st.caption(" Select rows using checkboxes to add detail, view analysis, or delete")
                                        
                                        # Summary row
                                        totals = {}
                                        for col in existing_months:
                                            if col in pivot_df.columns:
                                                totals[col] = f"${pivot_df[col].sum():,.0f}"
                                        totals['Total'] = f"${pivot_df['Total'].sum():,.0f}" if 'Total' in pivot_df.columns else "N/A"
                                        st.dataframe(pd.DataFrame([totals]), use_container_width=True, hide_index=True)
                                    
                                    else:
                                        # Row view (original format)
                                        st.markdown("##### Detail View (Months as Rows)")
                                        
                                        if show_editable:
                                            # Column configuration
                                            column_config = {
                                                'Amount': st.column_config.NumberColumn(
                                                    'Amount',
                                                    format="$%.2f",
                                                    min_value=-999999999,
                                                    max_value=999999999
                                                ),
                                                'Month': st.column_config.SelectboxColumn(
                                                    'Month',
                                                    options=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                                                    required=True
                                                ),
                                                'Month_Num': st.column_config.NumberColumn(
                                                    'Month #',
                                                    min_value=1,
                                                    max_value=12
                                                ),
                                                'Account_Category': st.column_config.SelectboxColumn(
                                                    'Category',
                                                    options=['Labor', 'Subcontracts', 'Materials', 'Travel', 'Overhead', 'Other', 'Revenue'],
                                                    required=True
                                                )
                                            }
                                            
                                            edited_df = st.data_editor(
                                                working_df,
                                                use_container_width=True,
                                                hide_index=True,
                                                num_rows="dynamic",
                                                column_config=column_config,
                                                key="row_editor"
                                            )
                                            
                                            if st.button(" Apply Changes", type="primary", key="apply_rows"):
                                                st.session_state.editable_budget_data = edited_df.copy()
                                                st.success(" Changes applied!")
                                                st.rerun()
                                        else:
                                            display_df = working_df.copy()
                                            display_df['Amount'] = display_df['Amount'].apply(lambda x: f"${x:,.2f}")
                                            st.dataframe(display_df, use_container_width=True, height=400)
                                    
                                    # Import options
                                    st.markdown("---")
                                    st.markdown("####  Import Options")
                                    
                                    # Use the edited data for import (excluding breakdown-only rows from totals)
                                    final_df = st.session_state.editable_budget_data.copy()
                                    
                                    # For import, we include all rows but breakdown-only have Amount=0
                                    # Calculate changes
                                    orig_total = converted_df['Amount'].sum()
                                    edit_total = final_df['Amount'].sum()
                                    diff = edit_total - orig_total
                                    orig_rows = len(converted_df)
                                    curr_rows = len(final_df)
                                    row_diff = curr_rows - orig_rows
                                    detail_count = len(final_df[final_df.get('_is_detail', False) == True]) if '_is_detail' in final_df.columns else 0
                                    
                                    # Metrics row with clickable button
                                    metric_col1, metric_col2, metric_col3, metric_col4, metric_col5 = st.columns([1, 1, 1, 1, 0.8])
                                    with metric_col1:
                                        st.metric("Original Total", f"${orig_total:,.0f}")
                                    with metric_col2:
                                        st.metric("Current Total", f"${edit_total:,.0f}", delta=f"${diff:,.0f}")
                                    with metric_col3:
                                        st.metric("Row Count", curr_rows, delta=row_diff)
                                    with metric_col4:
                                        st.metric("Detail Rows", detail_count)
                                    with metric_col5:
                                        st.markdown("<br>", unsafe_allow_html=True)
                                        if st.button(" View Changes", key="view_changes_btn", use_container_width=True):
                                            # Store all change data in session_state for dialog
                                            st.session_state.changes_data = {
                                                'orig_total': orig_total,
                                                'edit_total': edit_total,
                                                'diff': diff,
                                                'orig_rows': orig_rows,
                                                'curr_rows': curr_rows,
                                                'row_diff': row_diff,
                                                'final_df': final_df.copy(),
                                                'converted_df': converted_df.copy()
                                            }
                                            st.session_state.show_changes_dialog = True
                                            st.rerun()
                                    
                                    st.markdown("---")
                                    
                                    # =============================================
                                    # VERSION SAVING SECTION - WITH CORPORATE ROLLUP
                                    # =============================================
                                    st.markdown("###  Save Budget Version")
                                    
                                    # Get corporate and saved versions (unified system)
                                    unified_versions = st.session_state.get('unified_corporate_versions', {})
                                    corporate_versions = {k: v for k, v in unified_versions.items() 
                                                         if v.get('page_type') == 'Budget Planning'}
                                    saved_versions = st.session_state.get('saved_budget_versions', {})
                                    
                                    # Check for department context selector
                                    ti_dept_context = st.session_state.get('ti_dept_context', None)
                                    
                                    # Department identifier - prefer context, then project code
                                    ti_dept_default = ''
                                    if ti_dept_context:
                                        ti_dept_default = ti_dept_context
                                    elif project_code:
                                        ti_dept_default = project_code
                                    
                                    # Show context banner if set
                                    if ti_dept_context:
                                        st.success(f" Saving budget for: **{ti_dept_context}**")
                                    
                                    # Department identifier
                                    dept_col1, dept_col2 = st.columns([1, 2])
                                    with dept_col1:
                                        ti_dept_name = st.text_input("Department/Unit Name", 
                                                                     value=ti_dept_default,
                                                                     placeholder="e.g., D&D Operations, Engineering",
                                                                     key="ti_save_dept_name",
                                                                     help="Identifies this budget's source in corporate rollup")
                                    with dept_col2:
                                        st.info(f"**Budget Summary:** {len(final_df)} lines | ${edit_total:,.0f}")
                                    
                                    st.markdown("---")
                                    
                                    # CORPORATE ROLLUP SECTION
                                    st.markdown("####  Corporate Rollup")
                                    st.caption("Add or update this budget in a company-wide version")
                                    
                                    corp_col1, corp_col2 = st.columns([1, 1])
                                    
                                    with corp_col1:
                                        ti_add_corporate = st.checkbox(" Add to Corporate Version", value=bool(corporate_versions),
                                                                        disabled=not corporate_versions, key="ti_add_corporate")
                                    
                                    ti_corp_version_name = None
                                    ti_corp_desc = ""
                                    ti_corp_is_locked = False
                                    ti_existing_contrib = None
                                    
                                    if ti_add_corporate and corporate_versions:
                                        with corp_col2:
                                            # Show status in dropdown - no create new option
                                            corp_options_display = []
                                            corp_options_map = {}
                                            for cid, cinfo in corporate_versions.items():
                                                status = cinfo.get('status', 'Working')
                                                ver_name = cinfo.get('name', cid)
                                                status_icon = {'Working': '', 'Draft': '', 'In Review': '', 'Submitted': '', 'Locked': '', 'Approved': ''}.get(status, '')
                                                display = f"{status_icon} {ver_name} ({status})"
                                                corp_options_display.append(display)
                                                corp_options_map[display] = cid
                                            
                                            ti_selected_corp_display = st.selectbox("Select Corporate Version", corp_options_display, key="ti_corp_select")
                                            ti_selected_corp = corp_options_map.get(ti_selected_corp_display, None)
                                        
                                        if ti_selected_corp:
                                            ti_corp_version_name = ti_selected_corp
                                            if ti_corp_version_name in corporate_versions:
                                                corp_info = corporate_versions[ti_corp_version_name]
                                                corp_status = corp_info.get('status', 'Working')
                                                ti_corp_display_name = corp_info.get('name', ti_corp_version_name)
                                                ti_corp_is_locked = corp_status in ['Locked', 'Approved']
                                                contributors = corp_info.get('contributors', {})
                                                total_corp_budget = sum(c.get('total', 0) for c in contributors.values())
                                                
                                                # Check if this department already exists
                                                if ti_dept_name and ti_dept_name in contributors:
                                                    ti_existing_contrib = contributors[ti_dept_name]
                                                
                                                if ti_corp_is_locked:
                                                    st.error(f" **{ti_corp_display_name}** is **{corp_status}** - cannot add contributions")
                                                else:
                                                    st.success(f" **{ti_corp_display_name}** ({corp_status}) | {len(contributors)} contributors | ${total_corp_budget:,.0f} total")
                                                
                                                # Show existing contribution warning/info
                                                if ti_existing_contrib and not ti_corp_is_locked:
                                                    existing_total = ti_existing_contrib.get('total', 0)
                                                    existing_data = ti_existing_contrib.get('data', pd.DataFrame())
                                                    existing_lines = len(existing_data) if isinstance(existing_data, pd.DataFrame) else 0
                                                    existing_updated = ti_existing_contrib.get('saved_at', '')
                                                    
                                                    st.warning(f" **'{ti_dept_name}'** already exists in this version:\n"
                                                              f" Current: ${existing_total:,.0f} ({existing_lines} lines)\n"
                                                              f" Last updated: {existing_updated}\n\n"
                                                              f"**Saving will overwrite** the existing contribution.")
                                                
                                                if contributors:
                                                    with st.expander(f"Current Contributors ({len(contributors)})", expanded=False):
                                                        for contrib_name, contrib_info in contributors.items():
                                                            is_current = contrib_name == ti_dept_name
                                                            prefix = " " if is_current else " "
                                                            contrib_data = contrib_info.get('data', pd.DataFrame())
                                                            contrib_lines = len(contrib_data) if isinstance(contrib_data, pd.DataFrame) else 0
                                                            st.caption(f"{prefix}{contrib_name}: ${contrib_info.get('total', 0):,.0f} ({contrib_lines} lines)")
                                    elif not corporate_versions:
                                        with corp_col2:
                                            st.info("No corporate versions. Create one in Settings  Version Management.")
                                    
                                    st.markdown("---")
                                    
                                    # STANDALONE VERSION SECTION
                                    st.markdown("####  Standalone Version (Optional)")
                                    st.caption("Also save as a separate version for this department only")
                                    
                                    ti_save_standalone = st.checkbox(" Also save standalone version", value=False, key="ti_save_standalone")
                                    
                                    ti_standalone_name = None
                                    ti_standalone_desc = ""
                                    if ti_save_standalone:
                                        standalone_col1, standalone_col2 = st.columns(2)
                                        with standalone_col1:
                                            ti_standalone_name = st.text_input("Standalone Version Name", 
                                                                                value=f"{ti_dept_name}_{datetime.now().year}B" if ti_dept_name else f"{datetime.now().year}B",
                                                                                key="ti_standalone_name")
                                        with standalone_col2:
                                            ti_standalone_desc = st.text_input("Description", key="ti_standalone_desc")
                                    
                                    st.markdown("---")
                                    
                                    # SAVE BUTTONS
                                    save_btn_col1, save_btn_col2 = st.columns(2)
                                    
                                    with save_btn_col1:
                                        # Can't save to locked corporate version
                                        can_save_corp = ti_add_corporate and ti_corp_version_name and ti_dept_name and not ti_corp_is_locked
                                        can_save = can_save_corp or (ti_save_standalone and ti_standalone_name)
                                        
                                        if ti_corp_is_locked and ti_add_corporate:
                                            st.warning(" Cannot add to locked/approved version")
                                        
                                        # Show button text based on whether overwriting
                                        ti_save_btn_text = " Update Version" if ti_existing_contrib else " Save Version"
                                        
                                        if st.button(ti_save_btn_text, type="primary", use_container_width=True, disabled=not can_save, key="ti_save_version_btn"):
                                            # Initialize if needed
                                            if 'saved_budget_versions' not in st.session_state:
                                                st.session_state.saved_budget_versions = {}
                                            if 'unified_corporate_versions' not in st.session_state:
                                                st.session_state.unified_corporate_versions = {}
                                            
                                            # Prepare data - convert template data to CC format for compatibility
                                            save_cc_data = final_df.copy()
                                            
                                            # Get field mapping from template if available
                                            template = all_templates.get(selected_template, {})
                                            field_mapping = template.get('field_mapping', {})
                                            
                                            # Detect if data is in monthly format (has Month and Amount columns with multiple rows per category)
                                            is_monthly_format = 'Month' in save_cc_data.columns and 'Amount' in save_cc_data.columns
                                            
                                            if is_monthly_format:
                                                # Data is already in monthly format - pivot to Direct Entry format
                                                # Group by non-month columns and pivot months
                                                group_cols = [c for c in save_cc_data.columns if c not in ['Month', 'Month_Num', 'Amount', 'Year', '_row_id', '_parent_id', '_is_detail']]
                                                
                                                if group_cols:
                                                    # Pivot the data to get monthly columns
                                                    try:
                                                        pivoted = save_cc_data.pivot_table(
                                                            index=group_cols,
                                                            columns='Month',
                                                            values='Amount',
                                                            aggfunc='sum'
                                                        ).reset_index()
                                                        
                                                        # Reorder month columns
                                                        month_cols_present = [m for m in MONTHS if m in pivoted.columns]
                                                        other_cols = [c for c in pivoted.columns if c not in MONTHS]
                                                        pivoted = pivoted[other_cols + month_cols_present]
                                                        
                                                        # Add Budget_Annual
                                                        pivoted['Budget_Annual'] = pivoted[month_cols_present].sum(axis=1)
                                                        
                                                        save_cc_data = pivoted
                                                    except Exception as e:
                                                        st.warning(f"Could not pivot data: {e}. Saving in original format.")
                                            
                                            # Apply field mapping to create standard columns
                                            for std_field, source in field_mapping.items():
                                                if source is None:
                                                    continue
                                                elif source == 'row_label':
                                                    if 'Label' in save_cc_data.columns:
                                                        save_cc_data[std_field] = save_cc_data['Label']
                                                    elif 'Cost_Center' in save_cc_data.columns:
                                                        save_cc_data[std_field] = save_cc_data['Cost_Center']
                                                elif source == 'template_name':
                                                    save_cc_data[std_field] = ti_dept_name if ti_dept_name else selected_template
                                                elif isinstance(source, int):
                                                    pass  # Column index mapping not applicable here
                                            
                                            # Fallback column mapping
                                            if 'Budget_Annual' not in save_cc_data.columns:
                                                if 'Amount' in save_cc_data.columns:
                                                    save_cc_data['Budget_Annual'] = save_cc_data['Amount']
                                                elif 'Total' in save_cc_data.columns:
                                                    save_cc_data['Budget_Annual'] = save_cc_data['Total']
                                                else:
                                                    # Sum monthly columns if present
                                                    month_cols_present = [m for m in MONTHS if m in save_cc_data.columns]
                                                    if month_cols_present:
                                                        save_cc_data['Budget_Annual'] = save_cc_data[month_cols_present].sum(axis=1)
                                            
                                            if 'Department' not in save_cc_data.columns:
                                                if 'Cost_Center' in save_cc_data.columns:
                                                    save_cc_data['Department'] = save_cc_data['Cost_Center']
                                                else:
                                                    save_cc_data['Department'] = ti_dept_name
                                            
                                            if 'Account' not in save_cc_data.columns:
                                                if 'GL_Account' in save_cc_data.columns:
                                                    save_cc_data['Account'] = save_cc_data['GL_Account']
                                                elif 'Label' in save_cc_data.columns:
                                                    save_cc_data['Account'] = save_cc_data['Label']
                                                elif 'Cost_Center' in save_cc_data.columns:
                                                    save_cc_data['Account'] = save_cc_data['Cost_Center']
                                                else:
                                                    save_cc_data['Account'] = 'Expense'
                                            
                                            if 'Category' not in save_cc_data.columns:
                                                if 'Account_Category' in save_cc_data.columns:
                                                    save_cc_data['Category'] = save_cc_data['Account_Category']
                                                else:
                                                    save_cc_data['Category'] = 'Other'
                                            
                                            if 'Description' not in save_cc_data.columns:
                                                if 'Label' in save_cc_data.columns:
                                                    save_cc_data['Description'] = save_cc_data['Label']
                                                elif 'Cost_Center' in save_cc_data.columns:
                                                    save_cc_data['Description'] = save_cc_data['Cost_Center']
                                                elif 'Account_Name' in save_cc_data.columns:
                                                    save_cc_data['Description'] = save_cc_data['Account_Name']
                                                else:
                                                    save_cc_data['Description'] = ''
                                            
                                            # Ensure monthly columns exist if not already present
                                            if not any(m in save_cc_data.columns for m in MONTHS):
                                                if 'Budget_Annual' in save_cc_data.columns:
                                                    for month in MONTHS:
                                                        save_cc_data[month] = save_cc_data['Budget_Annual'] / 12
                                            
                                            save_data = {
                                                'cc_data': save_cc_data,
                                                'detail_data': pd.DataFrame(),
                                                'raw_data': final_df.copy(),
                                                'field_mapping': field_mapping,
                                            }
                                            
                                            messages = []
                                            
                                            # Save to corporate version (only if not locked and version exists)
                                            if can_save_corp and ti_corp_version_name in st.session_state.unified_corporate_versions:
                                                corp_id = ti_corp_version_name
                                                is_update = ti_dept_name in st.session_state.unified_corporate_versions[corp_id].get('contributors', {})
                                                
                                                # Use unified structure
                                                st.session_state.unified_corporate_versions[corp_id]['contributors'][ti_dept_name] = {
                                                    'data': save_cc_data.copy(),
                                                    'total': edit_total,
                                                    'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M'),
                                                    'saved_by': 'User',
                                                    'source': 'template_import',
                                                    'template_name': selected_template,
                                                    'raw_data': final_df.copy(),
                                                }
                                                
                                                contributors = st.session_state.unified_corporate_versions[corp_id]['contributors']
                                                st.session_state.unified_corporate_versions[corp_id]['total_amount'] = sum(c.get('total', 0) for c in contributors.values())
                                                
                                                ti_corp_display_name = st.session_state.unified_corporate_versions[corp_id].get('name', corp_id)
                                                action = "Updated" if is_update else "Added"
                                                messages.append(f"{action} '{ti_dept_name}' in '{ti_corp_display_name}' (${edit_total:,.0f})")
                                            
                                            # Save standalone version
                                            if ti_save_standalone and ti_standalone_name:
                                                version_id = ti_standalone_name.replace(" ", "_").upper()
                                                st.session_state.saved_budget_versions[version_id] = {
                                                    'name': ti_standalone_name,
                                                    'description': ti_standalone_desc,
                                                    'data': save_data,
                                                    'source': 'template_import',
                                                    'created': datetime.now(),
                                                    'fiscal_year': datetime.now().year,
                                                    'cc_count': len(final_df),
                                                    'detail_count': 0,
                                                    'total_budget': edit_total,
                                                    'department': ti_dept_name,
                                                    'template_name': selected_template,
                                                }
                                                messages.append(f"Saved standalone '{ti_standalone_name}'")
                                            
                                            st.success(" " + " | ".join(messages))
                                    
                                    with save_btn_col2:
                                        if not can_save:
                                            st.caption("Enter department name and select save option")
                                    
                                    # Show saved versions summary
                                    total_versions = len(saved_versions) + len(corporate_versions)
                                    if total_versions > 0:
                                        with st.expander(f" All Saved Versions ({total_versions})", expanded=False):
                                            if corporate_versions:
                                                st.markdown("** Corporate Versions**")
                                                for ver_name, ver_data in corporate_versions.items():
                                                    contributors = ver_data.get('contributors', {})
                                                    st.caption(f" {ver_name}: ${ver_data.get('total_budget', 0):,.0f} ({len(contributors)} depts)")
                                            if saved_versions:
                                                st.markdown("** Standalone Versions**")
                                                for ver_name, ver_data in saved_versions.items():
                                                    st.caption(f" {ver_name}: ${ver_data.get('total_budget', 0):,.0f}")
                                    
                                    st.markdown("---")
                                    st.markdown("** Import to Budget System**")
                                    imp_col1, imp_col2, imp_col3 = st.columns(3)
                                    
                                    with imp_col1:
                                        import_mode = st.radio("Mode", ["Append", "Replace"], key="adv_import_mode", horizontal=True)
                                    with imp_col2:
                                        fiscal_year = st.selectbox("Fiscal Year", [2025, 2026, 2024], key="adv_fy")
                                    with imp_col3:
                                        bu_override = st.text_input("Override Business Unit", value=project_code, key="bu_override")
                                    
                                    btn_col1, btn_col2 = st.columns(2)
                                    
                                    with btn_col1:
                                        if st.button(" Import to Budget", type="primary", use_container_width=True):
                                            final_df['Year'] = fiscal_year
                                            if bu_override:
                                                final_df['Business_Unit'] = bu_override
                                            
                                            if import_mode == "Replace":
                                                st.session_state.budget_data_enhanced = final_df
                                            else:
                                                if st.session_state.budget_data_enhanced.empty:
                                                    st.session_state.budget_data_enhanced = final_df
                                                else:
                                                    st.session_state.budget_data_enhanced = pd.concat([
                                                        st.session_state.budget_data_enhanced, final_df
                                                    ], ignore_index=True)
                                            
                                            st.success(f" Imported {len(final_df)} records!")
                                            st.balloons()
                                    
                                    with btn_col2:
                                        csv_data = final_df.to_csv(index=False)
                                        st.download_button(" Download CSV", data=csv_data, 
                                                          file_name=f"extracted_{datetime.now().strftime('%Y%m%d')}.csv",
                                                          mime="text/csv", use_container_width=True)
                                else:
                                    st.error("No data extracted. Check template row configuration.")
                            
                            else:
                                # Standard template processing (existing logic)
                                if uploaded_file.name.endswith('.csv'):
                                    raw_df = pd.read_csv(uploaded_file, header=template.get('header_row', 0))
                                else:
                                    raw_df = pd.read_excel(uploaded_file, header=template.get('header_row', 0))
                                
                                st.success(f" File loaded: {len(raw_df)} rows")
                                st.info("Standard template processing - see Administration  Templates for complex formats")
                        
                        except Exception as e:
                            st.error(f"Error processing file: {str(e)}")
                            import traceback
                            st.code(traceback.format_exc())
        
        elif import_method == " Simple Import":
            st.caption("Direct import from Excel or CSV files")
            
            # Reset Direct Entry dialog flags when switching away
            st.session_state.de_show_load_dialog = False
            st.session_state.de_show_save_dialog = False
            
            simple_file = st.file_uploader("Upload Excel or CSV File", type=['xlsx', 'xls', 'xlsb', 'csv'], key="simple_import")
            
            if simple_file:
                try:
                    if simple_file.name.endswith('.csv'):
                        preview_df = pd.read_csv(simple_file, nrows=10)
                        st.markdown("#### Preview")
                        st.dataframe(preview_df, use_container_width=True)
                        
                        if st.button("Import Data", type="primary", key="import_csv"):
                            simple_file.seek(0)
                            full_df = pd.read_csv(simple_file)
                            st.success(f"Imported {len(full_df)} rows successfully!")
                    else:
                        xl = pd.ExcelFile(simple_file)
                        sheet = st.selectbox("Select Sheet", xl.sheet_names)
                        
                        preview_df = pd.read_excel(simple_file, sheet_name=sheet, nrows=10)
                        st.markdown("#### Preview")
                        st.dataframe(preview_df, use_container_width=True)
                        
                        if st.button("Import Data", type="primary", key="import_excel"):
                            full_df = pd.read_excel(simple_file, sheet_name=sheet)
                            st.success(f"Imported {len(full_df)} rows successfully!")
                except Exception as e:
                    st.error(f"Error reading file: {e}")
        
        elif import_method == " Database":
            st.caption("Import from connected database")
            
            # Reset Direct Entry dialog flags when switching away
            st.session_state.de_show_load_dialog = False
            st.session_state.de_show_save_dialog = False
            
            st.info("Configure database connection in Administration  Settings")

    # =========================================================================

    # =========================================================================

    # =========================================================================
    # TAB 4: CALCULATION BUILDER (Excel-like)
    # =========================================================================
    with tab4:
        # Initialize state
        if 'calc_workbook' not in st.session_state:
            st.session_state.calc_workbook = pd.DataFrame()
        for key, default in [('calc_custom_columns', []), ('calc_column_formulas', {}), 
                             ('calc_cell_formulas', {}), ('calc_row_formulas', {}),
                             ('calc_formula', ''), ('calc_sel_row', 0), ('calc_sel_col', 'Jan'),
                             ('calc_edit_mode', None)]:
            if key not in st.session_state:
                st.session_state[key] = default
        
        month_cols = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
        
        def eval_formula(formula, row_data, all_data, row_idx):
            try:
                if not formula or not str(formula).startswith('='): return float(formula) if formula else 0
                import re
                expr = str(formula)[1:].strip()
                for pattern, func in [(r'SUM\((\w+):(\w+)\)', lambda v: sum(v)), (r'AVG\((\w+):(\w+)\)', lambda v: sum(v)/len(v) if v else 0),
                                      (r'MAX\((\w+):(\w+)\)', lambda v: max(v)), (r'MIN\((\w+):(\w+)\)', lambda v: min(v))]:
                    match = re.match(pattern, expr, re.IGNORECASE)
                    if match:
                        s, e = match.groups()
                        if s in month_cols and e in month_cols:
                            vals = [float(row_data.get(m, 0) or 0) for m in month_cols[month_cols.index(s):month_cols.index(e)+1]]
                            return func(vals)
                for match in re.finditer(r'Row(\d+)\.(\w+)', expr):
                    r, c = int(match.group(1))-1, match.group(2)
                    if 0 <= r < len(all_data) and c in all_data.columns:
                        expr = expr.replace(match.group(0), str(float(all_data.iloc[r][c] or 0)))
                for col in sorted(row_data.keys(), key=len, reverse=True):
                    if col in expr and col != 'Description':
                        expr = re.sub(rf'\b{col}\b', str(float(row_data.get(col, 0) or 0)), expr)
                return eval(expr, {"__builtins__": {}}, {})
            except: return 0
        
        # Helper to append to formula
        def add_to_formula(text):
            st.session_state.calc_formula = st.session_state.calc_formula + text
        
        def set_formula(text):
            st.session_state.calc_formula = text
        
        def clear_formula():
            st.session_state.calc_formula = ""
        
        def backspace_formula():
            st.session_state.calc_formula = st.session_state.calc_formula[:-1] if st.session_state.calc_formula else ""
        
        # ============ MAIN UI ============
        st.markdown("###  Calculation Builder")
        
        # Toolbar
        tb = st.columns(7)
        if tb[0].button(" Help", key="tb_help", use_container_width=True):
            st.session_state.calc_edit_mode = 'help' if st.session_state.calc_edit_mode != 'help' else None
        if tb[1].button(" Col", key="tb_addcol", use_container_width=True):
            st.session_state.calc_edit_mode = 'addcol' if st.session_state.calc_edit_mode != 'addcol' else None
        if tb[2].button(" Row", key="tb_addrow", use_container_width=True):
            if not st.session_state.calc_workbook.empty:
                new_row = {col: 0 if col != 'Description' else 'New Row' for col in st.session_state.calc_workbook.columns}
                st.session_state.calc_workbook = pd.concat([st.session_state.calc_workbook, pd.DataFrame([new_row])], ignore_index=True)
        if tb[3].button(" Load", key="tb_load", use_container_width=True):
            cc_data = st.session_state.get('direct_entry_cc_data', pd.DataFrame())
            if cc_data.empty: cc_data = st.session_state.get('direct_entry_data', pd.DataFrame())
            if not cc_data.empty:
                rows = []
                for i, row in cc_data.head(20).iterrows():
                    desc_parts = [str(row[c])[:15] for c in ['Description', 'Account', 'Department', 'Project', 'Category'] if c in row and pd.notna(row[c]) and str(row[c]).strip()]
                    row_data = {'Description': (' | '.join(desc_parts[:2]) if desc_parts else f'Line {i}')[:40]}
                    for m in month_cols: row_data[m] = float(row.get(m, 0)) if m in row and pd.notna(row.get(m, 0)) else 0
                    rows.append(row_data)
                if rows:
                    st.session_state.calc_workbook = pd.DataFrame(rows)
                    st.session_state.calc_custom_columns, st.session_state.calc_column_formulas = [], {}
                    st.session_state.calc_cell_formulas, st.session_state.calc_row_formulas = {}, {}
            else: st.toast("No data. Load in Import Data tab first.")
        if tb[4].button(" Reset", key="tb_reset", use_container_width=True):
            for k in ['calc_workbook', 'calc_custom_columns', 'calc_column_formulas', 'calc_cell_formulas', 'calc_row_formulas', 'calc_formula', 'calc_edit_mode']:
                if k in st.session_state: del st.session_state[k]
        if tb[5].button(" Budget", key="tb_apply", use_container_width=True, type="primary"):
            st.session_state.calc_edit_mode = 'apply' if st.session_state.calc_edit_mode != 'apply' else None
        if tb[6].button(" Sample", key="tb_sample", use_container_width=True):
            st.session_state.calc_workbook = pd.DataFrame({
                'Description': ['Salaries', 'Benefits', 'Contractors', 'Materials', 'Equipment', 'Travel', 'Software', 'Training', 'Overhead', 'Contingency'],
                'Jan': [50000, 15000, 20000, 10000, 5000, 2000, 3000, 1000, 8000, 5000],
                'Feb': [50000, 15000, 20000, 10000, 5000, 2000, 3000, 1000, 8000, 5000],
                'Mar': [50000, 15000, 20000, 10000, 5000, 2000, 3000, 1000, 8000, 5000],
                'Apr': [52000, 15600, 22000, 11000, 5000, 3000, 3000, 2000, 8500, 5000],
                'May': [52000, 15600, 22000, 11000, 5000, 3000, 3000, 2000, 8500, 5000],
                'Jun': [52000, 15600, 22000, 11000, 5000, 3000, 3000, 2000, 8500, 5000],
                'Jul': [54000, 16200, 25000, 12000, 6000, 2000, 3500, 1000, 9000, 6000],
                'Aug': [54000, 16200, 25000, 12000, 6000, 2000, 3500, 1000, 9000, 6000],
                'Sep': [54000, 16200, 25000, 12000, 6000, 2000, 3500, 1000, 9000, 6000],
                'Oct': [56000, 16800, 28000, 13000, 7000, 4000, 4000, 3000, 9500, 7000],
                'Nov': [56000, 16800, 28000, 13000, 7000, 4000, 4000, 3000, 9500, 7000],
                'Dec': [58000, 17400, 30000, 14000, 8000, 5000, 4500, 4000, 10000, 8000]
            })
            st.session_state.calc_custom_columns, st.session_state.calc_column_formulas = [], {}
            st.session_state.calc_cell_formulas, st.session_state.calc_row_formulas = {}, {}
        
        # ============ HELP PANEL ============
        if st.session_state.calc_edit_mode == 'help':
            with st.container(border=True):
                st.markdown("""
**Formula Reference** | `=Jan*1.05` multiply | `=SUM(Jan:Dec)` sum range | `=AVG(Jan:Dec)` average | `=MAX(Jan:Dec)` max | `=Row1.Jan` cell ref | `=Row1.Jan+Row2.Feb` add cells
                """)
        
        # ============ ADD COLUMN PANEL ============
        if st.session_state.calc_edit_mode == 'addcol':
            with st.container(border=True):
                c1, c2, c3 = st.columns([1,1,1])
                new_name = c1.text_input("Name", key="nc_name", placeholder="Annual")
                new_formula = c2.text_input("Formula", key="nc_formula", placeholder="=SUM(Jan:Dec)")
                if c3.button(" Create", type="primary"):
                    if new_name and not st.session_state.calc_workbook.empty and new_name not in st.session_state.calc_workbook.columns:
                        st.session_state.calc_custom_columns.append(new_name)
                        st.session_state.calc_workbook[new_name] = 0.0
                        if new_formula and new_formula.startswith('='):
                            st.session_state.calc_column_formulas[new_name] = new_formula
                            for idx in range(len(st.session_state.calc_workbook)):
                                st.session_state.calc_workbook.at[idx, new_name] = eval_formula(new_formula, st.session_state.calc_workbook.iloc[idx].to_dict(), st.session_state.calc_workbook, idx)
                        st.session_state.calc_edit_mode = None
        
        # ============ APPLY TO BUDGET PANEL ============
        if st.session_state.calc_edit_mode == 'apply' and not st.session_state.calc_workbook.empty:
            with st.container(border=True):
                c1, c2, c3, c4 = st.columns(4)
                dept = c1.selectbox("Dept", st.session_state.org_departments, key="ap_dept")
                cat = c2.selectbox("Cat", ['Labor', 'Materials', 'Subcontracts', 'Equipment', 'Travel', 'Other'], key="ap_cat")
                mode = c3.selectbox("Mode", ["Append", "Replace"], key="ap_mode")
                if c4.button(" Apply", type="primary"):
                    new_rows = []
                    for idx, row in st.session_state.calc_workbook.iterrows():
                        nr = {'Description': row['Description'], 'Category': cat, 'Department': dept, '_selected': False, 'PY_Annual': 0}
                        for m in month_cols: nr[m], nr[f'PY_{m}'] = float(row.get(m, 0)), 0
                        nr['Budget_Annual'] = sum(nr.get(m, 0) for m in month_cols)
                        new_rows.append(nr)
                    new_df = pd.DataFrame(new_rows)
                    if mode == "Append" and not st.session_state.direct_entry_data.empty:
                        st.session_state.direct_entry_data = pd.concat([st.session_state.direct_entry_data, new_df], ignore_index=True)
                    else:
                        st.session_state.direct_entry_data = new_df
                    st.session_state.calc_edit_mode = None
                    st.toast(f"Applied {len(new_rows)} rows!")
        
        # ============ ROW/COLUMN EDIT PANEL ============
        if st.session_state.calc_edit_mode in ['row', 'col'] and not st.session_state.calc_workbook.empty:
            with st.container(border=True):
                row_idx = st.session_state.calc_sel_row
                sel_col = st.session_state.calc_sel_col
                
                if st.session_state.calc_edit_mode == 'row':
                    row = st.session_state.calc_workbook.iloc[row_idx]
                    st.markdown(f"**Editing Row {row_idx+1}: {row['Description']}**")
                    sel_col = st.selectbox("Target Column", month_cols + st.session_state.calc_custom_columns, key="ed_col", index=month_cols.index(sel_col) if sel_col in month_cols else 0)
                    st.session_state.calc_sel_col = sel_col
                else:
                    st.markdown(f"**Editing Column: {sel_col}**")
                    row_idx = 0
                    row = st.session_state.calc_workbook.iloc[0]
                
                # FORMULA BAR - Display only (no text_input to avoid state conflicts)
                st.markdown("**Formula:**")
                formula_display = st.session_state.calc_formula if st.session_state.calc_formula else "(click = to start, then click cells)"
                st.code(formula_display, language=None)
                
                # Operator buttons - ROW 1
                op1 = st.columns(12)
                if op1[0].button("=", key="op_eq", use_container_width=True, on_click=set_formula, args=("=",)): pass
                if op1[1].button("+", key="op_plus", use_container_width=True, on_click=add_to_formula, args=("+",)): pass
                if op1[2].button("-", key="op_minus", use_container_width=True, on_click=add_to_formula, args=("-",)): pass
                if op1[3].button("", key="op_mult", use_container_width=True, on_click=add_to_formula, args=("*",)): pass
                if op1[4].button("", key="op_div", use_container_width=True, on_click=add_to_formula, args=("/",)): pass
                if op1[5].button("(", key="op_lp", use_container_width=True, on_click=add_to_formula, args=("(",)): pass
                if op1[6].button(")", key="op_rp", use_container_width=True, on_click=add_to_formula, args=(")",)): pass
                if op1[7].button("", key="op_back", use_container_width=True, on_click=backspace_formula): pass
                if op1[8].button("C", key="op_clr", use_container_width=True, on_click=clear_formula): pass
                if op1[9].button("1.05", key="op_105", use_container_width=True, on_click=add_to_formula, args=("*1.05",)): pass
                if op1[10].button("1.10", key="op_110", use_container_width=True, on_click=add_to_formula, args=("*1.10",)): pass
                if op1[11].button("1.03", key="op_103", use_container_width=True, on_click=add_to_formula, args=("*1.03",)): pass
                
                # Quick formulas - ROW 2
                qf = st.columns(6)
                if qf[0].button("SUM(Jan:Dec)", key="qf_sum", use_container_width=True, on_click=set_formula, args=("=SUM(Jan:Dec)",)): pass
                if qf[1].button("AVG(Jan:Dec)", key="qf_avg", use_container_width=True, on_click=set_formula, args=("=AVG(Jan:Dec)",)): pass
                if qf[2].button("MAX(Jan:Dec)", key="qf_max", use_container_width=True, on_click=set_formula, args=("=MAX(Jan:Dec)",)): pass
                if qf[3].button("SUM(Jan:Mar)", key="qf_q1", use_container_width=True, on_click=set_formula, args=("=SUM(Jan:Mar)",)): pass
                if qf[4].button("SUM(Jan:Jun)", key="qf_h1", use_container_width=True, on_click=set_formula, args=("=SUM(Jan:Jun)",)): pass
                if qf[5].button("Jan*1.05", key="qf_g5", use_container_width=True, on_click=set_formula, args=("=Jan*1.05",)): pass
                
                # Cell reference grid
                st.caption("**Click cells to add to formula:**")
                num_rows = min(5, len(st.session_state.calc_workbook))
                for ridx in range(num_rows):
                    r = st.session_state.calc_workbook.iloc[ridx]
                    rcols = st.columns([0.8] + [1]*12)
                    rcols[0].caption(f"R{ridx+1}")
                    for mi, m in enumerate(month_cols):
                        val = r[m] if m in r else 0
                        ref = f"Row{ridx+1}.{m}"
                        if rcols[mi+1].button(f"{int(val/1000)}k", key=f"cell_{ridx}_{m}", use_container_width=True, on_click=add_to_formula, args=(ref,)):
                            pass
                
                # Preview result
                if st.session_state.calc_formula and st.session_state.calc_formula.startswith('='):
                    try:
                        result = eval_formula(st.session_state.calc_formula, row.to_dict(), st.session_state.calc_workbook, row_idx)
                        st.success(f"**Result: ${result:,.0f}**")
                    except:
                        st.warning("Invalid formula")
                
                # Apply buttons
                st.markdown("---")
                ap = st.columns(5)
                if ap[0].button(" Apply Cell", type="primary", key="apply_cell"):
                    if st.session_state.calc_formula:
                        st.session_state.calc_cell_formulas[(row_idx, sel_col)] = st.session_state.calc_formula
                        st.session_state.calc_workbook.at[row_idx, sel_col] = eval_formula(st.session_state.calc_formula, row.to_dict(), st.session_state.calc_workbook, row_idx)
                        st.toast(f"Applied to R{row_idx+1}.{sel_col}")
                
                if ap[1].button(" Apply Col", key="apply_col"):
                    if st.session_state.calc_formula:
                        st.session_state.calc_column_formulas[sel_col] = st.session_state.calc_formula
                        for idx2 in range(len(st.session_state.calc_workbook)):
                            st.session_state.calc_workbook.at[idx2, sel_col] = eval_formula(st.session_state.calc_formula, st.session_state.calc_workbook.iloc[idx2].to_dict(), st.session_state.calc_workbook, idx2)
                        st.toast(f"Applied to all {sel_col}")
                
                if ap[2].button(" Apply Row", key="apply_row"):
                    if st.session_state.calc_formula:
                        st.session_state.calc_row_formulas[row_idx] = st.session_state.calc_formula
                        for m in month_cols:
                            st.session_state.calc_workbook.at[row_idx, m] = eval_formula(st.session_state.calc_formula, row.to_dict(), st.session_state.calc_workbook, row_idx)
                        st.toast(f"Applied to Row {row_idx+1}")
                
                if ap[3].button(" Clear", key="clear_form"):
                    ck = (row_idx, sel_col)
                    if ck in st.session_state.calc_cell_formulas: del st.session_state.calc_cell_formulas[ck]
                    if sel_col in st.session_state.calc_column_formulas: del st.session_state.calc_column_formulas[sel_col]
                    if row_idx in st.session_state.calc_row_formulas: del st.session_state.calc_row_formulas[row_idx]
                
                if ap[4].button(" Close", key="close_edit"):
                    st.session_state.calc_edit_mode = None
                    st.session_state.calc_formula = ""
        
        # ============ SPREADSHEET GRID ============
        if st.session_state.calc_workbook.empty:
            st.info(" Click ** Load** to load from Import Data tab, or ** Sample** for demo data")
        else:
            st.markdown("---")
            display_df = st.session_state.calc_workbook.copy()
            all_cols = month_cols + st.session_state.calc_custom_columns
            display_df['Annual'] = display_df[month_cols].sum(axis=1)
            
            # Header row
            hdr = st.columns([0.5, 2.2] + [0.85]*len(all_cols) + [1])
            hdr[0].markdown("**#**")
            hdr[1].markdown("**Description**")
            for i, col in enumerate(all_cols):
                has_formula = col in st.session_state.calc_column_formulas
                lbl = f"{col}" if has_formula else col
                if hdr[i+2].button(lbl, key=f"hdr_{col}", use_container_width=True):
                    st.session_state.calc_sel_col = col
                    st.session_state.calc_edit_mode = 'col'
                    st.session_state.calc_formula = st.session_state.calc_column_formulas.get(col, "")
            hdr[len(all_cols)+2].markdown("**Annual**")
            
            # Data rows
            for idx in range(len(display_df)):
                row = display_df.iloc[idx]
                has_formula = idx in st.session_state.calc_row_formulas or any((idx, c) in st.session_state.calc_cell_formulas for c in all_cols)
                
                cols = st.columns([0.5, 2.2] + [0.85]*len(all_cols) + [1])
                
                row_lbl = f"{idx+1}" if has_formula else str(idx+1)
                if cols[0].button(row_lbl, key=f"row_{idx}", use_container_width=True):
                    st.session_state.calc_sel_row = idx
                    st.session_state.calc_edit_mode = 'row'
                    st.session_state.calc_formula = ""
                
                cols[1].caption(row['Description'][:28])
                
                for i, col in enumerate(all_cols):
                    val = row[col] if col in row else 0
                    has_cell = (idx, col) in st.session_state.calc_cell_formulas
                    if has_cell:
                        cols[i+2].markdown(f"<span style='color:#0066cc;font-size:12px'>${val:,.0f}</span>", unsafe_allow_html=True)
                    else:
                        cols[i+2].caption(f"${val:,.0f}")
                
                cols[len(all_cols)+2].markdown(f"**${row['Annual']:,.0f}**")
            
            # Totals
            st.markdown("---")
            tot = st.columns([0.5, 2.2] + [0.85]*len(all_cols) + [1])
            tot[0].write("")
            tot[1].markdown("**TOTAL**")
            for i, col in enumerate(all_cols):
                tot[i+2].markdown(f"**${display_df[col].sum():,.0f}**")
            tot[len(all_cols)+2].markdown(f"**${display_df['Annual'].sum():,.0f}**")

# PAGE: PROJECT CONTROLS
# =============================================================================

elif page == " Project Controls":
    st.markdown("###  Project Controls & Management")
    st.caption("End-to-end project planning, forecasting, and performance tracking")
    
    # Tabs for Project Controls
    pc_tabs = st.tabs([" Portfolio Dashboard", " Forecasting", " Cost Management", " Revenue & Billing", 
                       " Schedule", " Resources", " Earned Value", " Risks", " Change Orders"])
    
    # =========================================================================
    # TAB 1: PORTFOLIO DASHBOARD
    # =========================================================================
    with pc_tabs[0]:
        st.markdown("####  Project Portfolio Overview")
        
        # Generate sample data button
        if st.button(" Generate Sample Project Data", type="primary", key="pc_gen_sample"):
            st.session_state.projects_data = _generate_sample_projects()
            st.session_state.project_costs = _generate_project_costs(st.session_state.projects_data)
            st.session_state.project_schedule = _generate_project_schedule(st.session_state.projects_data)
            st.session_state.project_resources = _generate_project_resources(st.session_state.projects_data)
            st.session_state.project_risks = _generate_project_risks(st.session_state.projects_data)
            st.toast(" Sample project data generated!")
            st.rerun()
        
        if not st.session_state.projects_data.empty:
            proj_df = st.session_state.projects_data
            
            # Portfolio KPIs
            st.markdown("---")
            kpi1, kpi2, kpi3, kpi4, kpi5, kpi6 = st.columns(6)
            
            with kpi1:
                st.metric("Active Projects", len(proj_df[proj_df['Status'] == 'Active']))
            with kpi2:
                total_contract = proj_df['Contract_Value'].sum()
                st.metric("Total Contract Value", f"${total_contract/1e6:.1f}M")
            with kpi3:
                total_funded = proj_df['Funded_Value'].sum()
                st.metric("Funded Value", f"${total_funded/1e6:.1f}M")
            with kpi4:
                avg_cpi = proj_df['CPI'].mean()
                st.metric("Avg CPI", f"{avg_cpi:.2f}", delta=f"{(avg_cpi-1)*100:.1f}%")
            with kpi5:
                avg_spi = proj_df['SPI'].mean()
                st.metric("Avg SPI", f"{avg_spi:.2f}", delta=f"{(avg_spi-1)*100:.1f}%")
            with kpi6:
                total_revenue = proj_df['Revenue_Recognized'].sum()
                st.metric("Revenue YTD", f"${total_revenue/1e6:.1f}M")
            
            st.markdown("---")
            
            # Project list with key metrics
            st.markdown("#### Project Performance Summary")
            
            display_cols = ['Project_ID', 'Project_Name', 'Customer', 'Contract_Type', 'PM', 
                           'Contract_Value', 'Pct_Complete', 'CPI', 'SPI', 'EAC', 'VAC']
            
            st.dataframe(
                proj_df[display_cols],
                column_config={
                    'Project_ID': st.column_config.TextColumn('ID', width='small'),
                    'Project_Name': st.column_config.TextColumn('Project', width='medium'),
                    'Contract_Value': st.column_config.NumberColumn('Contract $', format='$%.0f'),
                    'Pct_Complete': st.column_config.ProgressColumn('% Complete', min_value=0, max_value=100),
                    'CPI': st.column_config.NumberColumn('CPI', format='%.2f'),
                    'SPI': st.column_config.NumberColumn('SPI', format='%.2f'),
                    'EAC': st.column_config.NumberColumn('EAC', format='$%.0f'),
                    'VAC': st.column_config.NumberColumn('VAC', format='$%.0f'),
                },
                use_container_width=True,
                hide_index=True
            )
            
            # Charts
            st.markdown("---")
            chart_col1, chart_col2 = st.columns(2)
            
            with chart_col1:
                st.markdown("##### Contract Value by Customer")
                cust_summary = proj_df.groupby('Customer')['Contract_Value'].sum().reset_index()
                fig1 = go.Figure(go.Pie(labels=cust_summary['Customer'], values=cust_summary['Contract_Value'],
                                       hole=0.4, textinfo='label+percent'))
                fig1.update_layout(height=300, margin=dict(l=20, r=20, t=30, b=20))
                st.plotly_chart(fig1, use_container_width=True)
            
            with chart_col2:
                st.markdown("##### CPI vs SPI Performance")
                fig2 = go.Figure()
                fig2.add_trace(go.Scatter(
                    x=proj_df['CPI'], y=proj_df['SPI'],
                    mode='markers+text',
                    text=proj_df['Project_ID'],
                    textposition='top center',
                    marker=dict(size=12, color=proj_df['Contract_Value'], colorscale='Blues', showscale=True)
                ))
                fig2.add_hline(y=1.0, line_dash="dash", line_color="red")
                fig2.add_vline(x=1.0, line_dash="dash", line_color="red")
                fig2.update_layout(
                    height=300, margin=dict(l=20, r=20, t=30, b=20),
                    xaxis_title="CPI (Cost Performance)", yaxis_title="SPI (Schedule Performance)"
                )
                st.plotly_chart(fig2, use_container_width=True)
        else:
            st.info(" Click 'Generate Sample Project Data' to populate the project portfolio")
    
    # =========================================================================
    # TAB 2: PROJECT FORECASTING (Direct Entry & Templates)
    # =========================================================================
    with pc_tabs[1]:
        st.markdown("####  Project Forecasting")
        
        # Get project info and fee rate
        selected_forecast_proj = None
        fee_rate = 0.08  # Default fee rate
        
        # Project and period selector
        fc_col1, fc_col2, fc_col3, fc_col4 = st.columns([2, 1, 1, 1])
        
        with fc_col1:
            if not st.session_state.projects_data.empty:
                proj_options = st.session_state.projects_data['Project_ID'].tolist()
                selected_forecast_proj = st.selectbox(" Project", proj_options, key="pcf_proj_select")
            else:
                selected_forecast_proj = st.text_input("Project ID", placeholder="e.g., ZION-D&D-001", key="pcf_proj_input")
        
        with fc_col2:
            forecast_year = st.selectbox("Year", [2024, 2025, 2026, 2027, 2028], index=1, key="pcf_year")
        
        with fc_col3:
            # Get fee rate from project data
            if selected_forecast_proj and not st.session_state.projects_data.empty:
                proj_row = st.session_state.projects_data[
                    st.session_state.projects_data['Project_ID'] == selected_forecast_proj
                ]
                if not proj_row.empty:
                    fee_rate = proj_row.iloc[0].get('Fee_Rate', 0.08)
            
            fee_rate_input = st.number_input("Fee Rate %", value=fee_rate * 100, min_value=0.0, max_value=25.0, step=0.5, key="pcf_fee_rate")
            fee_rate = fee_rate_input / 100
        
        with fc_col4:
            forecast_status = st.selectbox("Status", ["Working", "Submitted", "Approved", "Locked"], key="pcf_status")
        
        # Project summary metrics
        if selected_forecast_proj and not st.session_state.projects_data.empty:
            proj_info = st.session_state.projects_data[
                st.session_state.projects_data['Project_ID'] == selected_forecast_proj
            ]
            if not proj_info.empty:
                proj_info = proj_info.iloc[0]
                pi1, pi2, pi3, pi4, pi5 = st.columns(5)
                with pi1:
                    st.metric("Contract Value", f"${proj_info.get('Contract_Value', 0):,.0f}")
                with pi2:
                    st.metric("BAC (Budget)", f"${proj_info.get('BAC', 0):,.0f}")
                with pi3:
                    st.metric("% Complete", f"{proj_info.get('Pct_Complete', 0):.1f}%")
                with pi4:
                    st.metric("ETC", f"${proj_info.get('ETC', 0):,.0f}")
                with pi5:
                    st.metric("Fee Rate", f"{fee_rate:.1%}")
        
        st.markdown("---")
        
        # Action buttons row
        btn_col1, btn_col2, btn_col3, btn_col4 = st.columns(4)
        
        with btn_col1:
            load_clicked = st.button(" Load Existing", use_container_width=True, key="pcf_load_btn")
        with btn_col2:
            new_clicked = st.button(" New Forecast", use_container_width=True, key="pcf_new")
        with btn_col3:
            is_locked = forecast_status == "Locked"
            submit_clicked = st.button(" Submit Forecast", use_container_width=True, key="pcf_submit", disabled=is_locked)
        with btn_col4:
            save_clicked = st.button(" Save Version", type="primary", use_container_width=True, key="pcf_save", disabled=is_locked)
        
        # Handle Load Existing
        if load_clicked:
            if not st.session_state.project_costs.empty and selected_forecast_proj:
                proj_costs = st.session_state.project_costs[
                    st.session_state.project_costs['Project_ID'] == selected_forecast_proj
                ].copy()
                
                if not proj_costs.empty:
                    pivot_df = proj_costs.pivot_table(
                        index='Cost_Category', columns='Month', values='Budget', aggfunc='sum'
                    ).reset_index()
                    pivot_df.columns.name = None
                    
                    for m in MONTHS:
                        if m not in pivot_df.columns:
                            pivot_df[m] = 0.0
                        else:
                            pivot_df[m] = pivot_df[m].astype(float)
                    
                    pivot_df = pivot_df[['Cost_Category'] + MONTHS]
                    st.session_state.project_forecast_data = pivot_df
                    st.toast(f" Loaded forecast for {selected_forecast_proj}")
                    st.rerun()
                else:
                    st.warning(f"No cost data found for {selected_forecast_proj}")
            else:
                st.warning("Go to the Portfolio Dashboard tab and click Load Sample Project Data")
        
        # Handle New Forecast
        if new_clicked:
            cost_categories = ['Labor', 'Materials', 'Subcontracts', 'Travel', 'Equipment', 'ODCs', 'Contingency']
            forecast_rows = []
            for cat in cost_categories:
                row = {'Cost_Category': cat}
                for m in MONTHS:
                    row[m] = 0.0
                forecast_rows.append(row)
            st.session_state.project_forecast_data = pd.DataFrame(forecast_rows)
            st.toast(" New forecast created")
            st.rerun()
        
        # Initialize if empty
        if st.session_state.project_forecast_data.empty:
            cost_categories = ['Labor', 'Materials', 'Subcontracts', 'Travel', 'Equipment', 'ODCs', 'Contingency']
            forecast_rows = []
            for cat in cost_categories:
                row = {'Cost_Category': cat}
                for m in MONTHS:
                    row[m] = 0.0
                forecast_rows.append(row)
            st.session_state.project_forecast_data = pd.DataFrame(forecast_rows)
        
        st.markdown("---")
        
        # ===========================================
        # COST FORECAST TABLE (Editable) with Live Revenue
        # ===========================================
        st.markdown("#####  Cost Forecast by Category")
        if is_locked:
            st.warning(" Forecast is locked - editing disabled")
        
        # Get current data
        forecast_df = st.session_state.project_forecast_data.copy()
        
        # Ensure numeric columns
        for m in MONTHS:
            if m in forecast_df.columns:
                forecast_df[m] = pd.to_numeric(forecast_df[m], errors='coerce').fillna(0.0)
        
        # Column config for editor
        col_config = {
            'Cost_Category': st.column_config.TextColumn('Category', disabled=True, width='medium'),
        }
        for m in MONTHS:
            col_config[m] = st.column_config.NumberColumn(m, format="%.0f", min_value=0, step=1000, width='small')
        
        edit_cols = ['Cost_Category'] + MONTHS
        for col in edit_cols:
            if col not in forecast_df.columns:
                forecast_df[col] = '' if col == 'Cost_Category' else 0.0
        
        # Store original for comparison
        original_df = forecast_df.copy()
        
        # Data editor
        if is_locked:
            st.dataframe(forecast_df[edit_cols], use_container_width=True, hide_index=True)
            edited_forecast = forecast_df.copy()
        else:
            edited_forecast = st.data_editor(
                forecast_df[edit_cols],
                column_config=col_config,
                use_container_width=True,
                hide_index=True,
                num_rows="fixed",
                key="pcf_editor"
            )
            
            # Convert to numeric
            for m in MONTHS:
                edited_forecast[m] = pd.to_numeric(edited_forecast[m], errors='coerce').fillna(0.0)
            
            # Check for changes (same pattern as Direct Entry)
            has_changes = False
            for m in MONTHS:
                if m in edited_forecast.columns and m in original_df.columns:
                    for i in range(len(edited_forecast)):
                        if edited_forecast.iloc[i][m] != original_df.iloc[i][m]:
                            has_changes = True
                            break
                if has_changes:
                    break
            
            # If changes detected, save and rerun immediately
            if has_changes:
                st.session_state.project_forecast_data = edited_forecast.copy()
                st.rerun()
        
        # Calculate totals from current data (use edited_forecast which has latest values)
        monthly_costs = {m: edited_forecast[m].sum() for m in MONTHS}
        total_cost = sum(monthly_costs.values())
        
        # Calculate revenue = cost * (1 + fee_rate)
        monthly_revenue = {m: monthly_costs[m] * (1 + fee_rate) for m in MONTHS}
        total_revenue = total_cost * (1 + fee_rate)
        total_fee = total_revenue - total_cost
        
        # ===========================================
        # AUTO-CALCULATED REVENUE (updates with edits)
        # ===========================================
        st.markdown("---")
        st.markdown("#####  Revenue Forecast *(Auto-calculated: Cost  (1 + Fee Rate))*")
        
        rev_data = {'Category': ['Total Cost', f'Fee ({fee_rate:.1%})', '**Revenue**']}
        for m in MONTHS:
            rev_data[m] = [monthly_costs[m], monthly_costs[m] * fee_rate, monthly_revenue[m]]
        rev_data['Annual'] = [total_cost, total_fee, total_revenue]
        
        rev_df = pd.DataFrame(rev_data)
        rev_col_config = {'Category': st.column_config.TextColumn('', width='medium')}
        for m in MONTHS:
            rev_col_config[m] = st.column_config.NumberColumn(m, format="$%.0f", width='small')
        rev_col_config['Annual'] = st.column_config.NumberColumn('Annual', format="$%.0f", width='medium')
        
        st.dataframe(rev_df, column_config=rev_col_config, use_container_width=True, hide_index=True)
        
        # ===========================================
        # SUMMARY METRICS
        # ===========================================
        st.markdown("---")
        m1, m2, m3, m4, m5, m6 = st.columns(6)
        
        with m1:
            st.metric(" Total Cost", f"${total_cost:,.0f}")
        with m2:
            st.metric(" Total Fee", f"${total_fee:,.0f}")
        with m3:
            st.metric(" Total Revenue", f"${total_revenue:,.0f}")
        with m4:
            q1_rev = sum(monthly_revenue[m] for m in ['Jan', 'Feb', 'Mar'])
            st.metric("Q1 Revenue", f"${q1_rev:,.0f}")
        with m5:
            q2_rev = sum(monthly_revenue[m] for m in ['Apr', 'May', 'Jun'])
            st.metric("Q2 Revenue", f"${q2_rev:,.0f}")
        with m6:
            h2_rev = sum(monthly_revenue[m] for m in ['Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])
            st.metric("H2 Revenue", f"${h2_rev:,.0f}")
        
        # ===========================================
        # VARIANCE TRACKING
        # ===========================================
        with st.expander(" Variance Analysis", expanded=False):
            var_col1, var_col2 = st.columns(2)
            
            with var_col1:
                st.markdown("**Prior Month Comparison**")
                # Simulated prior month data (in real app, load from saved version)
                prior_total = total_cost * 0.95  # Simulated
                variance = total_cost - prior_total
                var_pct = (variance / prior_total * 100) if prior_total > 0 else 0
                
                st.metric("Current EAC", f"${total_cost:,.0f}", delta=f"${variance:,.0f} ({var_pct:+.1f}%)")
            
            with var_col2:
                st.markdown("**Budget Baseline Comparison**")
                if selected_forecast_proj and not st.session_state.projects_data.empty:
                    proj_row = st.session_state.projects_data[
                        st.session_state.projects_data['Project_ID'] == selected_forecast_proj
                    ]
                    if not proj_row.empty:
                        bac = proj_row.iloc[0].get('BAC', 0)
                        eac_variance = total_cost - bac
                        eac_var_pct = (eac_variance / bac * 100) if bac > 0 else 0
                        st.metric("EAC vs BAC", f"${total_cost:,.0f}", delta=f"${eac_variance:,.0f} ({eac_var_pct:+.1f}%)")
                else:
                    st.info("Select a project to see baseline comparison")
        
        # ===========================================
        # MONTHLY TREND CHART
        # ===========================================
        with st.expander(" Monthly Trend Chart", expanded=False):
            fig = go.Figure()
            
            # Stacked cost bars
            for _, row in forecast_df.iterrows():
                fig.add_trace(go.Bar(
                    name=row['Cost_Category'],
                    x=MONTHS,
                    y=[row[m] for m in MONTHS]
                ))
            
            # Revenue line
            fig.add_trace(go.Scatter(
                name='Revenue',
                x=MONTHS,
                y=[monthly_revenue[m] for m in MONTHS],
                mode='lines+markers',
                line=dict(color='green', width=3),
                yaxis='y'
            ))
            
            fig.update_layout(
                barmode='stack',
                height=350,
                margin=dict(l=20, r=20, t=30, b=20),
                legend=dict(orientation='h', yanchor='bottom', y=1.02)
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # ===========================================
        # SAVE VERSION
        # ===========================================
        if save_clicked and not st.session_state.project_forecast_data.empty:
            version_name = f"{selected_forecast_proj}_{forecast_year}_{datetime.now().strftime('%m%d')}"
            st.session_state.project_forecast_versions[version_name] = {
                'data': st.session_state.project_forecast_data.copy(),
                'project_id': selected_forecast_proj,
                'year': forecast_year,
                'status': forecast_status,
                'fee_rate': fee_rate,
                'total_cost': total_cost,
                'total_revenue': total_revenue,
                'total': total_revenue,
                'created': datetime.now().strftime('%Y-%m-%d %H:%M'),
                'monthly_costs': monthly_costs,
                'monthly_revenue': monthly_revenue
            }
            st.toast(f" Saved: {version_name}")
            st.rerun()
        
        # ===========================================
        # VERSION MANAGEMENT (UNIFIED)
        # ===========================================
        st.markdown("---")
        st.markdown("#####  Version Management")
        
        # Initialize unified corporate versions if needed
        if 'unified_corporate_versions' not in st.session_state:
            st.session_state.unified_corporate_versions = {}
        
        # Get Project Controls corporate versions
        pc_corp_versions = {k: v for k, v in st.session_state.unified_corporate_versions.items() 
                          if v.get('page_type') == 'Project Controls'}
        standalone_versions = st.session_state.project_forecast_versions
        
        ver_tab1, ver_tab2 = st.tabs([" Load/View Versions", " Save to Corporate"])
        
        with ver_tab1:
            # Build combined options
            load_options = ['-- Select Version --']
            load_mapping = {}
            
            if pc_corp_versions:
                for k, v in pc_corp_versions.items():
                    status_icon = {'Working': '', 'Submitted': '', 'Approved': '', 'Locked': ''}.get(v.get('status', 'Working'), '')
                    display = f" {v['name']} ({status_icon} {v.get('status', 'Working')})"
                    load_options.append(display)
                    load_mapping[display] = ('corporate', k)
            
            if standalone_versions:
                for k, v in standalone_versions.items():
                    display = f" {k}"
                    load_options.append(display)
                    load_mapping[display] = ('standalone', k)
            
            if len(load_options) > 1:
                lv_col1, lv_col2 = st.columns([2, 1])
                
                with lv_col1:
                    selected_load = st.selectbox("Select Version", load_options, key="pc_load_version_select")
                
                if selected_load != '-- Select Version --':
                    source, ver_key = load_mapping[selected_load]
                    
                    with lv_col2:
                        if source == 'corporate':
                            ver_info = pc_corp_versions[ver_key]
                            st.caption(f"FY: {ver_info.get('fiscal_year', 'N/A')}")
                            st.caption(f"Contributors: {len(ver_info.get('contributors', {}))}")
                            st.caption(f"Total: ${ver_info.get('total_amount', 0):,.0f}")
                        else:
                            ver_info = standalone_versions[ver_key]
                            st.caption(f"Project: {ver_info.get('project_id', 'N/A')}")
                            st.caption(f"Revenue: ${ver_info.get('total_revenue', 0):,.0f}")
                    
                    btn_col1, btn_col2 = st.columns(2)
                    with btn_col1:
                        if st.button(" Load Version", key="pc_load_ver_btn", type="primary"):
                            if source == 'corporate':
                                # Load combined data from corporate version
                                corp_ver = st.session_state.unified_corporate_versions[ver_key]
                                contributors = corp_ver.get('contributors', {})
                                if contributors:
                                    all_dfs = [c['data'] for c in contributors.values() if 'data' in c and isinstance(c['data'], pd.DataFrame)]
                                    if all_dfs:
                                        combined_df = pd.concat(all_dfs, ignore_index=True)
                                        st.session_state.project_forecast_data = combined_df
                                        st.session_state.pc_current_version = f"Corporate: {corp_ver['name']}"
                                        st.toast(f" Loaded: {corp_ver['name']}")
                                    else:
                                        st.warning("No data in this version yet")
                                else:
                                    st.warning("No contributions yet")
                            else:
                                # Load standalone version
                                st.session_state.project_forecast_data = standalone_versions[ver_key]['data'].copy()
                                st.session_state.pc_current_version = ver_key
                                st.toast(f" Loaded: {ver_key}")
                            st.rerun()
                    
                    with btn_col2:
                        if source == 'corporate':
                            if st.button(" View Contributors", key="pc_view_contrib"):
                                st.session_state.pc_show_contrib = ver_key
                
                # Show contributors if viewing
                if st.session_state.get('pc_show_contrib'):
                    show_key = st.session_state.pc_show_contrib
                    if show_key in pc_corp_versions:
                        show_ver = pc_corp_versions[show_key]
                        contributors = show_ver.get('contributors', {})
                        
                        st.markdown(f"**Contributors for '{show_ver.get('name', '')}':**")
                        if contributors:
                            for contrib_name, contrib_info in contributors.items():
                                with st.expander(f" {contrib_name} - ${contrib_info.get('total', 0):,.0f}", expanded=False):
                                    st.caption(f"Saved: {contrib_info.get('saved_at', 'N/A')} by {contrib_info.get('saved_by', 'N/A')}")
                                    contrib_data = contrib_info.get('data', pd.DataFrame())
                                    if isinstance(contrib_data, pd.DataFrame) and not contrib_data.empty:
                                        st.dataframe(contrib_data, use_container_width=True, height=150)
                                        
                                        # Pull down button
                                        if show_ver.get('status') not in ['Locked', 'Approved']:
                                            if st.button(f" Pull Down to My Data", key=f"pc_pull_{show_key}_{contrib_name.replace(' ', '_')}"):
                                                st.session_state.project_forecast_data = contrib_data.copy()
                                                st.session_state.pc_current_version = f"Pulled from {show_ver['name']}: {contrib_name}"
                                                st.toast(f" Pulled data from {contrib_name}")
                                                st.rerun()
                                    else:
                                        st.caption("No detailed data")
                        else:
                            st.info("No contributions yet")
            else:
                st.info("No saved versions yet")
        
        with ver_tab2:
            # Save to corporate version
            available_corp = {k: v for k, v in st.session_state.unified_corporate_versions.items() 
                             if v.get('page_type') == 'Project Controls' and v.get('status') == 'Working'}
            
            if available_corp:
                corp_options = list(available_corp.keys())
                corp_display = [f"{available_corp[k]['name']} (FY{available_corp[k].get('fiscal_year', '')})" for k in corp_options]
                
                sc_col1, sc_col2 = st.columns(2)
                
                with sc_col1:
                    selected_corp_idx = st.selectbox("Select Corporate Version", range(len(corp_options)),
                                                    format_func=lambda i: corp_display[i], key="pc_corp_select")
                    selected_corp_key = corp_options[selected_corp_idx]
                
                with sc_col2:
                    contributor_name = st.text_input("Contributor Name", key="pc_contributor_name",
                                                    placeholder="e.g., Your Name or Project Team")
                
                if st.button(" Save to Corporate Version", key="pc_save_corp_btn", type="primary"):
                    if contributor_name.strip():
                        # Get current data
                        df = st.session_state.get('project_forecast_data', pd.DataFrame())
                        total_amount = total_revenue if 'total_revenue' in dir() else (df[MONTHS].sum().sum() if not df.empty and 'Jan' in df.columns else 0)
                        
                        # Add as contributor
                        st.session_state.unified_corporate_versions[selected_corp_key]['contributors'][contributor_name.strip()] = {
                            'data': df.copy() if not df.empty else pd.DataFrame(),
                            'total': total_amount,
                            'project_id': selected_forecast_proj if 'selected_forecast_proj' in dir() else '',
                            'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M'),
                            'saved_by': 'User'
                        }
                        
                        # Update total
                        new_total = sum(c.get('total', 0) for c in st.session_state.unified_corporate_versions[selected_corp_key]['contributors'].values())
                        st.session_state.unified_corporate_versions[selected_corp_key]['total_amount'] = new_total
                        
                        st.session_state.pc_current_version = f"Corporate: {available_corp[selected_corp_key]['name']} ({contributor_name.strip()})"
                        st.toast(f" Saved to: {available_corp[selected_corp_key]['name']}")
                        st.rerun()
                    else:
                        st.warning("Please enter your name or team")
            else:
                st.warning("No Working corporate versions available for Project Controls. Create one in Settings  Versions.")
        
        # Show current version indicator
        if st.session_state.get('pc_current_version'):
            st.success(f" Current: {st.session_state.pc_current_version}")
        
        # ===========================================
        # INTEGRATION BUTTONS
        # ===========================================
        st.markdown("---")
        st.markdown("#####  Integration")
        int_col1, int_col2, int_col3 = st.columns(3)
        
        with int_col1:
            if st.button(" Push to Budget Planning", use_container_width=True, key="pcf_push_budget"):
                if not st.session_state.project_forecast_data.empty:
                    st.toast(" Pushed to Budget Planning")
        
        with int_col2:
            if st.button(" Update P&L Forecast", use_container_width=True, key="pcf_update_pl"):
                st.toast(" P&L forecast updated")
        
        with int_col3:
            if st.button(" Sync to Cash Flow", use_container_width=True, key="pcf_sync_cash"):
                st.toast(" Cash flow synced")
    
    # =========================================================================
    # TAB 3: COST MANAGEMENT
    # =========================================================================
    with pc_tabs[2]:
        st.markdown("####  Project Cost Management")
        
        if not st.session_state.projects_data.empty and not st.session_state.project_costs.empty:
            proj_df = st.session_state.projects_data
            costs_df = st.session_state.project_costs
            
            # Project selector
            selected_project = st.selectbox("Select Project", proj_df['Project_ID'].tolist(), key="cost_proj_select")
            
            proj_info = proj_df[proj_df['Project_ID'] == selected_project].iloc[0]
            proj_costs = costs_df[costs_df['Project_ID'] == selected_project]
            
            # Project cost summary
            st.markdown("---")
            st.markdown(f"##### {proj_info['Project_Name']}")
            
            c1, c2, c3, c4, c5 = st.columns(5)
            with c1:
                st.metric("BAC", f"${proj_info['BAC']:,.0f}")
            with c2:
                st.metric("ACWP (Actual)", f"${proj_info['ACWP']:,.0f}")
            with c3:
                st.metric("EAC", f"${proj_info['EAC']:,.0f}")
            with c4:
                st.metric("ETC", f"${proj_info['ETC']:,.0f}")
            with c5:
                vac_color = "normal" if proj_info['VAC'] >= 0 else "inverse"
                st.metric("VAC", f"${proj_info['VAC']:,.0f}", delta=f"${proj_info['VAC']:,.0f}")
            
            st.markdown("---")
            
            # Cost by category
            st.markdown("##### Cost by Category")
            cat_summary = proj_costs.groupby('Cost_Category').agg({
                'Budget': 'sum', 'Actual': 'sum', 'Forecast': 'sum'
            }).reset_index()
            cat_summary['Variance'] = cat_summary['Budget'] - cat_summary['Actual']
            cat_summary['Var_%'] = cat_summary.apply(
                lambda r: round((r['Variance'] / r['Budget'] * 100), 1) if r['Budget'] != 0 else 0, axis=1
            )
            
            st.dataframe(
                cat_summary,
                column_config={
                    'Budget': st.column_config.NumberColumn(format='$%.0f'),
                    'Actual': st.column_config.NumberColumn(format='$%.0f'),
                    'Forecast': st.column_config.NumberColumn(format='$%.0f'),
                    'Variance': st.column_config.NumberColumn(format='$%.0f'),
                    'Var_%': st.column_config.NumberColumn('Var %', format='%.1f%%'),
                },
                use_container_width=True,
                hide_index=True
            )
            
            # Monthly cost trend
            st.markdown("##### Monthly Cost Trend")
            monthly_costs = proj_costs.groupby('Month').agg({'Budget': 'sum', 'Actual': 'sum', 'Forecast': 'sum'}).reset_index()
            monthly_costs['Month'] = pd.Categorical(monthly_costs['Month'], categories=MONTHS, ordered=True)
            monthly_costs = monthly_costs.sort_values('Month')
            
            fig = go.Figure()
            fig.add_trace(go.Bar(name='Budget', x=monthly_costs['Month'], y=monthly_costs['Budget'], marker_color='#A5A5A5'))
            fig.add_trace(go.Scatter(name='Actual', x=monthly_costs['Month'], y=monthly_costs['Actual'], 
                                    mode='lines+markers', line=dict(color='#4472C4', width=3)))
            fig.add_trace(go.Scatter(name='Forecast', x=monthly_costs['Month'], y=monthly_costs['Forecast'],
                                    mode='lines+markers', line=dict(color='#00B050', dash='dash')))
            fig.update_layout(height=350, margin=dict(l=20, r=20, t=30, b=20), barmode='overlay',
                             legend=dict(orientation='h', yanchor='bottom', y=1.02))
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Generate project data - go to the Portfolio tab and click Load Sample Data.")
    
    # =========================================================================
    # TAB 4: REVENUE & BILLING
    # =========================================================================
    with pc_tabs[3]:
        st.markdown("####  Revenue Planning & Billing")
        
        if not st.session_state.projects_data.empty:
            proj_df = st.session_state.projects_data
            
            # Revenue summary
            st.markdown("##### Revenue Summary by Project")
            
            rev_cols = ['Project_ID', 'Project_Name', 'Contract_Type', 'Contract_Value', 'Fee_Rate',
                       'Revenue_Recognized', 'Billed_Amount', 'Unbilled_Revenue']
            
            st.dataframe(
                proj_df[rev_cols],
                column_config={
                    'Contract_Value': st.column_config.NumberColumn('Contract $', format='$%.0f'),
                    'Fee_Rate': st.column_config.NumberColumn('Fee %', format='%.1f%%'),
                    'Revenue_Recognized': st.column_config.NumberColumn('Revenue', format='$%.0f'),
                    'Billed_Amount': st.column_config.NumberColumn('Billed', format='$%.0f'),
                    'Unbilled_Revenue': st.column_config.NumberColumn('Unbilled', format='$%.0f'),
                },
                use_container_width=True,
                hide_index=True
            )
            
            st.markdown("---")
            
            # Revenue KPIs
            rev1, rev2, rev3, rev4 = st.columns(4)
            total_rev = proj_df['Revenue_Recognized'].sum()
            total_billed = proj_df['Billed_Amount'].sum()
            total_unbilled = proj_df['Unbilled_Revenue'].sum()
            total_contract = proj_df['Contract_Value'].sum()
            
            with rev1:
                st.metric("Total Revenue YTD", f"${total_rev/1e6:.1f}M")
            with rev2:
                st.metric("Total Billed", f"${total_billed/1e6:.1f}M")
            with rev3:
                st.metric("Unbilled Revenue", f"${total_unbilled/1e6:.1f}M")
            with rev4:
                st.metric("Backlog", f"${(total_contract - total_rev)/1e6:.1f}M")
            
            # Revenue by contract type
            st.markdown("---")
            rcol1, rcol2 = st.columns(2)
            
            with rcol1:
                st.markdown("##### Revenue by Contract Type")
                ct_summary = proj_df.groupby('Contract_Type')['Revenue_Recognized'].sum().reset_index()
                fig = go.Figure(go.Pie(labels=ct_summary['Contract_Type'], values=ct_summary['Revenue_Recognized'],
                                      hole=0.4))
                fig.update_layout(height=300, margin=dict(l=20, r=20, t=30, b=20))
                st.plotly_chart(fig, use_container_width=True)
            
            with rcol2:
                st.markdown("##### Billing Status")
                billing_data = pd.DataFrame({
                    'Status': ['Billed', 'Unbilled'],
                    'Amount': [total_billed, total_unbilled]
                })
                fig2 = go.Figure(go.Bar(x=billing_data['Status'], y=billing_data['Amount'], 
                                       marker_color=['#4472C4', '#ED7D31']))
                fig2.update_layout(height=300, margin=dict(l=20, r=20, t=30, b=20))
                st.plotly_chart(fig2, use_container_width=True)
        else:
            st.info("Generate project data - go to the Portfolio tab and click Load Sample Data.")
    
    # =========================================================================
    # TAB 5: SCHEDULE
    # =========================================================================
    with pc_tabs[4]:
        st.markdown("####  Project Schedule & Milestones")
        
        if not st.session_state.projects_data.empty and not st.session_state.project_schedule.empty:
            proj_df = st.session_state.projects_data
            schedule_df = st.session_state.project_schedule
            
            # Project selector
            selected_project = st.selectbox("Select Project", proj_df['Project_ID'].tolist(), key="sched_proj_select")
            proj_schedule = schedule_df[schedule_df['Project_ID'] == selected_project]
            proj_info = proj_df[proj_df['Project_ID'] == selected_project].iloc[0]
            
            st.markdown("---")
            st.markdown(f"##### {proj_info['Project_Name']} - Timeline")
            
            # Project duration bar
            s1, s2, s3, s4 = st.columns(4)
            with s1:
                st.metric("Start Date", proj_info['Start_Date'].strftime('%Y-%m-%d'))
            with s2:
                st.metric("End Date", proj_info['End_Date'].strftime('%Y-%m-%d'))
            with s3:
                st.metric("% Complete", f"{proj_info['Pct_Complete']:.1f}%")
            with s4:
                st.metric("SPI", f"{proj_info['SPI']:.2f}")
            
            st.markdown("---")
            st.markdown("##### Milestone Status")
            
            # Milestone table
            ms_display = proj_schedule[['Milestone', 'Planned_Date', 'Actual_Date', 'Status', 'Variance_Days']].copy()
            ms_display['Planned_Date'] = ms_display['Planned_Date'].dt.strftime('%Y-%m-%d')
            ms_display['Actual_Date'] = ms_display['Actual_Date'].apply(lambda x: x.strftime('%Y-%m-%d') if pd.notna(x) else '-')
            
            st.dataframe(
                ms_display,
                column_config={
                    'Variance_Days': st.column_config.NumberColumn('Variance (Days)', format='%d'),
                },
                use_container_width=True,
                hide_index=True
            )
            
            # Gantt-style visualization
            st.markdown("##### Project Timeline")
            
            fig = go.Figure()
            
            for idx, row in proj_schedule.iterrows():
                color = {'Completed': '#00B050', 'In Progress': '#FFC000', 'Not Started': '#C0C0C0'}[row['Status']]
                fig.add_trace(go.Bar(
                    x=[row['Pct_Timeline']],
                    y=[row['Milestone']],
                    orientation='h',
                    marker_color=color,
                    name=row['Status'],
                    showlegend=idx == 0
                ))
            
            fig.update_layout(
                height=350,
                margin=dict(l=20, r=20, t=30, b=20),
                xaxis_title="% of Project Timeline",
                barmode='stack'
            )
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Generate project data - go to the Portfolio tab and click Load Sample Data.")
    
    # =========================================================================
    # TAB 6: RESOURCES
    # =========================================================================
    with pc_tabs[5]:
        st.markdown("####  Resource Planning & Utilization")
        
        if not st.session_state.projects_data.empty and not st.session_state.project_resources.empty:
            proj_df = st.session_state.projects_data
            resources_df = st.session_state.project_resources
            
            # Project selector
            selected_project = st.selectbox("Select Project", proj_df['Project_ID'].tolist(), key="res_proj_select")
            proj_resources = resources_df[resources_df['Project_ID'] == selected_project]
            
            st.markdown("---")
            
            # Resource summary by role
            st.markdown("##### Resource Summary by Role")
            role_summary = proj_resources.groupby('Role').agg({
                'Planned_FTE': 'mean',
                'Planned_Hours': 'sum',
                'Actual_Hours': 'sum',
                'Planned_Cost': 'sum',
                'Actual_Cost': 'sum'
            }).reset_index()
            role_summary['Utilization'] = (role_summary['Actual_Hours'] / role_summary['Planned_Hours'] * 100).round(1)
            role_summary['Cost_Variance'] = role_summary['Planned_Cost'] - role_summary['Actual_Cost']
            
            st.dataframe(
                role_summary,
                column_config={
                    'Planned_FTE': st.column_config.NumberColumn('Avg FTE', format='%.1f'),
                    'Planned_Hours': st.column_config.NumberColumn('Plan Hrs', format='%.0f'),
                    'Actual_Hours': st.column_config.NumberColumn('Actual Hrs', format='%.0f'),
                    'Utilization': st.column_config.ProgressColumn('Utilization %', min_value=0, max_value=150),
                    'Planned_Cost': st.column_config.NumberColumn('Plan $', format='$%.0f'),
                    'Actual_Cost': st.column_config.NumberColumn('Actual $', format='$%.0f'),
                    'Cost_Variance': st.column_config.NumberColumn('Variance', format='$%.0f'),
                },
                use_container_width=True,
                hide_index=True
            )
            
            st.markdown("---")
            
            # Monthly resource trend
            st.markdown("##### Monthly Labor Hours")
            monthly_res = proj_resources.groupby('Month').agg({'Planned_Hours': 'sum', 'Actual_Hours': 'sum'}).reset_index()
            monthly_res['Month'] = pd.Categorical(monthly_res['Month'], categories=MONTHS, ordered=True)
            monthly_res = monthly_res.sort_values('Month')
            
            fig = go.Figure()
            fig.add_trace(go.Bar(name='Planned Hours', x=monthly_res['Month'], y=monthly_res['Planned_Hours'], marker_color='#A5A5A5'))
            fig.add_trace(go.Scatter(name='Actual Hours', x=monthly_res['Month'], y=monthly_res['Actual_Hours'],
                                    mode='lines+markers', line=dict(color='#4472C4', width=3)))
            fig.update_layout(height=350, margin=dict(l=20, r=20, t=30, b=20), barmode='overlay')
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Generate project data - go to the Portfolio tab and click Load Sample Data.")
    
    # =========================================================================
    # TAB 7: EARNED VALUE MANAGEMENT
    # =========================================================================
    with pc_tabs[6]:
        st.markdown("####  Earned Value Management (EVM)")
        
        if not st.session_state.projects_data.empty:
            proj_df = st.session_state.projects_data
            
            # Project selector
            selected_project = st.selectbox("Select Project", proj_df['Project_ID'].tolist(), key="evm_proj_select")
            proj_info = proj_df[proj_df['Project_ID'] == selected_project].iloc[0]
            
            st.markdown("---")
            st.markdown(f"##### {proj_info['Project_Name']} - EVM Analysis")
            
            # EVM metrics
            ev1, ev2, ev3, ev4 = st.columns(4)
            with ev1:
                st.metric("BAC (Budget at Completion)", f"${proj_info['BAC']:,.0f}")
            with ev2:
                st.metric("EAC (Estimate at Completion)", f"${proj_info['EAC']:,.0f}")
            with ev3:
                st.metric("VAC (Variance at Completion)", f"${proj_info['VAC']:,.0f}")
            with ev4:
                tcpi = (proj_info['BAC'] - proj_info['BCWP']) / (proj_info['BAC'] - proj_info['ACWP']) if (proj_info['BAC'] - proj_info['ACWP']) != 0 else 1
                st.metric("TCPI", f"{tcpi:.2f}")
            
            st.markdown("---")
            
            ev5, ev6, ev7, ev8 = st.columns(4)
            with ev5:
                st.metric("BCWS (Planned Value)", f"${proj_info['BCWS']:,.0f}")
            with ev6:
                st.metric("BCWP (Earned Value)", f"${proj_info['BCWP']:,.0f}")
            with ev7:
                st.metric("ACWP (Actual Cost)", f"${proj_info['ACWP']:,.0f}")
            with ev8:
                st.metric("ETC (Estimate to Complete)", f"${proj_info['ETC']:,.0f}")
            
            st.markdown("---")
            
            # Performance indices
            pi1, pi2, pi3, pi4 = st.columns(4)
            with pi1:
                cpi_color = "normal" if proj_info['CPI'] >= 1 else "inverse"
                st.metric("CPI (Cost Performance)", f"{proj_info['CPI']:.2f}", 
                         delta=f"{(proj_info['CPI']-1)*100:.1f}%", delta_color=cpi_color)
            with pi2:
                spi_color = "normal" if proj_info['SPI'] >= 1 else "inverse"
                st.metric("SPI (Schedule Performance)", f"{proj_info['SPI']:.2f}",
                         delta=f"{(proj_info['SPI']-1)*100:.1f}%", delta_color=spi_color)
            with pi3:
                cv_color = "normal" if proj_info['CV'] >= 0 else "inverse"
                st.metric("CV (Cost Variance)", f"${proj_info['CV']:,.0f}",
                         delta=f"${proj_info['CV']:,.0f}", delta_color=cv_color)
            with pi4:
                sv_color = "normal" if proj_info['SV'] >= 0 else "inverse"
                st.metric("SV (Schedule Variance)", f"${proj_info['SV']:,.0f}",
                         delta=f"${proj_info['SV']:,.0f}", delta_color=sv_color)
            
            st.markdown("---")
            
            # EVM S-Curve visualization
            st.markdown("##### EVM S-Curve")
            
            # Generate S-curve data points
            pct_points = np.linspace(0, proj_info['Pct_Complete'], 12)
            bcws_curve = [proj_info['BAC'] * (p/100) * 1.02 for p in pct_points]
            bcwp_curve = [proj_info['BAC'] * (p/100) for p in pct_points]
            acwp_curve = [proj_info['BAC'] * (p/100) * (1/proj_info['CPI']) for p in pct_points]
            
            fig = go.Figure()
            fig.add_trace(go.Scatter(x=list(pct_points), y=bcws_curve, name='BCWS (Planned)', 
                                    mode='lines', line=dict(color='#A5A5A5', dash='dash')))
            fig.add_trace(go.Scatter(x=list(pct_points), y=bcwp_curve, name='BCWP (Earned)',
                                    mode='lines', line=dict(color='#00B050', width=3)))
            fig.add_trace(go.Scatter(x=list(pct_points), y=acwp_curve, name='ACWP (Actual)',
                                    mode='lines', line=dict(color='#C00000', width=3)))
            fig.update_layout(
                height=400,
                margin=dict(l=20, r=20, t=30, b=20),
                xaxis_title="% Complete",
                yaxis_title="Cumulative Cost ($)",
                legend=dict(orientation='h', yanchor='bottom', y=1.02)
            )
            st.plotly_chart(fig, use_container_width=True)
            
            # EVM interpretation
            st.markdown("---")
            st.markdown("##### Performance Analysis")
            
            if proj_info['CPI'] >= 1 and proj_info['SPI'] >= 1:
                st.success(" **Project is under budget and ahead of schedule.** Continue current execution approach.")
            elif proj_info['CPI'] >= 1 and proj_info['SPI'] < 1:
                st.warning(" **Project is under budget but behind schedule.** Focus on schedule recovery without increasing costs.")
            elif proj_info['CPI'] < 1 and proj_info['SPI'] >= 1:
                st.warning(" **Project is over budget but on schedule.** Implement cost controls while maintaining schedule.")
            else:
                st.error(" **Project is over budget and behind schedule.** Immediate corrective action required.")
        else:
            st.info("Generate project data - go to the Portfolio tab and click Load Sample Data.")
    
    # =========================================================================
    # TAB 8: RISKS
    # =========================================================================
    with pc_tabs[7]:
        st.markdown("####  Risk Management")
        
        if not st.session_state.projects_data.empty and not st.session_state.project_risks.empty:
            proj_df = st.session_state.projects_data
            risks_df = st.session_state.project_risks
            
            # Risk summary
            st.markdown("##### Risk Summary")
            
            r1, r2, r3, r4 = st.columns(4)
            with r1:
                st.metric("Total Risks", len(risks_df))
            with r2:
                st.metric("Open Risks", len(risks_df[risks_df['Status'] == 'Open']))
            with r3:
                st.metric("High Impact", len(risks_df[risks_df['Impact'] == 'High']))
            with r4:
                total_exposure = risks_df[risks_df['Status'] == 'Open']['Cost_Impact'].sum()
                st.metric("Risk Exposure", f"${total_exposure:,.0f}")
            
            st.markdown("---")
            
            # Risk register
            st.markdown("##### Risk Register")
            
            # Project filter
            project_filter = st.selectbox("Filter by Project", ['All'] + proj_df['Project_ID'].tolist(), key="risk_filter")
            
            if project_filter != 'All':
                display_risks = risks_df[risks_df['Project_ID'] == project_filter]
            else:
                display_risks = risks_df
            
            st.dataframe(
                display_risks[['Risk_ID', 'Project_ID', 'Risk_Description', 'Risk_Type', 'Probability', 
                              'Impact', 'Cost_Impact', 'Status', 'Owner']],
                column_config={
                    'Cost_Impact': st.column_config.NumberColumn('Cost Impact', format='$%.0f'),
                },
                use_container_width=True,
                hide_index=True
            )
            
            # Risk matrix
            st.markdown("---")
            st.markdown("##### Risk Heat Map")
            
            # Create risk matrix
            prob_map = {'Low': 1, 'Medium': 2, 'High': 3}
            impact_map = {'Low': 1, 'Medium': 2, 'High': 3}
            
            matrix_data = np.zeros((3, 3))
            for _, risk in display_risks[display_risks['Status'] == 'Open'].iterrows():
                p_idx = prob_map[risk['Probability']] - 1
                i_idx = impact_map[risk['Impact']] - 1
                matrix_data[p_idx, i_idx] += 1
            
            fig = go.Figure(go.Heatmap(
                z=matrix_data,
                x=['Low Impact', 'Medium Impact', 'High Impact'],
                y=['Low Prob', 'Medium Prob', 'High Prob'],
                colorscale=[[0, '#00B050'], [0.5, '#FFC000'], [1, '#C00000']],
                text=matrix_data.astype(int),
                texttemplate='%{text}',
                showscale=False
            ))
            fig.update_layout(height=300, margin=dict(l=20, r=20, t=30, b=20))
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Generate project data - go to the Portfolio tab and click Load Sample Data.")
    
    # =========================================================================
    # TAB 9: CHANGE ORDERS
    # =========================================================================
    with pc_tabs[8]:
        st.markdown("####  Change Order Management")
        
        if not st.session_state.projects_data.empty:
            proj_df = st.session_state.projects_data
            
            # Generate sample change orders if not exists
            if 'project_changes' not in st.session_state or st.session_state.project_changes.empty:
                change_rows = []
                for _, proj in proj_df.iterrows():
                    num_changes = np.random.randint(2, 6)
                    for i in range(num_changes):
                        change_rows.append({
                            'Change_ID': f"CO-{proj['Project_ID'][:4]}-{i+1:03d}",
                            'Project_ID': proj['Project_ID'],
                            'Project_Name': proj['Project_Name'],
                            'Description': f"Scope change {i+1} - {np.random.choice(['Additional work', 'Design modification', 'Schedule acceleration', 'Scope reduction'])}",
                            'Type': np.random.choice(['Scope', 'Schedule', 'Cost', 'All']),
                            'Cost_Impact': np.random.randint(-50000, 200000),
                            'Schedule_Impact': np.random.randint(-10, 30),
                            'Status': np.random.choice(['Draft', 'Submitted', 'Approved', 'Rejected'], p=[0.2, 0.3, 0.4, 0.1]),
                            'Submitted_Date': (datetime.now() - pd.Timedelta(days=np.random.randint(10, 90))).strftime('%Y-%m-%d'),
                            'Approved_Date': (datetime.now() - pd.Timedelta(days=np.random.randint(1, 30))).strftime('%Y-%m-%d') if np.random.random() > 0.4 else None
                        })
                st.session_state.project_changes = pd.DataFrame(change_rows)
            
            changes_df = st.session_state.project_changes
            
            # Change order summary
            st.markdown("##### Change Order Summary")
            
            co1, co2, co3, co4 = st.columns(4)
            with co1:
                st.metric("Total Changes", len(changes_df))
            with co2:
                st.metric("Approved", len(changes_df[changes_df['Status'] == 'Approved']))
            with co3:
                st.metric("Pending", len(changes_df[changes_df['Status'].isin(['Draft', 'Submitted'])]))
            with co4:
                approved_impact = changes_df[changes_df['Status'] == 'Approved']['Cost_Impact'].sum()
                st.metric("Approved Value", f"${approved_impact:,.0f}")
            
            st.markdown("---")
            
            # Change order table
            st.markdown("##### Change Order Register")
            
            project_filter = st.selectbox("Filter by Project", ['All'] + proj_df['Project_ID'].tolist(), key="co_filter")
            
            if project_filter != 'All':
                display_changes = changes_df[changes_df['Project_ID'] == project_filter]
            else:
                display_changes = changes_df
            
            st.dataframe(
                display_changes[['Change_ID', 'Project_ID', 'Description', 'Type', 'Cost_Impact', 
                               'Schedule_Impact', 'Status', 'Submitted_Date']],
                column_config={
                    'Cost_Impact': st.column_config.NumberColumn('Cost $', format='$%.0f'),
                    'Schedule_Impact': st.column_config.NumberColumn('Days', format='%d'),
                },
                use_container_width=True,
                hide_index=True
            )
            
            # Impact analysis
            st.markdown("---")
            st.markdown("##### Change Impact by Project")
            
            impact_by_proj = changes_df[changes_df['Status'] == 'Approved'].groupby('Project_ID').agg({
                'Cost_Impact': 'sum',
                'Schedule_Impact': 'sum',
                'Change_ID': 'count'
            }).reset_index()
            impact_by_proj.columns = ['Project_ID', 'Total Cost Impact', 'Total Schedule Days', 'Change Count']
            
            st.dataframe(
                impact_by_proj,
                column_config={
                    'Total Cost Impact': st.column_config.NumberColumn(format='$%.0f'),
                    'Total Schedule Days': st.column_config.NumberColumn(format='%d days'),
                },
                use_container_width=True,
                hide_index=True
            )
        else:
            st.info("Generate project data - go to the Portfolio tab and click Load Sample Data.")


# =============================================================================
# PAGE: PURCHASING
# =============================================================================

elif page == " Purchasing":
    st.markdown("###  Purchasing Management")
    st.caption("End-to-end Purchase Request, Purchase Order, and vendor management integrated with Oracle EBS")
    
    # Initialize purchasing session state
    if 'purchase_orders' not in st.session_state:
        st.session_state.purchase_orders = pd.DataFrame()
    if 'pr_detail_modal_idx' not in st.session_state:
        st.session_state.pr_detail_modal_idx = None
    if 'pr_budget_data' not in st.session_state:
        st.session_state.pr_budget_data = pd.DataFrame()
    
    # Tabs for purchasing management
    purch_tabs = st.tabs([" Purchase Requests", " Purchase Orders", " Vendors", " Analytics"])
    
    # =========================================================================
    # TAB 1: PURCHASE REQUESTS
    # =========================================================================
    with purch_tabs[0]:
        st.markdown("####  Purchase Request Management")
        st.caption("Budget lines marked 'Needs PR' from Corporate Budget Versions (Detail Level)")
        
        # Function to load budget data from corporate versions
        def load_pr_budget_data():
            all_budget_lines = []
            unified_versions = st.session_state.get('unified_corporate_versions', {})
            
            for ver_id, ver_info in unified_versions.items():
                if ver_info.get('page_type') != 'Budget Planning':
                    continue
                
                ver_name = ver_info.get('name', ver_id)
                ver_status = ver_info.get('status', 'Working')
                contributors = ver_info.get('contributors', {})
                
                for contrib_name, contrib_info in contributors.items():
                    # PRIORITY: detail_data first (has Needs_PR and full detail fields)
                    detail_data = contrib_info.get('detail_data', None)
                    main_data = contrib_info.get('data', None)
                    
                    # Determine which data source to use
                    contrib_data = None
                    if isinstance(detail_data, pd.DataFrame) and not detail_data.empty:
                        contrib_data = detail_data.copy()
                    elif isinstance(main_data, pd.DataFrame) and not main_data.empty:
                        contrib_data = main_data.copy()
                    
                    if contrib_data is None or contrib_data.empty:
                        continue
                    
                    # Add tracking columns
                    contrib_data['Corporate_Version'] = ver_name
                    contrib_data['Contributor'] = contrib_name
                    contrib_data['Version_Status'] = ver_status
                    contrib_data['Version_ID'] = ver_id
                    
                    # Filter: Only include lines where Needs_PR is True
                    # If Needs_PR column doesn't exist, include ALL lines (backward compat)
                    if 'Needs_PR' in contrib_data.columns:
                        contrib_data = contrib_data[contrib_data['Needs_PR'] == True].copy()
                    
                    if not contrib_data.empty:
                        all_budget_lines.append(contrib_data)
            
            if not all_budget_lines:
                return pd.DataFrame()
            
            budget_data = pd.concat(all_budget_lines, ignore_index=True)
            
            # Determine amount column - sum monthly if Budget_Annual not present
            if 'Budget_Annual' not in budget_data.columns:
                month_cols = [m for m in MONTHS if m in budget_data.columns]
                if month_cols:
                    budget_data['Budget_Annual'] = budget_data[month_cols].sum(axis=1)
                elif 'Amount' in budget_data.columns:
                    budget_data['Budget_Annual'] = budget_data['Amount']
                elif 'Budget' in budget_data.columns:
                    budget_data['Budget_Annual'] = budget_data['Budget']
                else:
                    budget_data['Budget_Annual'] = 0
            
            # Add required columns
            if 'Expense_Type' not in budget_data.columns:
                def classify_expense(row):
                    acct = str(row.get('Account', row.get('Account_Category', ''))).upper()
                    cat = str(row.get('Category', '')).upper()
                    if any(x in acct or x in cat for x in ['CAPEX', 'CAPITAL', 'ASSET', 'EQUIP', 'FIXED']):
                        return 'CAPEX'
                    return 'OPEX'
                budget_data['Expense_Type'] = budget_data.apply(classify_expense, axis=1)
            
            if 'Approval_Status' not in budget_data.columns:
                budget_data['Approval_Status'] = budget_data['Version_Status'].apply(
                    lambda x: 'Approved' if x in ['Approved', 'Locked'] else 'Pending'
                )
            
            for col, default in [('PR_Number', ''), ('PR_Type', 'Standard'), ('Urgency', 'Normal'), ('PO_Number', ''), ('_selected', False)]:
                if col not in budget_data.columns:
                    budget_data[col] = default
            
            return budget_data
        
        # Refresh button
        refresh_col1, refresh_col2 = st.columns([1, 4])
        with refresh_col1:
            if st.button(" Refresh from Budgets", key="pr_refresh_data"):
                st.session_state.pr_budget_data = load_pr_budget_data()
                st.session_state.pr_data_loaded = True
                st.toast(" Refreshed budget data")
        with refresh_col2:
            st.caption("Pull latest detail-level budget lines marked 'Needs PR'")
        
        # Load data on first visit only
        if 'pr_data_loaded' not in st.session_state:
            st.session_state.pr_budget_data = load_pr_budget_data()
            st.session_state.pr_data_loaded = True
        
        # Use the stored data
        budget_data = st.session_state.get('pr_budget_data', pd.DataFrame())
        
        if isinstance(budget_data, pd.DataFrame) and not budget_data.empty:
            
            # Summary metrics - all on one line
            total = len(budget_data)
            approved = len(budget_data[budget_data['Approval_Status'] == 'Approved']) if 'Approval_Status' in budget_data.columns else 0
            pending = len(budget_data[budget_data['Approval_Status'] == 'Pending']) if 'Approval_Status' in budget_data.columns else 0
            rejected = len(budget_data[budget_data['Approval_Status'] == 'Rejected']) if 'Approval_Status' in budget_data.columns else 0
            prs_generated = len(budget_data[budget_data['PR_Number'] != '']) if 'PR_Number' in budget_data.columns else 0
            pos_created = len(budget_data[budget_data['PO_Number'] != '']) if 'PO_Number' in budget_data.columns else 0
            opex_total = budget_data[budget_data['Expense_Type'] == 'OPEX']['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns and 'Expense_Type' in budget_data.columns else 0
            capex_total = budget_data[budget_data['Expense_Type'] == 'CAPEX']['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns and 'Expense_Type' in budget_data.columns else 0
            num_contributors = budget_data['Contributor'].nunique() if 'Contributor' in budget_data.columns else 0
            num_versions = budget_data['Corporate_Version'].nunique() if 'Corporate_Version' in budget_data.columns else 0
            
            m1, m2, m3, m4, m5, m6, m7, m8 = st.columns(8)
            with m1:
                st.metric("Lines", total)
            with m2:
                st.metric("Contributors", num_contributors)
            with m3:
                st.metric(" Approved", approved)
            with m4:
                st.metric(" Pending", pending)
            with m5:
                st.metric(" PRs", prs_generated)
            with m6:
                st.metric(" POs", pos_created)
            with m7:
                st.metric("OPEX", f"${opex_total/1000:.0f}K" if opex_total >= 1000 else f"${opex_total:.0f}")
            with m8:
                st.metric("CAPEX", f"${capex_total/1000:.0f}K" if capex_total >= 1000 else f"${capex_total:.0f}")
            
            # Filters - collapsible
            with st.expander(" Filters", expanded=False):
                f1, f2, f3, f4, f5, f6 = st.columns(6)
                with f1:
                    status_filter = st.selectbox("Approval Status", ["All", "Pending", "Approved", "Rejected"], key="pr_status_flt")
                with f2:
                    type_filter = st.selectbox("Expense Type", ["All", "OPEX", "CAPEX"], key="pr_type_flt")
                with f3:
                    pr_filter = st.selectbox("PR Status", ["All", "No PR", "PR Generated"], key="pr_pr_flt")
                with f4:
                    # Corporate Version filter
                    if 'Corporate_Version' in budget_data.columns:
                        corp_vers = ['All'] + sorted(budget_data['Corporate_Version'].dropna().unique().tolist())
                        corp_filter = st.selectbox("Corporate Version", corp_vers, key="pr_corp_flt")
                    else:
                        corp_filter = "All"
                with f5:
                    # Contributor filter
                    if 'Contributor' in budget_data.columns:
                        contributors = ['All'] + sorted(budget_data['Contributor'].dropna().unique().tolist())
                        contrib_filter = st.selectbox("Contributor", contributors, key="pr_contrib_flt")
                    else:
                        contrib_filter = "All"
                with f6:
                    if 'Business_Unit' in budget_data.columns:
                        bus = ['All'] + sorted(budget_data['Business_Unit'].dropna().unique().tolist())
                        bu_filter = st.selectbox("Business Unit", bus, key="pr_bu_flt")
                    elif 'Department' in budget_data.columns:
                        depts = ['All'] + sorted(budget_data['Department'].dropna().unique().tolist())
                        bu_filter = st.selectbox("Department", depts, key="pr_dept_flt")
                    else:
                        bu_filter = "All"
            
            # Get filter values from session state (for when expander is collapsed)
            status_filter = st.session_state.get('pr_status_flt', 'All')
            type_filter = st.session_state.get('pr_type_flt', 'All')
            pr_filter = st.session_state.get('pr_pr_flt', 'All')
            corp_filter = st.session_state.get('pr_corp_flt', 'All')
            contrib_filter = st.session_state.get('pr_contrib_flt', 'All')
            bu_filter = st.session_state.get('pr_bu_flt', st.session_state.get('pr_dept_flt', 'All'))
            
            # Apply filters
            filtered_data = budget_data.copy()
            if status_filter != "All":
                filtered_data = filtered_data[filtered_data['Approval_Status'] == status_filter]
            if type_filter != "All":
                filtered_data = filtered_data[filtered_data['Expense_Type'] == type_filter]
            if pr_filter == "No PR":
                filtered_data = filtered_data[filtered_data['PR_Number'] == '']
            elif pr_filter == "PR Generated":
                filtered_data = filtered_data[filtered_data['PR_Number'] != '']
            if corp_filter != "All" and 'Corporate_Version' in filtered_data.columns:
                filtered_data = filtered_data[filtered_data['Corporate_Version'] == corp_filter]
            if contrib_filter != "All" and 'Contributor' in filtered_data.columns:
                filtered_data = filtered_data[filtered_data['Contributor'] == contrib_filter]
            if bu_filter != "All":
                if 'Business_Unit' in filtered_data.columns:
                    filtered_data = filtered_data[filtered_data['Business_Unit'] == bu_filter]
                elif 'Department' in filtered_data.columns:
                    filtered_data = filtered_data[filtered_data['Department'] == bu_filter]
            
            # Get indices for filtered data
            filtered_indices = filtered_data.index.tolist()
            
            # Get current selection from budget_data (stored state)
            selected_indices = []
            if '_selected' in budget_data.columns:
                for idx in filtered_indices:
                    if budget_data.at[idx, '_selected']:
                        selected_indices.append(idx)
            sel_count = len(selected_indices)
            
            # Count approved lines ready for PR
            approved_no_pr = budget_data[(budget_data['Approval_Status'] == 'Approved') & (budget_data['PR_Number'] == '')]
            approved_count_for_pr = len(approved_no_pr)
            approved_value_for_pr = approved_no_pr['Budget_Annual'].sum() if 'Budget_Annual' in approved_no_pr.columns and approved_count_for_pr > 0 else 0
            
            # =====================================================
            # ACTIONS SECTION - ABOVE TABLE
            # =====================================================
            st.markdown(f"#####  Actions" + (f" ({sel_count} selected)" if sel_count > 0 else ""))
            
            if sel_count > 0:
                # When rows are selected: Selected actions
                act1, act2, act3, act4, act5 = st.columns(5)
                
                with act1:
                    if st.button(f" Approve ({sel_count})", key="pr_approve_sel", type="secondary"):
                        for idx in selected_indices:
                            budget_data.at[idx, 'Approval_Status'] = 'Approved'
                            budget_data.at[idx, '_selected'] = False
                        st.session_state.pr_budget_data = budget_data.copy()
                        st.toast(f" Approved {sel_count} lines")
                        st.rerun()
                
                with act2:
                    if st.button(f" Reject ({sel_count})", key="pr_reject_sel"):
                        for idx in selected_indices:
                            budget_data.at[idx, 'Approval_Status'] = 'Rejected'
                            budget_data.at[idx, '_selected'] = False
                        st.session_state.pr_budget_data = budget_data.copy()
                        st.toast(f" Rejected {sel_count} lines")
                        st.rerun()
                
                with act3:
                    # Generate PRs for selected approved lines only
                    selected_approved = [idx for idx in selected_indices 
                                        if budget_data.at[idx, 'Approval_Status'] == 'Approved' 
                                        and budget_data.at[idx, 'PR_Number'] == '']
                    sel_approved_count = len(selected_approved)
                    btn_label = f" Generate PRs ({sel_approved_count})" if sel_approved_count > 0 else " Generate PRs"
                    if st.button(btn_label, type="primary", key="pr_generate_sel", disabled=sel_approved_count==0):
                        count = 0
                        for idx in selected_approved:
                            pr_type = budget_data.at[idx, 'PR_Type']
                            type_prefix = {'Standard': 'PR', 'Blanket': 'BPR', 'Planned': 'PPR'}.get(pr_type, 'PR')
                            pr_num = f"{type_prefix}-{datetime.now().strftime('%Y%m%d')}-{idx:04d}"
                            budget_data.at[idx, 'PR_Number'] = pr_num
                            budget_data.at[idx, '_selected'] = False
                            count += 1
                        st.session_state.pr_budget_data = budget_data.copy()
                        st.toast(f" Generated {count} PRs")
                        st.balloons()
                        st.rerun()
                
                with act4:
                    if sel_count == 1:
                        if st.button(" View Detail", key="pr_view_detail"):
                            st.session_state.pr_detail_modal_idx = selected_indices[0]
                            st.rerun()
                    else:
                        sel_value = sum(budget_data.at[idx, 'Budget_Annual'] for idx in selected_indices if 'Budget_Annual' in budget_data.columns)
                        st.caption(f" ${sel_value:,.0f} selected")
                
                with act5:
                    if st.button(" Clear Selection", key="pr_clear_sel"):
                        for idx in filtered_indices:
                            budget_data.at[idx, '_selected'] = False
                        st.session_state.pr_budget_data = budget_data.copy()
                        st.rerun()
            else:
                # When no rows selected: All actions
                act1, act2, act3, act4 = st.columns(4)
                
                pending_count = len(filtered_data[filtered_data['Approval_Status'] == 'Pending']) if 'Approval_Status' in filtered_data.columns else 0
                
                with act1:
                    if st.button(f" Approve All Pending ({pending_count})", key="pr_approve_all", disabled=pending_count==0):
                        count = 0
                        for idx in filtered_indices:
                            if budget_data.at[idx, 'Approval_Status'] == 'Pending':
                                budget_data.at[idx, 'Approval_Status'] = 'Approved'
                                count += 1
                        st.session_state.pr_budget_data = budget_data.copy()
                        st.toast(f" Approved {count} lines")
                        st.rerun()
                
                with act2:
                    if st.button(f" Reject All Pending ({pending_count})", key="pr_reject_all", disabled=pending_count==0):
                        count = 0
                        for idx in filtered_indices:
                            if budget_data.at[idx, 'Approval_Status'] == 'Pending':
                                budget_data.at[idx, 'Approval_Status'] = 'Rejected'
                                count += 1
                        st.session_state.pr_budget_data = budget_data.copy()
                        st.toast(f" Rejected {count} lines")
                        st.rerun()
                
                with act3:
                    btn_label = f" Generate All PRs ({approved_count_for_pr})" if approved_count_for_pr > 0 else " Generate PRs"
                    if st.button(btn_label, type="primary", key="pr_generate_all", disabled=approved_count_for_pr==0):
                        count = 0
                        for idx in approved_no_pr.index:
                            pr_type = budget_data.at[idx, 'PR_Type']
                            type_prefix = {'Standard': 'PR', 'Blanket': 'BPR', 'Planned': 'PPR'}.get(pr_type, 'PR')
                            pr_num = f"{type_prefix}-{datetime.now().strftime('%Y%m%d')}-{idx:04d}"
                            budget_data.at[idx, 'PR_Number'] = pr_num
                            count += 1
                        st.session_state.pr_budget_data = budget_data.copy()
                        st.toast(f" Generated {count} PRs")
                        st.balloons()
                        st.rerun()
                
                with act4:
                    if st.button(" Reset All", key="pr_reset_all"):
                        for idx in filtered_indices:
                            budget_data.at[idx, 'Approval_Status'] = 'Pending'
                            budget_data.at[idx, 'PR_Number'] = ''
                            budget_data.at[idx, 'PO_Number'] = ''
                            budget_data.at[idx, '_selected'] = False
                        st.session_state.pr_budget_data = budget_data.copy()
                        st.toast(" All statuses reset")
                        st.rerun()
            
            st.markdown("---")
            
            # =====================================================
            # TABLE SECTION
            # =====================================================
            st.markdown(f"#####  Budget Lines ({len(filtered_data)} shown)")
            
            # Store working data BEFORE editor (the "original" state)
            working_df = filtered_data.copy()
            
            # Ensure _selected column exists
            if '_selected' not in working_df.columns:
                working_df['_selected'] = False
            
            # Prepare display columns
            disp_cols = ['_selected', 'Corporate_Version', 'Contributor', 'Expense_Type']
            if 'Budget_Annual' in working_df.columns:
                disp_cols.append('Budget_Annual')
            disp_cols.extend(['Approval_Status', 'PR_Type', 'Urgency', 'PR_Number', 'PO_Number'])
            for c in ['Business_Unit', 'Department', 'Account', 'Account_Name', 'Account_Category', 'Category', 
                      'Description', 'Project', 'Task', 'Vendor', 'Customer', 'PO']:
                if c in working_df.columns and c not in disp_cols:
                    disp_cols.append(c)
            disp_cols = [c for c in disp_cols if c in working_df.columns]
            
            # Column config
            col_config = {
                '_selected': st.column_config.CheckboxColumn('Select', default=False, width='small'),
                'Corporate_Version': st.column_config.TextColumn('Corp. Version', width='medium'),
                'Contributor': st.column_config.TextColumn('Budgeted By', width='medium'),
                'Expense_Type': st.column_config.SelectboxColumn('Type', options=['OPEX', 'CAPEX'], width='small'),
                'Budget_Annual': st.column_config.NumberColumn('Amount', format='$%.0f', width='medium'),
                'Approval_Status': st.column_config.SelectboxColumn('Approval', options=['Pending', 'Approved', 'Rejected'], width='small'),
                'PR_Type': st.column_config.SelectboxColumn('PR Type', options=['Standard', 'Blanket', 'Planned'], width='small'),
                'Urgency': st.column_config.SelectboxColumn('Urgency', options=['Normal', 'Urgent', 'Emergency'], width='small'),
                'PR_Number': st.column_config.TextColumn('PR #', width='medium'),
                'PO_Number': st.column_config.TextColumn('PO #', width='medium'),
                'Business_Unit': st.column_config.TextColumn('BU', width='small'),
                'Department': st.column_config.TextColumn('Dept', width='medium'),
                'Account': st.column_config.TextColumn('Acct', width='small'),
                'Account_Name': st.column_config.TextColumn('Acct Name', width='medium'),
                'Account_Category': st.column_config.TextColumn('Acct Cat', width='medium'),
                'Category': st.column_config.TextColumn('Category', width='small'),
                'Description': st.column_config.TextColumn('Description', width='large'),
                'Project': st.column_config.TextColumn('Project', width='medium'),
                'Task': st.column_config.TextColumn('Task', width='small'),
                'Vendor': st.column_config.TextColumn('Vendor', width='medium'),
                'Customer': st.column_config.TextColumn('Customer', width='small'),
                'PO': st.column_config.TextColumn('Existing PO', width='small'),
            }
            
            # Data editor
            edited_df = st.data_editor(
                working_df[disp_cols],
                column_config=col_config,
                use_container_width=True,
                hide_index=True,
                height=400,
                key="pr_lines_editor"
            )
            
            # =====================================================
            # CHANGE DETECTION - Direct Entry Pattern
            # =====================================================
            has_changes = False
            selection_changed = False
            
            if len(edited_df) == len(filtered_indices):
                for i in range(len(edited_df)):
                    orig_idx = filtered_indices[i]
                    
                    # Check selection change
                    if '_selected' in edited_df.columns:
                        old_sel = bool(budget_data.at[orig_idx, '_selected']) if '_selected' in budget_data.columns else False
                        new_sel = bool(edited_df.iloc[i]['_selected'])
                        if old_sel != new_sel:
                            selection_changed = True
                            budget_data.at[orig_idx, '_selected'] = new_sel
                    
                    # Check editable columns
                    for col in ['PR_Type', 'Urgency', 'Expense_Type', 'Approval_Status']:
                        if col in edited_df.columns and col in budget_data.columns:
                            old_val = str(budget_data.at[orig_idx, col]) if pd.notna(budget_data.at[orig_idx, col]) else ''
                            new_val = str(edited_df.iloc[i][col]) if pd.notna(edited_df.iloc[i][col]) else ''
                            if old_val != new_val:
                                has_changes = True
                                budget_data.at[orig_idx, col] = edited_df.iloc[i][col]
            
            # Save and rerun ONLY if actual changes detected
            if has_changes or selection_changed:
                st.session_state.pr_budget_data = budget_data.copy()
                st.rerun()
            
            # Line Detail Modal
            if st.session_state.pr_detail_modal_idx is not None:
                detail_idx = st.session_state.pr_detail_modal_idx
                if detail_idx in budget_data.index:
                    detail_row = budget_data.loc[detail_idx]
                    
                    @st.dialog(" Line Detail")
                    def show_line_detail():
                        d1, d2 = st.columns(2)
                        with d1:
                            st.markdown("**General Information**")
                            st.write(f"**Department:** {detail_row.get('Department', 'N/A')}")
                            st.write(f"**Category:** {detail_row.get('Category', 'N/A')}")
                            st.write(f"**Description:** {detail_row.get('Description', 'N/A')}")
                            st.write(f"**Vendor:** {detail_row.get('Vendor', 'N/A')}")
                            st.write(f"**Account:** {detail_row.get('Account', 'N/A')}")
                        with d2:
                            st.markdown("**Financial & Status**")
                            st.write(f"**Expense Type:** {detail_row.get('Expense_Type', 'N/A')}")
                            st.write(f"**Amount:** ${detail_row.get('Budget_Annual', 0):,.0f}")
                            st.write(f"**Approval:** {detail_row.get('Approval_Status', 'N/A')}")
                            st.write(f"**PR Type:** {detail_row.get('PR_Type', 'N/A')}")
                            st.write(f"**Urgency:** {detail_row.get('Urgency', 'N/A')}")
                            st.write(f"**PR Number:** {detail_row.get('PR_Number', 'None') or 'None'}")
                            st.write(f"**PO Number:** {detail_row.get('PO_Number', 'None') or 'None'}")
                        
                        if st.button("Close", key="pr_detail_close"):
                            st.session_state.pr_detail_modal_idx = None
                            st.rerun()
                    
                    show_line_detail()
        else:
            st.info(" No budget lines marked 'Needs PR' found. To see budget lines here:\n\n1. Go to **Budget Planning  Direct Entry** (Detail Level)\n2. Check the **'Needs PR'** checkbox on lines that need purchase requests\n3. Save your budget to a **Corporate Version**\n4. Click ** Refresh from Budgets** above")
            
            # Debug info for troubleshooting
            with st.expander(" Debug: Corporate Version Data", expanded=False):
                unified_versions = st.session_state.get('unified_corporate_versions', {})
                bp_versions = {k: v for k, v in unified_versions.items() if v.get('page_type') == 'Budget Planning'}
                
                if not bp_versions:
                    st.warning("No Budget Planning corporate versions found")
                else:
                    for ver_id, ver_info in bp_versions.items():
                        st.markdown(f"**{ver_info.get('name', ver_id)}** (Status: {ver_info.get('status', 'Unknown')})")
                        contributors = ver_info.get('contributors', {})
                        if not contributors:
                            st.caption("  - No contributors")
                        else:
                            for contrib_name, contrib_info in contributors.items():
                                detail_data = contrib_info.get('detail_data', None)
                                main_data = contrib_info.get('data', None)
                                
                                detail_info = "None"
                                if isinstance(detail_data, pd.DataFrame) and not detail_data.empty:
                                    has_needs_pr = 'Needs_PR' in detail_data.columns
                                    needs_pr_count = detail_data['Needs_PR'].sum() if has_needs_pr else 0
                                    detail_info = f"{len(detail_data)} rows, Needs_PR col: {has_needs_pr}, Checked: {needs_pr_count}"
                                
                                main_info = "None"
                                if isinstance(main_data, pd.DataFrame) and not main_data.empty:
                                    has_needs_pr = 'Needs_PR' in main_data.columns
                                    main_info = f"{len(main_data)} rows, Needs_PR col: {has_needs_pr}"
                                
                                st.caption(f"  - {contrib_name}: detail_data={detail_info}, data={main_info}")
    
    # =========================================================================
    # TAB 2: PURCHASE ORDERS
    # =========================================================================
    with purch_tabs[1]:
        st.markdown("####  Purchase Order Management")
        
        # Get budget data for PO creation
        budget_data = st.session_state.get('pr_budget_data', pd.DataFrame())
        
        # PRs ready for PO
        if not budget_data.empty and 'PR_Number' in budget_data.columns:
            prs_for_po = budget_data[(budget_data['PR_Number'] != '') & (budget_data['PO_Number'] == '')]
            
            # PO Summary
            po1, po2, po3, po4 = st.columns(4)
            with po1:
                st.metric("PRs Ready for PO", len(prs_for_po))
            with po2:
                pos_created = len(budget_data[budget_data['PO_Number'] != ''])
                st.metric("POs Created", pos_created)
            with po3:
                po_value = budget_data[budget_data['PO_Number'] != '']['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns else 0
                st.metric("PO Total Value", f"${po_value:,.0f}")
            with po4:
                pending_value = prs_for_po['Budget_Annual'].sum() if 'Budget_Annual' in prs_for_po.columns else 0
                st.metric("Pending PO Value", f"${pending_value:,.0f}")
            
            st.markdown("---")
            
            # PRs ready for PO conversion
            if len(prs_for_po) > 0:
                st.markdown("#####  Purchase Requests Ready for PO Conversion")
                
                pr_disp_cols = ['PR_Number', 'PR_Status', 'Expense_Type']
                for c in ['Department', 'Description', 'Budget_Annual', 'Vendor']:
                    if c in prs_for_po.columns:
                        pr_disp_cols.append(c)
                pr_disp_cols = [c for c in pr_disp_cols if c in prs_for_po.columns]
                
                st.dataframe(
                    prs_for_po[pr_disp_cols],
                    use_container_width=True,
                    hide_index=True,
                    column_config={'Budget_Annual': st.column_config.NumberColumn(format='$%.0f')},
                    key="po_pr_list_df"
                )
                
                po_col1, po_col2 = st.columns([3, 1])
                with po_col1:
                    po_type = st.selectbox("PO Type", ["Standard", "Blanket", "Contract", "Planned"], key="po_type_sel")
                with po_col2:
                    if st.button(" Create POs from PRs", type="primary", key="po_create"):
                        count = 0
                        for idx in prs_for_po.index:
                            po_num = f"PO-{datetime.now().strftime('%Y%m%d')}-{idx:04d}"
                            budget_data.at[idx, 'PO_Number'] = po_num
                            count += 1
                        st.session_state.pr_budget_data = budget_data
                        st.toast(f" Created {count} POs in Oracle EBS")
                        st.balloons()
                        st.rerun()
            else:
                st.info("No PRs ready for PO conversion. Generate PRs first in the Purchase Requests tab.")
            
            st.markdown("---")
            
            # Existing POs
            existing_pos = budget_data[budget_data['PO_Number'] != '']
            if len(existing_pos) > 0:
                st.markdown(f"#####  Existing Purchase Orders ({len(existing_pos)})")
                
                # PO status filter
                po_status_filter = st.selectbox("PO Status", ["All", "Open", "Partially Received", "Closed"], key="po_status_flt")
                
                po_disp_cols = ['PO_Number', 'PR_Number', 'Expense_Type']
                for c in ['Department', 'Description', 'Budget_Annual', 'Vendor']:
                    if c in existing_pos.columns:
                        po_disp_cols.append(c)
                po_disp_cols = [c for c in po_disp_cols if c in existing_pos.columns]
                
                st.dataframe(
                    existing_pos[po_disp_cols],
                    use_container_width=True,
                    hide_index=True,
                    column_config={'Budget_Annual': st.column_config.NumberColumn(format='$%.0f')},
                    key="po_list_df"
                )
        else:
            st.info("No PR data available. Generate PRs in the Purchase Requests tab first.")
    
    # =========================================================================
    # TAB 3: VENDORS
    # =========================================================================
    with purch_tabs[2]:
        st.markdown("####  Vendor Management")
        
        budget_data = st.session_state.get('pr_budget_data', pd.DataFrame())
        
        if not budget_data.empty and 'Vendor' in budget_data.columns:
            # Vendor summary
            vendor_summary = budget_data.groupby('Vendor').agg({
                'Budget_Annual': 'sum',
                'PR_Number': lambda x: (x != '').sum(),
                'PO_Number': lambda x: (x != '').sum()
            }).reset_index()
            vendor_summary.columns = ['Vendor', 'Total Spend', 'PR Count', 'PO Count']
            vendor_summary = vendor_summary.sort_values('Total Spend', ascending=False)
            
            # Top vendors
            v1, v2, v3 = st.columns(3)
            with v1:
                st.metric("Total Vendors", len(vendor_summary))
            with v2:
                top_vendor = vendor_summary.iloc[0]['Vendor'] if len(vendor_summary) > 0 else 'N/A'
                st.metric("Top Vendor", top_vendor)
            with v3:
                total_spend = vendor_summary['Total Spend'].sum()
                st.metric("Total Vendor Spend", f"${total_spend:,.0f}")
            
            st.markdown("---")
            st.markdown("#####  Vendor Spend Summary")
            
            st.dataframe(
                vendor_summary,
                use_container_width=True,
                hide_index=True,
                column_config={'Total Spend': st.column_config.NumberColumn(format='$%.0f')},
                key="vendor_summary_df"
            )
            
            st.markdown("---")
            st.markdown("#####  Vendor Spend Distribution")
            st.bar_chart(vendor_summary.set_index('Vendor')['Total Spend'])
        else:
            st.info("No vendor data available. Ensure budget lines have vendor assignments.")
    
    # =========================================================================
    # TAB 4: ANALYTICS
    # =========================================================================
    with purch_tabs[3]:
        st.markdown("####  Purchasing Analytics")
        
        budget_data = st.session_state.get('pr_budget_data', pd.DataFrame())
        
        if not budget_data.empty:
            # Overview metrics
            st.markdown("#####  Spend Overview")
            
            an1, an2, an3, an4 = st.columns(4)
            with an1:
                total_budget = budget_data['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns else 0
                st.metric("Total Budget", f"${total_budget:,.0f}")
            with an2:
                approved_spend = budget_data[budget_data['Approval_Status'] == 'Approved']['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns else 0
                st.metric("Approved Spend", f"${approved_spend:,.0f}")
            with an3:
                pr_spend = budget_data[budget_data['PR_Number'] != '']['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns else 0
                st.metric("PR'd Spend", f"${pr_spend:,.0f}")
            with an4:
                po_spend = budget_data[budget_data['PO_Number'] != '']['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns else 0
                st.metric("PO'd Spend", f"${po_spend:,.0f}")
            
            st.markdown("---")
            
            # Spend by Type
            if 'Expense_Type' in budget_data.columns and 'Budget_Annual' in budget_data.columns:
                st.markdown("#####  OPEX vs CAPEX")
                type_spend = budget_data.groupby('Expense_Type')['Budget_Annual'].sum()
                
                tc1, tc2 = st.columns([1, 2])
                with tc1:
                    for exp_type, amount in type_spend.items():
                        pct = (amount / total_budget * 100) if total_budget > 0 else 0
                        st.metric(exp_type, f"${amount:,.0f}", f"{pct:.1f}%")
                with tc2:
                    st.bar_chart(type_spend)
            
            st.markdown("---")
            
            # Approval Status Distribution
            if 'Approval_Status' in budget_data.columns:
                st.markdown("#####  Approval Status Distribution")
                status_counts = budget_data['Approval_Status'].value_counts()
                st.bar_chart(status_counts)
            
            st.markdown("---")
            
            # Department Spend
            if 'Department' in budget_data.columns and 'Budget_Annual' in budget_data.columns:
                st.markdown("#####  Spend by Department")
                dept_spend = budget_data.groupby('Department')['Budget_Annual'].sum().sort_values(ascending=False)
                st.bar_chart(dept_spend)
            
            st.markdown("---")
            
            # Pipeline Summary
            st.markdown("#####  Procurement Pipeline")
            
            pipeline_data = {
                'Stage': ['Budget Pending', 'Budget Approved', 'PR Created', 'PO Created'],
                'Count': [
                    len(budget_data[budget_data['Approval_Status'] == 'Pending']),
                    len(budget_data[(budget_data['Approval_Status'] == 'Approved') & (budget_data['PR_Number'] == '')]),
                    len(budget_data[(budget_data['PR_Number'] != '') & (budget_data['PO_Number'] == '')]),
                    len(budget_data[budget_data['PO_Number'] != ''])
                ],
                'Value': [
                    budget_data[budget_data['Approval_Status'] == 'Pending']['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns else 0,
                    budget_data[(budget_data['Approval_Status'] == 'Approved') & (budget_data['PR_Number'] == '')]['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns else 0,
                    budget_data[(budget_data['PR_Number'] != '') & (budget_data['PO_Number'] == '')]['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns else 0,
                    budget_data[budget_data['PO_Number'] != '']['Budget_Annual'].sum() if 'Budget_Annual' in budget_data.columns else 0
                ]
            }
            pipeline_df = pd.DataFrame(pipeline_data)
            st.dataframe(
                pipeline_df,
                use_container_width=True,
                hide_index=True,
                column_config={'Value': st.column_config.NumberColumn(format='$%.0f')},
                key="pipeline_df"
            )
        else:
            st.info("No data available for analytics. Load budget data first.")


# =============================================================================
# PAGE: WORKFORCE PLANNING
# =============================================================================

elif page == " Workforce Planning":
    tab1, tab2, tab3, tab4 = st.tabs([" Headcount Plan", " Compensation", " Analytics", " Requisitions"])
    
    with tab1:
        st.caption("Manage headcount, compensation, and workforce costs")
        if st.session_state.headcount_plan.empty:
            st.info("No headcount data. Load sample data or import from HR system.")
        else:
            hc_df = st.session_state.headcount_plan
            
            # Summary metrics
            col1, col2, col3, col4, col5 = st.columns(5)
            
            active_count = len(hc_df[hc_df['Status'] == 'Active'])
            planned_hires = len(hc_df[hc_df['Status'] == 'Planned Hire'])
            total_salary = hc_df[hc_df['Status'] == 'Active']['Annual Salary'].sum()
            avg_salary = hc_df[hc_df['Status'] == 'Active']['Annual Salary'].mean()
            total_fte = hc_df[hc_df['Status'] == 'Active']['FTE'].sum()
            
            with col1:
                st.metric("Active Headcount", f"{active_count:,}")
            with col2:
                st.metric("Planned Hires", f"{planned_hires:,}")
            with col3:
                st.metric("Total FTE", f"{total_fte:.1f}")
            with col4:
                st.metric("Total Salary", format_currency(total_salary))
            with col5:
                st.metric("Avg Salary", format_currency(avg_salary))
            
            st.markdown("---")
            
            # Filters
            col1, col2, col3 = st.columns(3)
            
            with col1:
                dept_filter = st.multiselect("Department", hc_df['Department'].unique())
            with col2:
                status_filter = st.multiselect("Status", hc_df['Status'].unique())
            with col3:
                entity_filter = st.multiselect("Entity", hc_df['Entity'].unique())
            
            # Apply filters
            display_hc = hc_df.copy()
            if dept_filter:
                display_hc = display_hc[display_hc['Department'].isin(dept_filter)]
            if status_filter:
                display_hc = display_hc[display_hc['Status'].isin(status_filter)]
            if entity_filter:
                display_hc = display_hc[display_hc['Entity'].isin(entity_filter)]
            
            # Display table
            st.dataframe(
                display_hc,
                use_container_width=True,
                height=400,
                column_config={
                    'Annual Salary': st.column_config.NumberColumn('Annual Salary', format="$%.0f"),
                    'Bonus Target %': st.column_config.NumberColumn('Bonus %', format="%.0f%%"),
                }
            )
            
            # Export
            col1, col2 = st.columns([1, 5])
            with col1:
                output = io.BytesIO()
                display_hc.to_excel(output, index=False)
                output.seek(0)
                st.download_button(
                    " Export",
                    data=output,
                    file_name="headcount_plan.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )
    
    with tab2:
        st.markdown("### Compensation Assumptions")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("#### Merit & COLA Increases")
            merit_increase = st.slider("Merit Increase %", 0.0, 10.0, 3.5, 0.5)
            cola_increase = st.slider("COLA Increase %", 0.0, 5.0, 2.0, 0.5)
            effective_date = st.date_input("Effective Date", datetime(datetime.now().year, 4, 1))
        
        with col2:
            st.markdown("#### Benefits & Taxes")
            health_rate = st.slider("Health Insurance %", 0.0, 30.0, 15.0, 0.5)
            retirement_rate = st.slider("401k Match %", 0.0, 10.0, 4.0, 0.5)
            payroll_tax_rate = st.slider("Payroll Tax %", 0.0, 15.0, 7.65, 0.01)
        
        st.markdown("---")
        
        st.markdown("#### Compensation Cost Projection")
        
        if not st.session_state.headcount_plan.empty:
            hc_df = st.session_state.headcount_plan[st.session_state.headcount_plan['Status'] == 'Active']
            
            base_salary = hc_df['Annual Salary'].sum()
            total_benefits = base_salary * (health_rate + retirement_rate + payroll_tax_rate) / 100
            total_bonus = (hc_df['Annual Salary'] * hc_df['Bonus Target %'] / 100).sum()
            
            merit_cost = base_salary * (merit_increase / 100) * (9/12)  # Assuming April effective
            
            projection_data = {
                'Category': ['Base Salaries', 'Merit Increase', 'Benefits', 'Bonus Accrual', 'Total'],
                'Current Year': [base_salary, merit_cost, total_benefits, total_bonus, 
                               base_salary + merit_cost + total_benefits + total_bonus],
                'Next Year': [base_salary * 1.03, base_salary * 1.03 * (merit_increase/100), 
                            total_benefits * 1.05, total_bonus * 1.03,
                            (base_salary * 1.03) * (1 + (merit_increase + health_rate + retirement_rate + payroll_tax_rate)/100) + total_bonus * 1.03]
            }
            
            proj_df = pd.DataFrame(projection_data)
            proj_df['Current Year'] = proj_df['Current Year'].apply(lambda x: f"${x:,.0f}")
            proj_df['Next Year'] = proj_df['Next Year'].apply(lambda x: f"${x:,.0f}")
            
            st.dataframe(proj_df, use_container_width=True, hide_index=True)
    
    with tab3:
        st.markdown("### Workforce Analytics")
        
        if not st.session_state.headcount_plan.empty:
            hc_df = st.session_state.headcount_plan
            
            col1, col2 = st.columns(2)
            
            with col1:
                # Headcount by department
                dept_hc = hc_df[hc_df['Status'] == 'Active'].groupby('Department').size()
                
                fig_dept = px.pie(
                    values=dept_hc.values,
                    names=dept_hc.index,
                    title="Headcount by Department",
                    hole=0.4
                )
                st.plotly_chart(fig_dept, use_container_width=True)
            
            with col2:
                # Salary distribution
                active_hc = hc_df[hc_df['Status'] == 'Active']
                
                fig_salary = px.histogram(
                    active_hc,
                    x='Annual Salary',
                    nbins=20,
                    title="Salary Distribution"
                )
                fig_salary.update_layout(xaxis_title="Annual Salary", yaxis_title="Count")
                st.plotly_chart(fig_salary, use_container_width=True)
            
            # Cost by department
            st.markdown("#### Compensation Cost by Department")
            
            dept_cost = hc_df[hc_df['Status'] == 'Active'].groupby('Department').agg({
                'Annual Salary': 'sum',
                'Employee ID': 'count'
            }).rename(columns={'Employee ID': 'Headcount'})
            
            dept_cost['Avg Salary'] = dept_cost['Annual Salary'] / dept_cost['Headcount']
            dept_cost['Loaded Cost'] = dept_cost['Annual Salary'] * 1.35  # 35% burden
            
            dept_cost = dept_cost.sort_values('Loaded Cost', ascending=False)
            
            for col in ['Annual Salary', 'Avg Salary', 'Loaded Cost']:
                dept_cost[col] = dept_cost[col].apply(lambda x: f"${x:,.0f}")
            
            st.dataframe(dept_cost, use_container_width=True)
    
    with tab4:
        st.markdown("### Open Requisitions")
        
        if not st.session_state.headcount_plan.empty:
            reqs = st.session_state.headcount_plan[st.session_state.headcount_plan['Status'] == 'Planned Hire']
            
            if not reqs.empty:
                st.dataframe(
                    reqs[['Employee ID', 'Position', 'Department', 'Cost Center Name', 'Hire Date', 'Annual Salary']],
                    use_container_width=True,
                    column_config={
                        'Annual Salary': st.column_config.NumberColumn('Annual Salary', format="$%.0f")
                    }
                )
            else:
                st.info("No open requisitions")


# =============================================================================
# PAGE: REVENUE PLANNING
# =============================================================================

elif page == " Revenue Planning":
    tab1, tab2, tab3, tab4 = st.tabs([" Revenue Forecast", " Customer Analysis", " Product Mix", " Pipeline"])
    
    with tab1:
        st.caption("Forecast revenue by customer, product, and channel")
        
        # Check for enhanced data first, then regular budget data
        has_enhanced = 'budget_data_enhanced' in st.session_state and not st.session_state.budget_data_enhanced.empty
        has_budget = not st.session_state.budget_data.empty
        
        if has_enhanced:
            df = st.session_state.budget_data_enhanced
            
            # For EnergySolutions data, filter for Revenue category
            if 'Account_Category' in df.columns:
                revenue_df = df[df['Account_Category'] == 'Revenue']
                
                if revenue_df.empty:
                    # If no Revenue category, show contract revenue instead
                    st.info("No revenue accounts in enhanced data. Showing contract revenue from Contracts page.")
                    if 'contracts_data' in st.session_state and not st.session_state.contracts_data.empty:
                        contract_df = st.session_state.contracts_data
                        
                        # Monthly revenue from contracts
                        total_contract_value = contract_df['Contract_Value'].sum() if 'Contract_Value' in contract_df.columns else 0
                        avg_monthly = total_contract_value / 12
                        
                        st.metric("Total Contract Value", f"${total_contract_value/1e6:.1f}M")
                        st.metric("Avg Monthly Revenue", f"${avg_monthly/1e6:.1f}M")
                        
                        # Contract revenue by customer
                        if 'Customer' in contract_df.columns:
                            by_customer = contract_df.groupby('Customer')['Contract_Value'].sum().sort_values(ascending=False)
                            fig = px.pie(values=by_customer.values, names=by_customer.index, hole=0.4, title="Revenue by Customer")
                            st.plotly_chart(fig, use_container_width=True)
                    else:
                        st.info("Load contract data to view revenue by customer.")
                else:
                    # Has revenue data in enhanced format
                    monthly_rev = revenue_df.groupby('Month')['Amount'].sum().reindex(MONTHS) / 1e6
                    
                    fig = go.Figure()
                    fig.add_trace(go.Bar(name='Revenue', x=MONTHS, y=monthly_rev.values, marker_color='#3b82f6'))
                    fig.update_layout(title="Monthly Revenue ($M)", height=400)
                    st.plotly_chart(fig, use_container_width=True)
                    
                    # Revenue by business unit
                    if 'Business_Unit_Name' in revenue_df.columns:
                        by_bu = revenue_df.groupby('Business_Unit_Name')['Amount'].sum()
                        fig_bu = px.pie(values=by_bu.values, names=by_bu.index, hole=0.4, title="Revenue by Business Unit")
                        st.plotly_chart(fig_bu, use_container_width=True)
            else:
                st.info("Enhanced data structure not recognized. Please load XYZ sample data.")
        
        elif has_budget:
            df = st.session_state.budget_data
            
            # Original logic for budget_data with Account column
            if 'Account' in df.columns:
                revenue_df = df[df['Account'].str.startswith('4')]
                
                if not revenue_df.empty:
                    # Monthly revenue chart
                    monthly_rev = revenue_df.groupby('Month').agg({
                        'Budget': 'sum',
                        'Actual': 'sum', 
                        'Forecast': 'sum'
                    }).reindex(MONTHS) / 1e6
                    
                    fig = go.Figure()
                    
                    fig.add_trace(go.Bar(name='Budget', x=MONTHS, y=monthly_rev['Budget'], marker_color='#e5e7eb'))
                    fig.add_trace(go.Bar(name='Actual', x=MONTHS[:datetime.now().month], 
                                        y=monthly_rev['Actual'][:datetime.now().month], marker_color='#3b82f6'))
                    fig.add_trace(go.Scatter(name='Forecast', x=MONTHS, y=monthly_rev['Forecast'],
                                            mode='lines+markers', line=dict(color='#10b981', dash='dot')))
                    
                    fig.update_layout(
                        title="Monthly Revenue ($M)",
                        barmode='overlay',
                        height=400,
                        legend=dict(orientation='h', yanchor='bottom', y=1.02)
                    )
                    
                    st.plotly_chart(fig, use_container_width=True)
                    
                    # Revenue by type
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.markdown("#### Revenue by Type")
                        rev_by_account = revenue_df.groupby('Account Name')['Budget'].sum()
                        
                        fig_type = px.pie(values=rev_by_account.values, names=rev_by_account.index, hole=0.4)
                        st.plotly_chart(fig_type, use_container_width=True)
                    
                    with col2:
                        st.markdown("#### Quarterly Breakdown")
                        
                        revenue_df['Quarter'] = revenue_df['Month'].apply(
                            lambda m: 'Q1' if m in QUARTERS['Q1'] else 'Q2' if m in QUARTERS['Q2'] 
                            else 'Q3' if m in QUARTERS['Q3'] else 'Q4'
                        )
                        
                        quarterly = revenue_df.groupby('Quarter')[['Budget', 'Actual', 'Forecast']].sum() / 1e6
                        quarterly = quarterly.reindex(['Q1', 'Q2', 'Q3', 'Q4'])
                        
                        quarterly['Budget'] = quarterly['Budget'].apply(lambda x: f"${x:.1f}M")
                        quarterly['Actual'] = quarterly['Actual'].apply(lambda x: f"${x:.1f}M")
                        quarterly['Forecast'] = quarterly['Forecast'].apply(lambda x: f"${x:.1f}M")
                        
                        st.dataframe(quarterly, use_container_width=True)
                else:
                    st.info("No revenue accounts found in budget data (accounts starting with '4').")
            else:
                st.info("Budget data does not have expected 'Account' column.")
        else:
            st.info(" Load budget data to view revenue planning. Use Budget Planning  Import or load XYZ sample data.")
    
    with tab2:
        st.markdown("### Customer Analysis")
        st.info("Customer-level revenue tracking coming soon. Connect to CRM for customer data.")
    
    with tab3:
        st.markdown("### Product Mix Analysis")
        st.info("Product-level analysis coming soon. Connect to product catalog.")
    
    with tab4:
        st.markdown("### Sales Pipeline")
        st.info("Pipeline integration coming soon. Connect to Salesforce or HubSpot.")


# =============================================================================
# PAGE: CAPEX MANAGEMENT
# =============================================================================

elif page == " CapEx Management":
    tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([
        " Dashboard", 
        " Project List",
        " Budget vs Actual", 
        " Multi-Year Plan",
        " Import Data",
        " New Project"
    ])
    
    # Get config
    capex_config = st.session_state.capex_config
    
    with tab1:
        st.caption("Capital expenditure planning, tracking, and approvals")
        
        if st.session_state.capex_projects.empty:
            st.info(" No CapEx data loaded. Use the 'Import Data' tab to upload your CapEx file, or load sample data.")
            
            if st.button(" Load Sample CapEx Data"):
                # Generate sample capex data
                np.random.seed(42)
                sample_projects = []
                
                facilities = capex_config['facilities'][:10]
                divisions = capex_config['divisions']
                statuses = capex_config['statuses'][:4]
                priorities = capex_config['priorities']
                reasons = capex_config['reasons']
                
                for i in range(50):
                    facility = np.random.choice(facilities)
                    division = np.random.choice(divisions)
                    budget = np.random.randint(50000, 5000000)
                    
                    # Generate monthly actuals (some months have actuals, later months are forecast)
                    months_with_actuals = np.random.randint(0, 10)
                    monthly_data = {}
                    total_spent = 0
                    
                    for m_idx, month in enumerate(MONTHS):
                        if m_idx < months_with_actuals:
                            # Actual
                            spent = np.random.uniform(0, budget / 8) if np.random.random() > 0.5 else 0
                            monthly_data[month] = round(spent, 2)
                            total_spent += spent
                        else:
                            # Forecast remaining
                            remaining = budget - total_spent
                            if remaining > 0 and m_idx == 11:  # Put rest in December
                                monthly_data[month] = round(remaining * 0.3, 2)
                            else:
                                monthly_data[month] = 0
                    
                    sample_projects.append({
                        'Project_ID': f"25{division[:2].upper()}{i+1:02d}",
                        'Facility': facility,
                        'Division': division,
                        'Project_Name': f"Project {i+1} - {np.random.choice(['Equipment', 'Building', 'IT', 'Vehicle', 'Infrastructure'])} {np.random.choice(['Upgrade', 'Replacement', 'New', 'Expansion'])}",
                        'Reason': np.random.choice(reasons),
                        'Status': np.random.choice(statuses),
                        'Priority': np.random.choice(priorities),
                        'Payment_Method': np.random.choice(capex_config['payment_methods']),
                        'Currency': 'USD',
                        'Budget_2025': budget,
                        'ITD_Spent': round(total_spent * 0.3, 2),
                        'Approval_Status': np.random.choice(['Approved', 'Pending', 'Not Required']),
                        'President_Approval': np.random.choice(['Y', 'N', '']),
                        'Committee_Approval': np.random.choice(['Y', 'N', '']),
                        'Budget_2026': round(budget * np.random.uniform(0, 0.5), 0) if np.random.random() > 0.7 else 0,
                        'Budget_2027': round(budget * np.random.uniform(0, 0.3), 0) if np.random.random() > 0.8 else 0,
                        **monthly_data
                    })
                
                st.session_state.capex_projects = pd.DataFrame(sample_projects)
                st.success(f"Loaded {len(sample_projects)} sample CapEx projects!")
                st.rerun()
        else:
            df = st.session_state.capex_projects
            
            # KPI Row
            col1, col2, col3, col4, col5 = st.columns(5)
            
            total_budget = df['Budget_2025'].sum() if 'Budget_2025' in df.columns else 0
            
            # Calculate YTD spent
            month_cols = [m for m in MONTHS if m in df.columns]
            current_month_idx = datetime.now().month
            ytd_cols = month_cols[:current_month_idx]
            ytd_spent = df[ytd_cols].sum().sum() if ytd_cols else 0
            
            # Count projects
            total_projects = len(df)
            approved_projects = len(df[df.get('Approval_Status', pd.Series([''])) == 'Approved']) if 'Approval_Status' in df.columns else 0
            
            with col1:
                st.metric("Total Budget", f"${total_budget/1e6:.1f}M")
            with col2:
                st.metric("YTD Spent", f"${ytd_spent/1e6:.1f}M")
            with col3:
                st.metric("Remaining", f"${(total_budget - ytd_spent)/1e6:.1f}M")
            with col4:
                st.metric("Total Projects", total_projects)
            with col5:
                st.metric("Approved", approved_projects)
            
            st.markdown("---")
            
            # Charts row
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("#### Budget by Division")
                if 'Division' in df.columns and 'Budget_2025' in df.columns:
                    div_budget = df.groupby('Division')['Budget_2025'].sum().sort_values(ascending=True)
                    
                    fig = go.Figure(go.Bar(
                        x=div_budget.values / 1e6,
                        y=div_budget.index,
                        orientation='h',
                        marker_color='#3b82f6'
                    ))
                    fig.update_layout(
                        height=300,
                        margin=dict(l=20, r=20, t=20, b=20),
                        xaxis_title='Budget ($M)',
                        yaxis_title=''
                    )
                    st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                st.markdown("#### Monthly Spend Trend")
                if month_cols:
                    monthly_totals = df[month_cols].sum()
                    
                    fig = go.Figure()
                    fig.add_trace(go.Bar(
                        x=month_cols,
                        y=monthly_totals.values / 1e6,
                        marker_color=['#3b82f6' if i < current_month_idx else '#e5e7eb' for i in range(len(month_cols))]
                    ))
                    fig.update_layout(
                        height=300,
                        margin=dict(l=20, r=20, t=20, b=20),
                        xaxis_title='',
                        yaxis_title='Spend ($M)'
                    )
                    st.plotly_chart(fig, use_container_width=True)
            
            # Top projects table
            st.markdown("#### Top 10 Projects by Budget")
            display_cols = ['Project_ID', 'Facility', 'Project_Name', 'Status', 'Budget_2025']
            if 'Approval_Status' in df.columns:
                display_cols.append('Approval_Status')
            available_cols = [c for c in display_cols if c in df.columns]
            top_projects = df.nlargest(10, 'Budget_2025')[available_cols].copy()
            top_projects['Budget_2025'] = top_projects['Budget_2025'].apply(lambda x: f"${x:,.0f}")
            st.dataframe(top_projects, use_container_width=True, hide_index=True)
    
    with tab2:
        st.markdown("### Project List")
        
        if st.session_state.capex_projects.empty:
            st.info("No CapEx data yet. Go to the Dashboard tab above and click Load Sample CapEx Data.")
        else:
            df = st.session_state.capex_projects
            
            # Filters
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                div_filter = st.multiselect("Division", df['Division'].unique() if 'Division' in df.columns else [])
            with col2:
                fac_filter = st.multiselect("Facility", df['Facility'].unique() if 'Facility' in df.columns else [])
            with col3:
                status_filter = st.multiselect("Status", df['Status'].unique() if 'Status' in df.columns else [])
            with col4:
                priority_filter = st.multiselect("Priority", df['Priority'].unique() if 'Priority' in df.columns else [])
            
            # Apply filters
            filtered_df = df.copy()
            if div_filter:
                filtered_df = filtered_df[filtered_df['Division'].isin(div_filter)]
            if fac_filter:
                filtered_df = filtered_df[filtered_df['Facility'].isin(fac_filter)]
            if status_filter:
                filtered_df = filtered_df[filtered_df['Status'].isin(status_filter)]
            if priority_filter:
                filtered_df = filtered_df[filtered_df['Priority'].isin(priority_filter)]
            
            st.markdown(f"**Showing {len(filtered_df)} of {len(df)} projects**")
            
            # Select columns to display
            display_cols = ['Project_ID', 'Facility', 'Division', 'Project_Name', 'Status', 
                          'Priority', 'Budget_2025', 'Approval_Status']
            display_cols = [c for c in display_cols if c in filtered_df.columns]
            
            # Editable grid
            edited_df = st.data_editor(
                filtered_df[display_cols],
                use_container_width=True,
                height=500,
                column_config={
                    'Budget_2025': st.column_config.NumberColumn('2025 Budget', format="$%.0f"),
                    'Status': st.column_config.SelectboxColumn('Status', options=capex_config['statuses']),
                    'Priority': st.column_config.SelectboxColumn('Priority', options=capex_config['priorities']),
                }
            )
            
            col1, col2 = st.columns([1, 5])
            with col1:
                if st.button(" Save Changes"):
                    st.success("Changes saved!")
            with col2:
                # Export
                output = io.BytesIO()
                filtered_df.to_excel(output, index=False)
                output.seek(0)
                st.download_button(
                    " Export to Excel",
                    data=output,
                    file_name=f"capex_projects_{datetime.now().strftime('%Y%m%d')}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )
    
    with tab3:
        st.markdown("### Budget vs Actual Analysis")
        
        if st.session_state.capex_projects.empty:
            st.info("No CapEx data yet. Go to the Dashboard tab above and click Load Sample CapEx Data.")
        else:
            df = st.session_state.capex_projects
            month_cols = [m for m in MONTHS if m in df.columns]
            current_month_idx = datetime.now().month
            
            # Summary by Division
            st.markdown("#### By Division")
            
            if 'Division' in df.columns and 'Budget_2025' in df.columns and month_cols:
                ytd_cols = month_cols[:current_month_idx]
                
                div_summary = df.groupby('Division').agg({
                    'Budget_2025': 'sum',
                    **{col: 'sum' for col in ytd_cols}
                })
                
                div_summary['YTD_Actual'] = div_summary[ytd_cols].sum(axis=1) if ytd_cols else 0
                div_summary['YTD_Budget'] = div_summary['Budget_2025'] * (current_month_idx / 12)
                div_summary['Variance'] = div_summary['YTD_Budget'] - div_summary['YTD_Actual']
                div_summary['Variance_%'] = (div_summary['Variance'] / div_summary['YTD_Budget'] * 100).round(1)
                
                display_div = div_summary[['Budget_2025', 'YTD_Budget', 'YTD_Actual', 'Variance', 'Variance_%']].copy()
                for col in ['Budget_2025', 'YTD_Budget', 'YTD_Actual', 'Variance']:
                    display_div[col] = display_div[col].apply(lambda x: f"${x:,.0f}")
                display_div['Variance_%'] = display_div['Variance_%'].apply(lambda x: f"{x:+.1f}%")
                
                st.dataframe(display_div, use_container_width=True)
            
            st.markdown("---")
            
            # Project-level detail
            st.markdown("#### Project Detail")
            
            # Select a project to drill down
            if 'Project_Name' in df.columns:
                project_options = df['Project_Name'].tolist()
                selected_project = st.selectbox("Select Project", ['All'] + project_options)
                
                if selected_project != 'All':
                    project_data = df[df['Project_Name'] == selected_project].iloc[0]
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.markdown(f"**Project:** {project_data.get('Project_Name', 'N/A')}")
                        st.markdown(f"**Facility:** {project_data.get('Facility', 'N/A')}")
                        st.markdown(f"**Division:** {project_data.get('Division', 'N/A')}")
                        st.markdown(f"**Status:** {project_data.get('Status', 'N/A')}")
                    
                    with col2:
                        budget = project_data.get('Budget_2025', 0)
                        ytd_actual = sum(project_data.get(m, 0) for m in ytd_cols) if ytd_cols else 0
                        
                        st.metric("2025 Budget", f"${budget:,.0f}")
                        st.metric("YTD Spent", f"${ytd_actual:,.0f}")
                        st.metric("Remaining", f"${budget - ytd_actual:,.0f}")
                    
                    # Monthly chart
                    if month_cols:
                        monthly_values = [project_data.get(m, 0) for m in month_cols]
                        
                        fig = go.Figure()
                        fig.add_trace(go.Bar(
                            x=month_cols,
                            y=monthly_values,
                            marker_color=['#3b82f6' if i < current_month_idx else '#e5e7eb' for i in range(12)]
                        ))
                        fig.update_layout(
                            title="Monthly Spend",
                            height=300,
                            xaxis_title='',
                            yaxis_title='Amount ($)'
                        )
                        st.plotly_chart(fig, use_container_width=True)
    
    with tab4:
        st.markdown("### Multi-Year Capital Plan")
        
        if st.session_state.capex_projects.empty:
            st.info("No CapEx data yet. Go to the Dashboard tab above and click Load Sample CapEx Data.")
        else:
            df = st.session_state.capex_projects
            
            # Check for multi-year columns
            year_cols = ['Budget_2025', 'Budget_2026', 'Budget_2027', 'Budget_2028', 'Budget_2029']
            available_year_cols = [c for c in year_cols if c in df.columns]
            
            if available_year_cols:
                # Summary by year
                st.markdown("#### Annual Plan Summary")
                
                year_totals = {col.replace('Budget_', ''): df[col].sum() for col in available_year_cols}
                
                year_df = pd.DataFrame([{
                    'Year': year,
                    'Budget': total,
                    'Display': f"${total/1e6:.1f}M"
                } for year, total in year_totals.items()])
                
                fig = go.Figure(go.Bar(
                    x=year_df['Year'],
                    y=year_df['Budget'] / 1e6,
                    text=year_df['Display'],
                    textposition='outside',
                    marker_color='#3b82f6'
                ))
                fig.update_layout(
                    height=350,
                    xaxis_title='Year',
                    yaxis_title='Budget ($M)',
                    showlegend=False
                )
                st.plotly_chart(fig, use_container_width=True)
                
                # Division breakdown by year
                st.markdown("#### By Division (Multi-Year)")
                
                if 'Division' in df.columns:
                    multi_year = df.groupby('Division')[available_year_cols].sum()
                    
                    # Rename columns for display
                    multi_year.columns = [c.replace('Budget_', '') for c in multi_year.columns]
                    
                    # Format as currency
                    display_multi = multi_year.copy()
                    for col in display_multi.columns:
                        display_multi[col] = display_multi[col].apply(lambda x: f"${x:,.0f}")
                    
                    st.dataframe(display_multi, use_container_width=True)
                    
                    # Stacked bar chart
                    fig = go.Figure()
                    
                    for div in multi_year.index:
                        fig.add_trace(go.Bar(
                            name=div,
                            x=multi_year.columns.tolist(),
                            y=multi_year.loc[div].values / 1e6
                        ))
                    
                    fig.update_layout(
                        barmode='stack',
                        height=400,
                        xaxis_title='Year',
                        yaxis_title='Budget ($M)',
                        legend=dict(orientation='h', yanchor='bottom', y=1.02)
                    )
                    st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("Multi-year budget columns not found. Import data with 2026-2029 budget columns.")
    
    with tab5:
        st.markdown("### Import CapEx Data")
        st.markdown("Upload your CapEx Excel file to import project data.")
        
        uploaded_file = st.file_uploader("Upload CapEx File", type=['xlsx', 'xls', 'xlsb'])
        
        if uploaded_file:
            try:
                xl = pd.ExcelFile(uploaded_file)
                
                st.markdown("#### Available Sheets")
                sheet_name = st.selectbox("Select Sheet", xl.sheet_names)
                
                # Preview
                preview_df = pd.read_excel(uploaded_file, sheet_name=sheet_name, header=None, nrows=10)
                st.markdown("#### Preview (first 10 rows)")
                st.dataframe(preview_df, use_container_width=True)
                
                st.markdown("---")
                st.markdown("#### Column Mapping")
                
                col1, col2 = st.columns(2)
                
                with col1:
                    header_row = st.number_input("Header Row", 0, 20, 0)
                    data_start_row = st.number_input("Data Start Row", 1, 50, 5)
                
                with col2:
                    # Auto-detect columns
                    st.markdown("**Standard column mapping will be applied:**")
                    st.markdown("""
                    - Column A: Facility
                    - Column B: Division
                    - Column C: CapEx Number  Project_ID
                    - Column D: Asset/Project  Project_Name
                    - Column E: Reason
                    - Column F: Status
                    - Column G: Priority
                    - Column T: 2025 Budget
                    - Columns V-AG: Jan-Dec
                    - Columns AJ-AM: 2026-2029 Budget
                    """)
                
                if st.button(" Import Data", type="primary"):
                    # Read the full data
                    full_df = pd.read_excel(uploaded_file, sheet_name=sheet_name, header=None)
                    
                    # Set headers from specified row
                    headers = full_df.iloc[header_row].tolist()
                    
                    # Get data rows
                    data_df = full_df.iloc[data_start_row:].copy()
                    data_df.columns = headers
                    
                    # Rename columns to standard names
                    column_mapping = {
                        'Facility': 'Facility',
                        'Division': 'Division',
                        'CapEx Number': 'Project_ID',
                        'Asset or Project': 'Project_Name',
                        'Reason': 'Reason',
                        'Status': 'Status',
                        'Priority': 'Priority',
                        'Capex Class': 'Capex_Class',
                        'Type': 'Type',
                        'Payment Method': 'Payment_Method',
                        'Currency': 'Currency',
                        'Budgeted': 'Budgeted',
                        'President Approval': 'President_Approval',
                        'Committee Approval': 'Committee_Approval',
                        'Review Date': 'Review_Date',
                        'ITD Total (as of 12/31/2024)': 'ITD_Spent',
                        '2025 Local Currency': 'Budget_2025',
                        '2025 Plan (USD)': 'Budget_2025_USD',
                        '2026 Plan (USD)': 'Budget_2026',
                        '2027 Plan (USD)': 'Budget_2027',
                        '2028 Plan (USD)': 'Budget_2028',
                        '2029 Plan (USD)': 'Budget_2029',
                        'Notes': 'Notes',
                    }
                    
                    # Apply mapping
                    data_df = data_df.rename(columns=column_mapping)
                    
                    # Drop rows with no project name
                    if 'Project_Name' in data_df.columns:
                        data_df = data_df[data_df['Project_Name'].notna() & (data_df['Project_Name'] != '')]
                    
                    # Store in session state
                    st.session_state.capex_projects = data_df
                    
                    st.success(f" Imported {len(data_df)} CapEx projects!")
                    st.rerun()
                    
            except Exception as e:
                st.error(f"Error reading file: {e}")
    
    with tab6:
        st.markdown("### Add New CapEx Project")
        
        with st.form("new_capex_project"):
            col1, col2 = st.columns(2)
            
            with col1:
                project_id = st.text_input("Project ID*", placeholder="e.g., 25WM01")
                facility = st.selectbox("Facility*", capex_config['facilities'])
                division = st.selectbox("Division*", capex_config['divisions'])
                project_name = st.text_input("Project Name*", placeholder="Description of the project")
                reason = st.selectbox("Reason", capex_config['reasons'])
            
            with col2:
                status = st.selectbox("Status", capex_config['statuses'])
                priority = st.selectbox("Priority", capex_config['priorities'])
                payment_method = st.selectbox("Payment Method", capex_config['payment_methods'])
                budget_2025 = st.number_input("2025 Budget ($)", min_value=0.0, step=10000.0)
                budget_2026 = st.number_input("2026 Budget ($)", min_value=0.0, step=10000.0)
            
            notes = st.text_area("Notes", placeholder="Additional notes or justification...")
            
            submitted = st.form_submit_button(" Add Project", type="primary")
            
            if submitted:
                if not project_id or not project_name:
                    st.error("Project ID and Name are required")
                else:
                    new_project = {
                        'Project_ID': project_id,
                        'Facility': facility,
                        'Division': division,
                        'Project_Name': project_name,
                        'Reason': reason,
                        'Status': status,
                        'Priority': priority,
                        'Payment_Method': payment_method,
                        'Currency': 'USD',
                        'Budget_2025': budget_2025,
                        'Budget_2026': budget_2026,
                        'Approval_Status': 'Pending',
                        'Notes': notes,
                        **{m: 0 for m in MONTHS}
                    }
                    
                    if st.session_state.capex_projects.empty:
                        st.session_state.capex_projects = pd.DataFrame([new_project])
                    else:
                        st.session_state.capex_projects = pd.concat([
                            st.session_state.capex_projects,
                            pd.DataFrame([new_project])
                        ], ignore_index=True)
                    
                    st.success(f" Project '{project_name}' added successfully!")
                    
                    # Offer to create approval workflow
                    if budget_2025 >= 100000:
                        st.info(f" This project has a budget of ${budget_2025:,.0f}. Consider submitting for approval via the Approvals page.")


# =============================================================================
# PAGE: LABOR/RESOURCE PLANNING
# =============================================================================

elif page == " Labor/Resource Planning":
    tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([
        " Utilization Dashboard", 
        " Resource Allocation",
        " Hours Planning", 
        " Timesheet Entry",
        " Batch Approval",
        " Labor Analytics"
    ])
    
    # Initialize resource data if needed
    if 'resource_data' not in st.session_state:
        st.session_state.resource_data = pd.DataFrame()
    
    # Ensure required columns exist if data is loaded
    if not st.session_state.resource_data.empty:
        required_cols = {'YTD_Hours': 0, 'Billable_Hours': 0, 'Overtime_Hours': 0, 
                        'Budgeted_Hours': 0, 'Status': 'Active', 'Facility': 'Unknown',
                        'Department': 'Unknown', 'Labor_Category': 'Unknown'}
        for col, default in required_cols.items():
            if col not in st.session_state.resource_data.columns:
                st.session_state.resource_data[col] = default
    if 'timesheet_data' not in st.session_state:
        st.session_state.timesheet_data = pd.DataFrame()
    if 'timesheet_approvals' not in st.session_state:
        st.session_state.timesheet_approvals = pd.DataFrame()
    if 'resource_config' not in st.session_state:
        st.session_state.resource_config = {
            'labor_categories': ['Direct Labor', 'Indirect Labor', 'Overhead', 'G&A', 'B&P', 'IR&D'],
            'charge_types': ['Billable', 'Non-Billable', 'PTO', 'Holiday', 'Training', 'Admin'],
            'work_types': ['Regular', 'Overtime', 'Double Time'],
            'standard_hours_per_week': 40,
            'standard_hours_per_year': 2080,
            'overtime_threshold': 40,
            'pay_codes': {
                'DT': 'Direct Time',
                'O': 'Overtime',
                'R': 'Regular',
                '26': 'Exempt Regular',
                '00.1.252': 'Direct Labor - Project',
                '00.1.000': 'Indirect Labor'
            },
            'schedules': ['ES-SF', 'ES-CL', 'ES-BC', 'ES-MM', 'ES-HN'],
            'employee_classes': ['REG HNE', 'REG SE', 'REG CL', 'REG BC', 'EXEMPT']
        }
    
    with tab1:
        st.caption("Track labor utilization across projects and cost centers")
        
        if st.session_state.resource_data.empty:
            st.info(" No resource data loaded. Load sample data to explore utilization metrics.")
            
            if st.button(" Load Sample Resource Data"):
                # Generate sample resource/utilization data
                np.random.seed(42)
                
                employees = []
                facilities = ['Clive', 'Bear Creek', 'Memphis', 'Barnwell', 'Erwin', 'Hittman', 'LWP', 'Corporate']
                departments = ['Operations', 'Engineering', 'Finance', 'HR', 'IT', 'Safety', 'Quality', 'Projects']
                job_titles = ['Engineer', 'Technician', 'Analyst', 'Manager', 'Specialist', 'Supervisor', 'Director']
                
                for i in range(75):
                    facility = np.random.choice(facilities)
                    dept = np.random.choice(departments)
                    
                    # Generate hours data
                    budgeted_hours = np.random.randint(1800, 2080)
                    ytd_hours = np.random.randint(800, 1600)
                    billable_hours = int(ytd_hours * np.random.uniform(0.5, 0.95))
                    
                    employees.append({
                        'Employee_ID': f"ES{1000+i}",
                        'Employee_Name': f"Employee {i+1}",
                        'Facility': facility,
                        'Department': dept,
                        'Job_Title': np.random.choice(job_titles),
                        'Labor_Category': np.random.choice(['Direct Labor', 'Indirect Labor', 'Overhead']),
                        'Hourly_Rate': round(np.random.uniform(35, 150), 2),
                        'Budgeted_Hours': budgeted_hours,
                        'YTD_Hours': ytd_hours,
                        'Billable_Hours': billable_hours,
                        'Non_Billable_Hours': ytd_hours - billable_hours,
                        'PTO_Hours': np.random.randint(0, 80),
                        'Overtime_Hours': np.random.randint(0, 100),
                        'Utilization_Target': 85.0,
                        'Status': 'Active'
                    })
                
                st.session_state.resource_data = pd.DataFrame(employees)
                
                # Generate timesheet data
                timesheets = []
                projects = [f"PRJ-{np.random.randint(1000,9999)}" for _ in range(20)]
                cost_centers = ['CC-100', 'CC-200', 'CC-300', 'CC-400', 'CC-500']
                
                for emp in employees[:30]:  # Generate timesheets for subset
                    for week in range(1, 45):  # 44 weeks of data
                        week_start = datetime(2025, 1, 6) + timedelta(weeks=week-1)
                        
                        # Random hours across projects
                        remaining_hours = np.random.randint(35, 45)
                        
                        for _ in range(np.random.randint(1, 4)):  # 1-3 projects per week
                            hours = min(remaining_hours, np.random.randint(8, 25))
                            remaining_hours -= hours
                            
                            timesheets.append({
                                'Employee_ID': emp['Employee_ID'],
                                'Week_Ending': week_start + timedelta(days=6),
                                'Project_ID': np.random.choice(projects),
                                'Cost_Center': np.random.choice(cost_centers),
                                'Charge_Type': np.random.choice(['Billable', 'Non-Billable'], p=[0.75, 0.25]),
                                'Work_Type': 'Regular',
                                'Hours': hours,
                                'Labor_Category': emp['Labor_Category'],
                                'Hourly_Rate': emp['Hourly_Rate'],
                                'Labor_Cost': round(hours * emp['Hourly_Rate'], 2)
                            })
                            
                            if remaining_hours <= 0:
                                break
                
                st.session_state.timesheet_data = pd.DataFrame(timesheets)
                st.success(f"Loaded {len(employees)} resources and {len(timesheets)} timesheet entries!")
                st.rerun()
        else:
            df = st.session_state.resource_data
            
            # KPI Row
            col1, col2, col3, col4, col5 = st.columns(5)
            
            total_employees = len(df[df['Status'] == 'Active']) if 'Status' in df.columns else len(df)
            total_ytd_hours = df['YTD_Hours'].sum() if 'YTD_Hours' in df.columns else 0
            total_billable = df['Billable_Hours'].sum() if 'Billable_Hours' in df.columns else 0
            avg_utilization = (total_billable / total_ytd_hours * 100) if total_ytd_hours > 0 else 0
            total_overtime = df['Overtime_Hours'].sum() if 'Overtime_Hours' in df.columns else 0
            
            with col1:
                st.metric("Total Resources", total_employees)
            with col2:
                st.metric("YTD Hours", f"{total_ytd_hours:,.0f}")
            with col3:
                st.metric("Billable Hours", f"{total_billable:,.0f}")
            with col4:
                delta_color = "normal" if avg_utilization >= 80 else "inverse"
                st.metric("Avg Utilization", f"{avg_utilization:.1f}%", 
                         delta=f"{avg_utilization - 85:.1f}% vs target")
            with col5:
                st.metric("Overtime Hours", f"{total_overtime:,.0f}")
            
            st.markdown("---")
            
            # Charts
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("#### Utilization by Facility")
                
                if 'Facility' in df.columns and 'Billable_Hours' in df.columns and 'YTD_Hours' in df.columns:
                    facility_util = df.groupby('Facility').agg({
                        'Billable_Hours': 'sum',
                        'YTD_Hours': 'sum'
                    })
                    facility_util['Utilization'] = (facility_util['Billable_Hours'] / facility_util['YTD_Hours'].replace(0, 1) * 100).round(1)
                    facility_util = facility_util.sort_values('Utilization', ascending=True)
                    
                    colors = ['#ef4444' if u < 75 else '#f59e0b' if u < 85 else '#22c55e' 
                             for u in facility_util['Utilization']]
                    
                    fig = go.Figure(go.Bar(
                        x=facility_util['Utilization'],
                        y=facility_util.index,
                        orientation='h',
                        marker_color=colors,
                        text=[f"{u:.1f}%" for u in facility_util['Utilization']],
                        textposition='outside'
                    ))
                    fig.add_vline(x=85, line_dash="dash", line_color="gray", 
                                 annotation_text="Target 85%")
                    fig.update_layout(height=300, margin=dict(l=20, r=60, t=20, b=20),
                                     xaxis_title='Utilization %', xaxis_range=[0, 110])
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.info("Missing required columns for utilization chart")
            
            with col2:
                st.markdown("#### Hours by Labor Category")
                
                if 'Labor_Category' in df.columns and 'YTD_Hours' in df.columns:
                    labor_hours = df.groupby('Labor_Category')['YTD_Hours'].sum()
                    
                    fig = go.Figure(go.Pie(
                        labels=labor_hours.index,
                        values=labor_hours.values,
                        hole=0.4
                    ))
                    fig.update_layout(height=300, margin=dict(l=20, r=20, t=20, b=20))
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.info("Missing required columns for hours chart")
            
            # Utilization detail table
            st.markdown("#### Resource Utilization Detail")
            
            # Build display columns based on what's available
            available_cols = [c for c in ['Employee_ID', 'Employee_Name', 'Facility', 'Department', 
                            'Budgeted_Hours', 'YTD_Hours', 'Billable_Hours', 'Overtime_Hours'] if c in df.columns]
            
            if available_cols:
                display_df = df[available_cols].copy()
                if 'Billable_Hours' in display_df.columns and 'YTD_Hours' in display_df.columns:
                    display_df['Utilization_%'] = (display_df['Billable_Hours'] / display_df['YTD_Hours'].replace(0, 1) * 100).round(1)
                if 'Budgeted_Hours' in display_df.columns and 'YTD_Hours' in display_df.columns:
                    display_df['Remaining_Hours'] = display_df['Budgeted_Hours'] - display_df['YTD_Hours']
                
                if 'Utilization_%' in display_df.columns:
                    st.dataframe(
                        display_df.style.background_gradient(subset=['Utilization_%'], cmap='RdYlGn', vmin=60, vmax=100),
                        use_container_width=True,
                        height=400
                    )
                else:
                    st.dataframe(display_df, use_container_width=True, height=400)
            else:
                st.dataframe(df, use_container_width=True, height=400)
    
    with tab2:
        st.caption("Allocate resources to projects and cost centers")
        
        if st.session_state.resource_data.empty:
            st.info("No resource data loaded yet.")
            if st.button(" Load Sample Resource Data", key="load_res_tab2"):
                # Generate sample resource data
                np.random.seed(42)
                employees = []
                facilities = ['Clive', 'Bear Creek', 'Memphis', 'Barnwell', 'Erwin', 'Hittman', 'LWP', 'Corporate']
                departments = ['Operations', 'Engineering', 'Finance', 'HR', 'IT', 'Safety', 'Quality', 'Projects']
                job_titles = ['Engineer', 'Technician', 'Analyst', 'Manager', 'Specialist', 'Supervisor', 'Director']
                
                for i in range(75):
                    facility = np.random.choice(facilities)
                    dept = np.random.choice(departments)
                    budgeted_hours = np.random.randint(1800, 2080)
                    ytd_hours = np.random.randint(800, 1600)
                    billable_hours = int(ytd_hours * np.random.uniform(0.5, 0.95))
                    
                    employees.append({
                        'Employee_ID': f"ES{1000+i}",
                        'Employee_Name': f"Employee {i+1}",
                        'Facility': facility,
                        'Department': dept,
                        'Job_Title': np.random.choice(job_titles),
                        'Labor_Category': np.random.choice(['Direct Labor', 'Indirect Labor', 'Overhead']),
                        'Hourly_Rate': round(np.random.uniform(35, 150), 2),
                        'Budgeted_Hours': budgeted_hours,
                        'YTD_Hours': ytd_hours,
                        'Billable_Hours': billable_hours,
                        'Non_Billable_Hours': ytd_hours - billable_hours,
                        'PTO_Hours': np.random.randint(0, 80),
                        'Overtime_Hours': np.random.randint(0, 100),
                        'Utilization_Target': 85.0,
                        'Status': 'Active'
                    })
                
                st.session_state.resource_data = pd.DataFrame(employees)
                st.success(f"Loaded {len(employees)} resources!")
                st.rerun()
        else:
            df = st.session_state.resource_data
            
            st.markdown("#### Resource Assignment Matrix")
            
            # Filters
            col1, col2, col3 = st.columns(3)
            with col1:
                fac_filter = st.multiselect("Facility", df['Facility'].unique())
            with col2:
                dept_filter = st.multiselect("Department", df['Department'].unique())
            with col3:
                avail_filter = st.selectbox("Availability", ['All', 'Under-utilized (<75%)', 'Available for OT'])
            
            filtered_df = df.copy()
            if fac_filter and 'Facility' in filtered_df.columns:
                filtered_df = filtered_df[filtered_df['Facility'].isin(fac_filter)]
            if dept_filter and 'Department' in filtered_df.columns:
                filtered_df = filtered_df[filtered_df['Department'].isin(dept_filter)]
            
            if 'Billable_Hours' in filtered_df.columns and 'YTD_Hours' in filtered_df.columns:
                filtered_df['Utilization_%'] = (filtered_df['Billable_Hours'] / filtered_df['YTD_Hours'].replace(0, 1) * 100).round(1)
            else:
                filtered_df['Utilization_%'] = 0
            
            if avail_filter == 'Under-utilized (<75%)':
                filtered_df = filtered_df[filtered_df['Utilization_%'] < 75]
            elif avail_filter == 'Available for OT' and 'Overtime_Hours' in filtered_df.columns:
                filtered_df = filtered_df[filtered_df['Overtime_Hours'] < 50]
            
            # Display with editing
            st.markdown(f"**{len(filtered_df)} resources matching filters**")
            
            display_cols = [c for c in ['Employee_ID', 'Employee_Name', 'Facility', 'Department', 
                           'Job_Title', 'Hourly_Rate', 'Utilization_%', 'Status'] if c in filtered_df.columns]
            
            edited_df = st.data_editor(
                filtered_df[display_cols] if display_cols else filtered_df,
                use_container_width=True,
                height=400,
                column_config={
                    'Hourly_Rate': st.column_config.NumberColumn('Rate', format="$%.2f"),
                    'Utilization_%': st.column_config.ProgressColumn('Utilization', min_value=0, max_value=100)
                }
            )
    
    with tab3:
        st.caption("Plan labor hours by project, cost center, and period")
        
        st.markdown("#### Hours Planning Matrix")
        
        # Create planning grid
        col1, col2 = st.columns(2)
        with col1:
            plan_year = st.selectbox("Planning Year", [2025, 2026, 2027])
            plan_view = st.selectbox("View By", ['Monthly', 'Quarterly', 'Annual'])
        with col2:
            plan_type = st.selectbox("Plan Type", ['By Project', 'By Cost Center', 'By Resource'])
        
        # Generate sample planning data
        if plan_view == 'Monthly':
            periods = MONTHS
        elif plan_view == 'Quarterly':
            periods = ['Q1', 'Q2', 'Q3', 'Q4']
        else:
            periods = [str(plan_year)]
        
        # Sample planning matrix
        if plan_type == 'By Project':
            rows = [f"PRJ-{1000+i}" for i in range(10)]
        elif plan_type == 'By Cost Center':
            rows = ['CC-100', 'CC-200', 'CC-300', 'CC-400', 'CC-500']
        else:
            rows = [f"ES{1000+i}" for i in range(10)]
        
        plan_data = {plan_type.split()[-1]: rows}
        for period in periods:
            plan_data[period] = [np.random.randint(100, 500) for _ in rows]
        
        plan_df = pd.DataFrame(plan_data)
        plan_df['Total'] = plan_df[periods].sum(axis=1)
        
        edited_plan = st.data_editor(plan_df, use_container_width=True, num_rows="dynamic")
        
        col1, col2 = st.columns([1, 5])
        with col1:
            if st.button(" Save Plan"):
                st.success("Hours plan saved!")
    
    with tab4:
        st.caption("Enter and manage timesheet data")
        
        if st.session_state.timesheet_data.empty:
            st.info("No timesheet data loaded yet.")
            if st.button(" Load Sample Timesheet Data", key="load_ts_entry"):
                # Generate sample timesheet data
                np.random.seed(42)
                timesheets = []
                projects = [f"PRJ-{np.random.randint(1000,9999)}" for _ in range(20)]
                cost_centers = ['CC-100', 'CC-200', 'CC-300', 'CC-400', 'CC-500']
                
                for emp_idx in range(30):
                    emp_id = f"ES{1000+emp_idx}"
                    hourly_rate = round(np.random.uniform(35, 150), 2)
                    labor_cat = np.random.choice(['Direct Labor', 'Indirect Labor', 'Overhead'])
                    
                    for week in range(1, 45):
                        week_start = datetime(2025, 1, 6) + timedelta(weeks=week-1)
                        remaining_hours = np.random.randint(35, 45)
                        
                        for _ in range(np.random.randint(1, 4)):
                            hours = min(remaining_hours, np.random.randint(8, 25))
                            remaining_hours -= hours
                            
                            timesheets.append({
                                'Employee_ID': emp_id,
                                'Week_Ending': week_start + timedelta(days=6),
                                'Project_ID': np.random.choice(projects),
                                'Cost_Center': np.random.choice(cost_centers),
                                'Charge_Type': np.random.choice(['Billable', 'Non-Billable'], p=[0.75, 0.25]),
                                'Work_Type': 'Regular',
                                'Hours': hours,
                                'Labor_Category': labor_cat,
                                'Hourly_Rate': hourly_rate,
                                'Labor_Cost': round(hours * hourly_rate, 2)
                            })
                            
                            if remaining_hours <= 0:
                                break
                
                st.session_state.timesheet_data = pd.DataFrame(timesheets)
                st.success(f"Loaded {len(timesheets)} timesheet entries!")
                st.rerun()
        else:
            ts_df = st.session_state.timesheet_data
            
            # Timesheet filters
            col1, col2, col3 = st.columns(3)
            with col1:
                emp_filter = st.selectbox("Employee", ['All'] + list(ts_df['Employee_ID'].unique()[:20]))
            with col2:
                week_options = ts_df['Week_Ending'].dt.strftime('%Y-%m-%d').unique()
                week_filter = st.selectbox("Week Ending", ['All'] + list(week_options[:12]))
            with col3:
                proj_filter = st.selectbox("Project", ['All'] + list(ts_df['Project_ID'].unique()))
            
            filtered_ts = ts_df.copy()
            if emp_filter != 'All':
                filtered_ts = filtered_ts[filtered_ts['Employee_ID'] == emp_filter]
            if week_filter != 'All':
                filtered_ts = filtered_ts[filtered_ts['Week_Ending'].dt.strftime('%Y-%m-%d') == week_filter]
            if proj_filter != 'All':
                filtered_ts = filtered_ts[filtered_ts['Project_ID'] == proj_filter]
            
            st.markdown(f"**{len(filtered_ts)} timesheet entries**")
            
            st.dataframe(
                filtered_ts[['Employee_ID', 'Week_Ending', 'Project_ID', 'Cost_Center', 
                            'Charge_Type', 'Hours', 'Hourly_Rate', 'Labor_Cost']],
                use_container_width=True,
                height=400,
                column_config={
                    'Week_Ending': st.column_config.DateColumn('Week Ending'),
                    'Hourly_Rate': st.column_config.NumberColumn('Rate', format="$%.2f"),
                    'Labor_Cost': st.column_config.NumberColumn('Cost', format="$%.2f")
                }
            )
            
            # Summary
            st.markdown("---")
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Total Hours", f"{filtered_ts['Hours'].sum():,.0f}")
            with col2:
                st.metric("Total Labor Cost", f"${filtered_ts['Labor_Cost'].sum():,.0f}")
            with col3:
                billable_pct = filtered_ts[filtered_ts['Charge_Type'] == 'Billable']['Hours'].sum() / filtered_ts['Hours'].sum() * 100 if len(filtered_ts) > 0 else 0
                st.metric("Billable %", f"{billable_pct:.1f}%")
    
    with tab5:
        st.caption("Submit employee timesheets for batch approval")
        
        # Generate sample timesheet data if needed
        if st.session_state.timesheet_approvals.empty and not st.session_state.resource_data.empty:
            # Check if required columns exist
            resource_df = st.session_state.resource_data
            has_required = 'Employee_ID' in resource_df.columns or 'Employee_Name' in resource_df.columns
            
            if has_required:
                np.random.seed(42)
                employees = resource_df.head(20)
                
                approval_data = []
                period_endings = [
                    datetime(2023, 8, 18),
                    datetime(2023, 8, 25),
                    datetime(2023, 9, 1),
                    datetime(2023, 9, 8)
                ]
                
                for period_end in period_endings:
                    for idx, emp in employees.iterrows():
                        regular_hours = np.random.uniform(35, 45)
                        overtime_hours = np.random.uniform(0, 8) if np.random.random() > 0.7 else 0
                        
                        emp_id = emp.get('Employee_ID', f"EMP{idx}")
                        emp_name = emp.get('Employee_Name', f"Employee {idx}")
                        
                        approval_data.append({
                            'Timesheet_ID': f"TS-{emp_id}-{period_end.strftime('%Y%m%d')}",
                            'Employee_ID': emp_id,
                            'Employee_Name': emp_name,
                            'Employee_Class': np.random.choice(['REG HNE', 'REG SE', 'REG CL', 'EXEMPT']),
                            'Schedule': 'ES-SF',
                            'Period_Ending': period_end,
                            'Revision': 1,
                            'Regular_Hours': round(regular_hours, 2),
                            'Overtime_Hours': round(overtime_hours, 2),
                            'Total_Hours': round(regular_hours + overtime_hours, 2),
                            'Status': np.random.choice(['Draft', 'Pending Approval', 'Approved', 'Rejected'], p=[0.2, 0.4, 0.3, 0.1]),
                            'Submitted_Date': period_end + timedelta(days=1) if np.random.random() > 0.2 else None,
                            'Submitted_By': emp_name,
                            'Approver': f"Manager {np.random.randint(1, 10)}",
                            'Approver_ID': f"{108000 + np.random.randint(1, 500)}",
                            'Approval_Date': period_end + timedelta(days=int(np.random.randint(1, 5))) if np.random.random() > 0.4 else None
                        })
                
                st.session_state.timesheet_approvals = pd.DataFrame(approval_data)
        
        # Batch Approval Interface
        st.markdown("### Timesheet Batch Approval")
        
        if st.session_state.timesheet_approvals.empty:
            st.info("No timesheet approval data loaded. Click below to generate sample timesheets.")
            
            if st.button(" Generate Sample Timesheets"):
                # Create sample data without resource data
                np.random.seed(42)
                sample_employees = [
                    ('109344', 'Gabaldon, Arthur P', 'REG HNE'),
                    ('108995', 'Molina, Kelvin H', 'REG SE'),
                    ('109001', 'Johnson, Sarah M', 'REG CL'),
                    ('109022', 'Williams, Robert T', 'EXEMPT'),
                    ('109045', 'Garcia, Maria L', 'REG HNE'),
                    ('109067', 'Brown, James K', 'REG SE'),
                    ('109089', 'Davis, Jennifer A', 'REG CL'),
                    ('109101', 'Miller, David W', 'EXEMPT'),
                    ('109123', 'Wilson, Amanda R', 'REG HNE'),
                    ('109145', 'Anderson, Michael S', 'REG SE'),
                ]
                
                approval_data = []
                period_endings = [
                    datetime(2023, 8, 18),
                    datetime(2023, 8, 25),
                    datetime(2023, 9, 1),
                ]
                
                for period_end in period_endings:
                    for emp_id, emp_name, emp_class in sample_employees:
                        regular_hours = np.random.uniform(35, 45)
                        overtime_hours = np.random.uniform(0, 8) if np.random.random() > 0.7 else 0
                        
                        approval_data.append({
                            'Timesheet_ID': f"TS-{emp_id}-{period_end.strftime('%Y%m%d')}",
                            'Employee_ID': emp_id,
                            'Employee_Name': emp_name,
                            'Employee_Class': emp_class,
                            'Schedule': 'ES-SF',
                            'Period_Ending': period_end,
                            'Revision': 1,
                            'Regular_Hours': round(regular_hours, 2),
                            'Overtime_Hours': round(overtime_hours, 2),
                            'Total_Hours': round(regular_hours + overtime_hours, 2),
                            'Status': np.random.choice(['Draft', 'Pending Approval', 'Approved', 'Rejected'], p=[0.3, 0.4, 0.2, 0.1]),
                            'Submitted_Date': period_end + timedelta(days=1) if np.random.random() > 0.3 else None,
                            'Submitted_By': emp_name,
                            'Approver': np.random.choice(['Livingston, Davi S', 'Fuller, Stephen R', 'Thompson, Mark J']),
                            'Approver_ID': f"{108000 + np.random.randint(200, 300)}",
                            'Approval_Date': period_end + timedelta(days=int(np.random.randint(1, 5))) if np.random.random() > 0.5 else None
                        })
                
                st.session_state.timesheet_approvals = pd.DataFrame(approval_data)
                st.success("Generated 30 sample timesheets!")
                st.rerun()
        else:
            ts_approvals = st.session_state.timesheet_approvals
            
            # Summary metrics
            col1, col2, col3, col4, col5 = st.columns(5)
            
            with col1:
                st.metric("Total Timesheets", len(ts_approvals))
            with col2:
                draft_count = len(ts_approvals[ts_approvals['Status'] == 'Draft'])
                st.metric("Draft", draft_count)
            with col3:
                pending_count = len(ts_approvals[ts_approvals['Status'] == 'Pending Approval'])
                st.metric("Pending Approval", pending_count)
            with col4:
                approved_count = len(ts_approvals[ts_approvals['Status'] == 'Approved'])
                st.metric("Approved", approved_count)
            with col5:
                rejected_count = len(ts_approvals[ts_approvals['Status'] == 'Rejected'])
                st.metric("Rejected", rejected_count)
            
            st.markdown("---")
            
            # Filters
            col1, col2, col3 = st.columns(3)
            
            with col1:
                period_filter = st.selectbox(
                    "Period Ending",
                    ['All'] + sorted(ts_approvals['Period_Ending'].dt.strftime('%Y-%m-%d').unique().tolist(), reverse=True)
                )
            with col2:
                status_filter = st.multiselect(
                    "Status",
                    ts_approvals['Status'].unique().tolist(),
                    default=['Draft', 'Pending Approval']
                )
            with col3:
                class_filter = st.multiselect(
                    "Employee Class",
                    ts_approvals['Employee_Class'].unique().tolist()
                )
            
            # Filter data
            filtered_ts = ts_approvals.copy()
            if period_filter != 'All':
                filtered_ts = filtered_ts[filtered_ts['Period_Ending'].dt.strftime('%Y-%m-%d') == period_filter]
            if status_filter:
                filtered_ts = filtered_ts[filtered_ts['Status'].isin(status_filter)]
            if class_filter:
                filtered_ts = filtered_ts[filtered_ts['Employee_Class'].isin(class_filter)]
            
            st.markdown(f"**{len(filtered_ts)} timesheets**")
            
            # Selectable dataframe
            st.markdown("#### Select Timesheets for Batch Action")
            
            display_df = filtered_ts[['Timesheet_ID', 'Employee_ID', 'Employee_Name', 'Employee_Class', 
                                      'Period_Ending', 'Regular_Hours', 'Overtime_Hours', 'Total_Hours', 
                                      'Status', 'Approver']].copy()
            display_df['Select'] = False
            
            # Move Select to first column
            cols = ['Select'] + [c for c in display_df.columns if c != 'Select']
            display_df = display_df[cols]
            
            edited_df = st.data_editor(
                display_df,
                use_container_width=True,
                height=400,
                column_config={
                    'Select': st.column_config.CheckboxColumn('Select', default=False),
                    'Period_Ending': st.column_config.DateColumn('Period Ending'),
                    'Regular_Hours': st.column_config.NumberColumn('Regular', format="%.2f"),
                    'Overtime_Hours': st.column_config.NumberColumn('OT', format="%.2f"),
                    'Total_Hours': st.column_config.NumberColumn('Total', format="%.2f")
                },
                disabled=['Timesheet_ID', 'Employee_ID', 'Employee_Name', 'Employee_Class',
                         'Period_Ending', 'Regular_Hours', 'Overtime_Hours', 'Total_Hours', 
                         'Status', 'Approver']
            )
            
            selected_ids = edited_df[edited_df['Select'] == True]['Timesheet_ID'].tolist()
            
            st.markdown("---")
            
            # Batch actions
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                if st.button(" Submit for Approval", type="primary", disabled=len(selected_ids) == 0):
                    # Update status to Pending Approval
                    mask = st.session_state.timesheet_approvals['Timesheet_ID'].isin(selected_ids)
                    st.session_state.timesheet_approvals.loc[mask, 'Status'] = 'Pending Approval'
                    st.session_state.timesheet_approvals.loc[mask, 'Submitted_Date'] = datetime.now()
                    st.success(f" Submitted {len(selected_ids)} timesheets for approval!")
                    st.rerun()
            
            with col2:
                if st.button(" Approve Selected", disabled=len(selected_ids) == 0):
                    mask = st.session_state.timesheet_approvals['Timesheet_ID'].isin(selected_ids)
                    st.session_state.timesheet_approvals.loc[mask, 'Status'] = 'Approved'
                    st.session_state.timesheet_approvals.loc[mask, 'Approval_Date'] = datetime.now()
                    st.success(f" Approved {len(selected_ids)} timesheets!")
                    st.rerun()
            
            with col3:
                if st.button(" Reject Selected", disabled=len(selected_ids) == 0):
                    mask = st.session_state.timesheet_approvals['Timesheet_ID'].isin(selected_ids)
                    st.session_state.timesheet_approvals.loc[mask, 'Status'] = 'Rejected'
                    st.success(f" Rejected {len(selected_ids)} timesheets")
                    st.rerun()
            
            with col4:
                export_format = st.selectbox("Export Format", ["PDF", "Excel"], key="export_format")
            
            if selected_ids:
                st.info(f" {len(selected_ids)} timesheet(s) selected")
                
                if export_format == "PDF":
                    st.markdown("#### Download Individual PDFs")
                    
                    # Get selected timesheet data
                    selected_ts = ts_approvals[ts_approvals['Timesheet_ID'].isin(selected_ids)]
                    
                    # Create download buttons for each timesheet
                    for idx, (_, ts_row) in enumerate(selected_ts.iterrows()):
                        ts_dict = ts_row.to_dict()
                        
                        # Create filename matching EnergySolutions format: WE_MMDDYYYY_EmpID_Name.pdf
                        period_str = ts_dict['Period_Ending'].strftime('%m%d%Y') if hasattr(ts_dict['Period_Ending'], 'strftime') else str(ts_dict['Period_Ending'])[:10].replace('-', '')
                        emp_id = ts_dict.get('Employee_ID', 'unknown')
                        emp_name = ts_dict.get('Employee_Name', 'Unknown').split(',')[0]  # Last name only
                        
                        filename = f"WE_{period_str}_{emp_id}_{emp_name}.pdf"
                        
                        col1, col2 = st.columns([3, 1])
                        
                        with col1:
                            st.write(f" {ts_dict.get('Employee_Name', 'Unknown')} - {ts_dict['Period_Ending'].strftime('%b %d, %Y') if hasattr(ts_dict['Period_Ending'], 'strftime') else ts_dict['Period_Ending']}")
                        
                        with col2:
                            try:
                                pdf_buffer = generate_timesheet_pdf(ts_dict)
                                st.download_button(
                                    " PDF",
                                    data=pdf_buffer,
                                    file_name=filename,
                                    mime="application/pdf",
                                    key=f"pdf_download_{idx}_{ts_dict.get('Timesheet_ID', idx)}"
                                )
                            except Exception as e:
                                st.error(f"Error: {e}")
                    
                    st.markdown("---")
                else:
                    # Excel export
                    export_df = ts_approvals[ts_approvals['Timesheet_ID'].isin(selected_ids)]
                    output = io.BytesIO()
                    export_df.to_excel(output, index=False)
                    output.seek(0)
                    st.download_button(
                        " Download Excel",
                        data=output,
                        file_name=f"timesheets_batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    )
    
    with tab6:
        st.caption("Analyze labor costs, trends, and productivity")
        
        if st.session_state.timesheet_data.empty:
            st.info("No timesheet data loaded yet.")
            if st.button(" Load Sample Timesheet Data", key="load_ts_analytics"):
                # Generate sample timesheet data
                np.random.seed(42)
                timesheets = []
                projects = [f"PRJ-{np.random.randint(1000,9999)}" for _ in range(20)]
                cost_centers = ['CC-100', 'CC-200', 'CC-300', 'CC-400', 'CC-500']
                
                for emp_idx in range(30):
                    emp_id = f"ES{1000+emp_idx}"
                    hourly_rate = round(np.random.uniform(35, 150), 2)
                    labor_cat = np.random.choice(['Direct Labor', 'Indirect Labor', 'Overhead'])
                    
                    for week in range(1, 45):
                        week_start = datetime(2025, 1, 6) + timedelta(weeks=week-1)
                        remaining_hours = np.random.randint(35, 45)
                        
                        for _ in range(np.random.randint(1, 4)):
                            hours = min(remaining_hours, np.random.randint(8, 25))
                            remaining_hours -= hours
                            
                            timesheets.append({
                                'Employee_ID': emp_id,
                                'Week_Ending': week_start + timedelta(days=6),
                                'Project_ID': np.random.choice(projects),
                                'Cost_Center': np.random.choice(cost_centers),
                                'Charge_Type': np.random.choice(['Billable', 'Non-Billable'], p=[0.75, 0.25]),
                                'Work_Type': 'Regular',
                                'Hours': hours,
                                'Labor_Category': labor_cat,
                                'Hourly_Rate': hourly_rate,
                                'Labor_Cost': round(hours * hourly_rate, 2)
                            })
                            
                            if remaining_hours <= 0:
                                break
                
                st.session_state.timesheet_data = pd.DataFrame(timesheets)
                st.success(f"Loaded {len(timesheets)} timesheet entries!")
                st.rerun()
        else:
            ts_df = st.session_state.timesheet_data
            
            # Weekly trend
            st.markdown("#### Weekly Hours Trend")
            
            weekly_hours = ts_df.groupby('Week_Ending').agg({
                'Hours': 'sum',
                'Labor_Cost': 'sum'
            }).reset_index()
            weekly_hours = weekly_hours.sort_values('Week_Ending')
            
            fig = make_subplots(specs=[[{"secondary_y": True}]])
            
            fig.add_trace(
                go.Bar(x=weekly_hours['Week_Ending'], y=weekly_hours['Hours'], 
                      name='Hours', marker_color='#3b82f6'),
                secondary_y=False
            )
            fig.add_trace(
                go.Scatter(x=weekly_hours['Week_Ending'], y=weekly_hours['Labor_Cost'],
                          name='Labor Cost', line=dict(color='#ef4444', width=2)),
                secondary_y=True
            )
            
            fig.update_layout(height=350, legend=dict(orientation='h', yanchor='bottom', y=1.02))
            fig.update_yaxes(title_text="Hours", secondary_y=False)
            fig.update_yaxes(title_text="Labor Cost ($)", secondary_y=True)
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Cost by project
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("#### Labor Cost by Project")
                proj_cost = ts_df.groupby('Project_ID')['Labor_Cost'].sum().sort_values(ascending=False).head(10)
                
                fig = go.Figure(go.Bar(
                    x=proj_cost.values,
                    y=proj_cost.index,
                    orientation='h',
                    marker_color='#3b82f6'
                ))
                fig.update_layout(height=300, margin=dict(l=20, r=20, t=20, b=20),
                                 xaxis_title='Labor Cost ($)')
                st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                st.markdown("#### Billable vs Non-Billable")
                charge_hours = ts_df.groupby('Charge_Type')['Hours'].sum()
                
                fig = go.Figure(go.Pie(
                    labels=charge_hours.index,
                    values=charge_hours.values,
                    hole=0.4,
                    marker_colors=['#22c55e', '#ef4444']
                ))
                fig.update_layout(height=300, margin=dict(l=20, r=20, t=20, b=20))
                st.plotly_chart(fig, use_container_width=True)


# =============================================================================
# PAGE: CASH FLOW MANAGEMENT
# =============================================================================

elif page == " Cash Flow":
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        " Cash Dashboard", 
        " Weekly Forecast",
        " AR/AP Management", 
        " Bank Reconciliation",
        " Cash Analytics"
    ])
    
    # Initialize cash flow data
    if 'cash_flow_data' not in st.session_state:
        st.session_state.cash_flow_data = pd.DataFrame()
    if 'ar_data' not in st.session_state:
        st.session_state.ar_data = pd.DataFrame()
    if 'ap_data' not in st.session_state:
        st.session_state.ap_data = pd.DataFrame()
    
    with tab1:
        st.caption("Monitor cash position and forecast liquidity")
        
        if st.session_state.cash_flow_data.empty:
            st.info(" No cash flow data loaded. Load sample data to explore cash management.")
            
            if st.button(" Load Sample Cash Flow Data"):
                np.random.seed(42)
                
                # Generate weekly cash flow data
                cash_data = []
                starting_balance = 45000000  # $45M starting cash
                running_balance = starting_balance
                
                start_date = datetime(2025, 1, 6)
                
                for week in range(52):
                    week_start = start_date + timedelta(weeks=week)
                    week_end = week_start + timedelta(days=6)
                    
                    # Inflows
                    customer_receipts = np.random.uniform(3000000, 8000000)
                    ndt_draws = np.random.uniform(500000, 2000000) if np.random.random() > 0.5 else 0
                    other_receipts = np.random.uniform(50000, 300000)
                    
                    total_inflows = customer_receipts + ndt_draws + other_receipts
                    
                    # Outflows
                    payroll = np.random.uniform(2500000, 4000000) if week % 2 == 0 else 0
                    vendor_payments = np.random.uniform(1000000, 3500000)
                    subcontractor = np.random.uniform(500000, 2000000)
                    capex_payments = np.random.uniform(100000, 800000) if np.random.random() > 0.6 else 0
                    taxes = np.random.uniform(200000, 500000) if week % 4 == 0 else 0
                    other_payments = np.random.uniform(50000, 200000)
                    
                    total_outflows = payroll + vendor_payments + subcontractor + capex_payments + taxes + other_payments
                    
                    net_change = total_inflows - total_outflows
                    running_balance += net_change
                    
                    cash_data.append({
                        'Week_Number': week + 1,
                        'Week_Start': week_start,
                        'Week_End': week_end,
                        'Beginning_Balance': running_balance - net_change,
                        'Customer_Receipts': round(customer_receipts, 2),
                        'NDT_Draws': round(ndt_draws, 2),
                        'Other_Receipts': round(other_receipts, 2),
                        'Total_Inflows': round(total_inflows, 2),
                        'Payroll': round(payroll, 2),
                        'Vendor_Payments': round(vendor_payments, 2),
                        'Subcontractor': round(subcontractor, 2),
                        'CapEx_Payments': round(capex_payments, 2),
                        'Taxes': round(taxes, 2),
                        'Other_Payments': round(other_payments, 2),
                        'Total_Outflows': round(total_outflows, 2),
                        'Net_Change': round(net_change, 2),
                        'Ending_Balance': round(running_balance, 2),
                        'Status': 'Actual' if week < 44 else 'Forecast'
                    })
                
                st.session_state.cash_flow_data = pd.DataFrame(cash_data)
                
                # Generate AR data
                ar_data = []
                customers = ['DOE - Idaho', 'DOE - Hanford', 'Exelon', 'Duke Energy', 'TVA', 
                            'Dominion', 'Southern Company', 'Entergy', 'PSEG', 'Xcel Energy']
                
                for i in range(50):
                    invoice_date = datetime(2025, 1, 1) + timedelta(days=int(np.random.randint(0, 300)))
                    due_date = invoice_date + timedelta(days=int(np.random.choice([30, 45, 60, 90])))
                    amount = np.random.uniform(50000, 2000000)
                    
                    days_outstanding = (datetime.now() - invoice_date).days
                    
                    if days_outstanding < 30:
                        aging = 'Current'
                    elif days_outstanding < 60:
                        aging = '31-60 Days'
                    elif days_outstanding < 90:
                        aging = '61-90 Days'
                    else:
                        aging = '90+ Days'
                    
                    paid = np.random.random() > 0.4
                    
                    ar_data.append({
                        'Invoice_ID': f"INV-{2025}{i+1:04d}",
                        'Customer': np.random.choice(customers),
                        'Contract_ID': f"CTR-{np.random.randint(100, 999)}",
                        'Invoice_Date': invoice_date,
                        'Due_Date': due_date,
                        'Amount': round(amount, 2),
                        'Paid_Amount': round(amount, 2) if paid else round(amount * np.random.uniform(0, 0.5), 2),
                        'Balance': 0 if paid else round(amount * np.random.uniform(0.5, 1), 2),
                        'Days_Outstanding': days_outstanding,
                        'Aging_Bucket': aging,
                        'Status': 'Paid' if paid else 'Open'
                    })
                
                st.session_state.ar_data = pd.DataFrame(ar_data)
                
                # Generate AP data
                ap_data = []
                vendors = ['Equipment Corp', 'Safety Supplies Inc', 'Transport LLC', 'Tech Services',
                          'Materials Co', 'Consulting Group', 'Lab Services', 'Training Inc']
                
                for i in range(40):
                    invoice_date = datetime(2025, 1, 1) + timedelta(days=int(np.random.randint(0, 300)))
                    due_date = invoice_date + timedelta(days=int(np.random.choice([30, 45, 60])))
                    amount = np.random.uniform(10000, 500000)
                    
                    paid = np.random.random() > 0.5
                    
                    ap_data.append({
                        'Invoice_ID': f"AP-{2025}{i+1:04d}",
                        'Vendor': np.random.choice(vendors),
                        'PO_Number': f"PO-{np.random.randint(10000, 99999)}",
                        'Invoice_Date': invoice_date,
                        'Due_Date': due_date,
                        'Amount': round(amount, 2),
                        'Paid_Amount': round(amount, 2) if paid else 0,
                        'Balance': 0 if paid else round(amount, 2),
                        'Payment_Terms': np.random.choice(['Net 30', 'Net 45', 'Net 60']),
                        'Status': 'Paid' if paid else 'Open'
                    })
                
                st.session_state.ap_data = pd.DataFrame(ap_data)
                
                st.success("Loaded 52 weeks of cash flow data, 50 AR invoices, and 40 AP invoices!")
                st.rerun()
        else:
            df = st.session_state.cash_flow_data
            current_week = 44  # Assume we're in week 44
            
            # Handle both column naming conventions
            week_col = 'Week_Number' if 'Week_Number' in df.columns else 'Week'
            week_end_col = 'Week_End' if 'Week_End' in df.columns else 'Week_Ending'
            
            # Current week data
            if week_col in df.columns and current_week <= len(df):
                current_data = df[df[week_col] == current_week].iloc[0] if not df[df[week_col] == current_week].empty else df.iloc[-1]
            else:
                current_data = df.iloc[-1]
            
            # KPI Row
            col1, col2, col3, col4, col5 = st.columns(5)
            
            with col1:
                st.metric("Current Cash", f"${current_data['Ending_Balance']/1e6:.1f}M")
            with col2:
                st.metric("Weekly Inflows", f"${current_data['Total_Inflows']/1e6:.1f}M")
            with col3:
                st.metric("Weekly Outflows", f"${current_data['Total_Outflows']/1e6:.1f}M")
            with col4:
                net = current_data['Net_Change']
                st.metric("Net Change", f"${net/1e6:+.1f}M", 
                         delta=f"{'Positive' if net > 0 else 'Negative'}")
            with col5:
                ar_balance = st.session_state.ar_data[st.session_state.ar_data['Status'] == 'Open']['Balance'].sum() if not st.session_state.ar_data.empty else 0
                st.metric("AR Outstanding", f"${ar_balance/1e6:.1f}M")
            
            st.markdown("---")
            
            # Cash trend chart
            col1, col2 = st.columns([2, 1])
            
            with col1:
                st.markdown("#### Cash Position Trend")
                
                fig = go.Figure()
                
                # Handle both data formats
                if 'Status' in df.columns:
                    actual_df = df[df['Status'] == 'Actual']
                    forecast_df = df[df['Status'] == 'Forecast']
                    
                    if week_end_col in df.columns:
                        fig.add_trace(go.Scatter(
                            x=actual_df[week_end_col],
                            y=actual_df['Ending_Balance'] / 1e6,
                            name='Actual',
                            line=dict(color='#3b82f6', width=2),
                            fill='tozeroy',
                            fillcolor='rgba(59, 130, 246, 0.1)'
                        ))
                        
                        fig.add_trace(go.Scatter(
                            x=forecast_df[week_end_col],
                            y=forecast_df['Ending_Balance'] / 1e6,
                            name='Forecast',
                            line=dict(color='#f59e0b', width=2, dash='dash')
                        ))
                else:
                    # Simple plot for data without Status column
                    fig.add_trace(go.Scatter(
                        x=df[week_end_col] if week_end_col in df.columns else df.index,
                        y=df['Ending_Balance'] / 1e6,
                        name='Cash Balance',
                        line=dict(color='#3b82f6', width=2),
                        fill='tozeroy',
                        fillcolor='rgba(59, 130, 246, 0.1)'
                    ))
                
                fig.add_hline(y=20, line_dash="dot", line_color="red",
                             annotation_text="Min Cash $20M")
                
                fig.update_layout(
                    height=350,
                    xaxis_title='',
                    yaxis_title='Cash Balance ($M)',
                    legend=dict(orientation='h', yanchor='bottom', y=1.02)
                )
                st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                st.markdown("#### Inflows vs Outflows")
                
                recent_weeks = df.tail(8)
                x_col = week_col if week_col in df.columns else df.index[-8:]
                
                fig = go.Figure()
                fig.add_trace(go.Bar(
                    x=recent_weeks[week_col] if week_col in recent_weeks.columns else list(range(len(recent_weeks))),
                    y=recent_weeks['Total_Inflows'] / 1e6,
                    name='Inflows',
                    marker_color='#22c55e'
                ))
                fig.add_trace(go.Bar(
                    x=recent_weeks[week_col] if week_col in recent_weeks.columns else list(range(len(recent_weeks))),
                    y=-recent_weeks['Total_Outflows'] / 1e6,
                    name='Outflows',
                    marker_color='#ef4444'
                ))
                
                fig.update_layout(
                    height=350,
                    barmode='relative',
                    xaxis_title='Week',
                    yaxis_title='Amount ($M)',
                    legend=dict(orientation='h', yanchor='bottom', y=1.02)
                )
                st.plotly_chart(fig, use_container_width=True)
    
    with tab2:
        st.caption("13-week rolling cash forecast")
        
        if st.session_state.cash_flow_data.empty:
            st.info("No cash flow data loaded yet.")
            if st.button(" Load Sample Cash Flow Data", key="load_cf_tab2"):
                np.random.seed(42)
                cash_data = []
                running_balance = 45000000
                start_date = datetime(2025, 1, 6)
                
                for week in range(52):
                    week_start = start_date + timedelta(weeks=week)
                    customer_receipts = np.random.uniform(3000000, 8000000)
                    ndt_draws = np.random.uniform(500000, 2000000) if np.random.random() > 0.5 else 0
                    other_receipts = np.random.uniform(50000, 300000)
                    total_inflows = customer_receipts + ndt_draws + other_receipts
                    payroll = np.random.uniform(2500000, 4000000) if week % 2 == 0 else 0
                    vendor_payments = np.random.uniform(1000000, 3500000)
                    subcontractor = np.random.uniform(500000, 2000000)
                    capex_payments = np.random.uniform(100000, 800000) if np.random.random() > 0.6 else 0
                    total_outflows = payroll + vendor_payments + subcontractor + capex_payments
                    net_change = total_inflows - total_outflows
                    running_balance += net_change
                    
                    cash_data.append({
                        'Week_Number': week + 1, 'Week_Start': week_start,
                        'Beginning_Balance': running_balance - net_change,
                        'Customer_Receipts': round(customer_receipts, 2),
                        'NDT_Draws': round(ndt_draws, 2),
                        'Other_Receipts': round(other_receipts, 2),
                        'Payroll': round(payroll, 2),
                        'Vendor_Payments': round(vendor_payments, 2),
                        'Subcontractor': round(subcontractor, 2),
                        'CapEx_Payments': round(capex_payments, 2),
                        'Ending_Balance': round(running_balance, 2)
                    })
                
                st.session_state.cash_flow_data = pd.DataFrame(cash_data)
                st.success("Loaded 52 weeks of cash flow data!")
                st.rerun()
        else:
            df = st.session_state.cash_flow_data
            
            st.markdown("#### 13-Week Cash Forecast")
            
            # Handle column naming variations
            week_col = 'Week_Number' if 'Week_Number' in df.columns else 'Week'
            
            forecast_start = 40
            if week_col in df.columns:
                forecast_df = df[(df[week_col] >= forecast_start) & (df[week_col] < forecast_start + 13)].copy()
            else:
                forecast_df = df.tail(13).copy()
            
            # Build display columns based on what's available
            base_cols = [week_col]
            if 'Week_Start' in df.columns:
                base_cols.append('Week_Start')
            
            value_cols = ['Beginning_Balance', 'Customer_Receipts', 'NDT_Draws', 'Other_Receipts',
                         'Payroll', 'Vendor_Payments', 'Subcontractor', 'CapEx_Payments', 'Ending_Balance']
            
            # Handle alternative column names
            col_mapping = {
                'NDT_Draws': ['NDT_Draws', 'Retainage_Releases'],
                'Other_Receipts': ['Other_Receipts', 'Other_Inflows'],
                'Subcontractor': ['Subcontractor', 'Subcontractor_Payments']
            }
            
            available_cols = base_cols.copy()
            for col in value_cols:
                if col in df.columns:
                    available_cols.append(col)
                elif col in col_mapping:
                    for alt in col_mapping[col]:
                        if alt in df.columns:
                            available_cols.append(alt)
                            break
            
            if forecast_df.empty:
                st.warning("No forecast data available for the selected period.")
            else:
                display_df = forecast_df[[c for c in available_cols if c in forecast_df.columns]].copy()
                
                # Round numeric columns
                for col in display_df.columns:
                    if display_df[col].dtype in ['float64', 'int64']:
                        display_df[col] = display_df[col].round(0)
                
                edited_forecast = st.data_editor(
                    display_df,
                    use_container_width=True,
                    column_config={
                        'Week_Start': st.column_config.DateColumn('Week Of'),
                        'Beginning_Balance': st.column_config.NumberColumn('Opening', format="$%.0f"),
                        'Customer_Receipts': st.column_config.NumberColumn('Customer $', format="$%.0f"),
                        'NDT_Draws': st.column_config.NumberColumn('NDT Draws', format="$%.0f"),
                        'Payroll': st.column_config.NumberColumn('Payroll', format="$%.0f"),
                        'Vendor_Payments': st.column_config.NumberColumn('Vendors', format="$%.0f"),
                        'Ending_Balance': st.column_config.NumberColumn('Closing', format="$%.0f"),
                    },
                    disabled=[week_col, 'Week_Start', 'Beginning_Balance', 'Ending_Balance']
                )
                
                col1, col2 = st.columns([1, 5])
                with col1:
                    if st.button(" Save Forecast"):
                        st.success("Forecast saved!")
                
                st.markdown("---")
                st.markdown("#### Forecast Summary")
                
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("Starting Cash", f"${forecast_df['Beginning_Balance'].iloc[0]/1e6:.1f}M")
                with col2:
                    total_inflows = forecast_df['Total_Inflows'].sum()
                    st.metric("Total Inflows", f"${total_inflows/1e6:.1f}M")
                with col3:
                    total_outflows = forecast_df['Total_Outflows'].sum()
                    st.metric("Total Outflows", f"${total_outflows/1e6:.1f}M")
                with col4:
                    ending = forecast_df['Ending_Balance'].iloc[-1]
                    st.metric("Ending Cash", f"${ending/1e6:.1f}M")
    
    with tab3:
        st.caption("Manage accounts receivable and payable")
        
        ar_tab, ap_tab = st.tabs([" Accounts Receivable", " Accounts Payable"])
        
        with ar_tab:
            if st.session_state.ar_data.empty:
                st.info("No data loaded yet. Go to the Dashboard tab to load sample data.")
            else:
                ar_df = st.session_state.ar_data
                open_ar = ar_df[ar_df['Status'] == 'Open']
                
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("Total AR", f"${open_ar['Balance'].sum()/1e6:.1f}M")
                with col2:
                    current = open_ar[open_ar['Aging_Bucket'] == 'Current']['Balance'].sum()
                    st.metric("Current", f"${current/1e6:.1f}M")
                with col3:
                    over_60 = open_ar[open_ar['Aging_Bucket'].isin(['61-90 Days', '90+ Days'])]['Balance'].sum()
                    st.metric("Over 60 Days", f"${over_60/1e6:.1f}M")
                with col4:
                    dso = open_ar['Days_Outstanding'].mean()
                    st.metric("Avg DSO", f"{dso:.0f} days")
                
                st.markdown("#### AR Aging")
                aging_summary = open_ar.groupby('Aging_Bucket')['Balance'].sum().reindex(
                    ['Current', '31-60 Days', '61-90 Days', '90+ Days']
                ).fillna(0)
                
                fig = go.Figure(go.Bar(
                    x=aging_summary.index,
                    y=aging_summary.values / 1e6,
                    marker_color=['#22c55e', '#f59e0b', '#f97316', '#ef4444']
                ))
                fig.update_layout(height=250, xaxis_title='', yaxis_title='Balance ($M)')
                st.plotly_chart(fig, use_container_width=True)
                
                st.markdown("#### Open Invoices")
                st.dataframe(
                    open_ar[['Invoice_ID', 'Customer', 'Invoice_Date', 'Due_Date', 'Amount', 'Balance', 'Days_Outstanding', 'Aging_Bucket']],
                    use_container_width=True,
                    height=300,
                    column_config={
                        'Amount': st.column_config.NumberColumn('Amount', format="$%.0f"),
                        'Balance': st.column_config.NumberColumn('Balance', format="$%.0f")
                    }
                )
        
        with ap_tab:
            if st.session_state.ap_data.empty:
                st.info("No data loaded yet. Go to the Dashboard tab to load sample data.")
            else:
                ap_df = st.session_state.ap_data
                open_ap = ap_df[ap_df['Status'] == 'Open']
                
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("Total AP", f"${open_ap['Balance'].sum()/1e6:.1f}M")
                with col2:
                    due_7 = open_ap[(pd.to_datetime(open_ap['Due_Date']) - datetime.now()).dt.days <= 7]['Balance'].sum()
                    st.metric("Due in 7 Days", f"${due_7/1e6:.1f}M")
                with col3:
                    overdue = open_ap[pd.to_datetime(open_ap['Due_Date']) < datetime.now()]['Balance'].sum()
                    st.metric("Overdue", f"${overdue/1e6:.1f}M")
                with col4:
                    st.metric("Open Invoices", len(open_ap))
                
                st.markdown("#### Open Payables")
                st.dataframe(
                    open_ap[['Invoice_ID', 'Vendor', 'PO_Number', 'Invoice_Date', 'Due_Date', 'Amount', 'Payment_Terms']],
                    use_container_width=True,
                    height=300,
                    column_config={
                        'Amount': st.column_config.NumberColumn('Amount', format="$%.0f")
                    }
                )
    
    with tab4:
        st.caption("Reconcile bank accounts")
        
        st.markdown("#### Bank Account Summary")
        
        accounts = pd.DataFrame([
            {'Account': 'Operating - Wells Fargo', 'Book_Balance': 28500000, 'Bank_Balance': 28750000, 'Difference': -250000, 'Status': 'Pending Items'},
            {'Account': 'Payroll - Chase', 'Book_Balance': 5200000, 'Bank_Balance': 5200000, 'Difference': 0, 'Status': 'Reconciled'},
            {'Account': 'NDT Fund - Trust', 'Book_Balance': 125000000, 'Bank_Balance': 125000000, 'Difference': 0, 'Status': 'Reconciled'},
            {'Account': 'CapEx Reserve', 'Book_Balance': 8500000, 'Bank_Balance': 8550000, 'Difference': -50000, 'Status': 'Pending Items'},
        ])
        
        st.dataframe(
            accounts,
            use_container_width=True,
            column_config={
                'Book_Balance': st.column_config.NumberColumn('Book Balance', format="$%.0f"),
                'Bank_Balance': st.column_config.NumberColumn('Bank Balance', format="$%.0f"),
                'Difference': st.column_config.NumberColumn('Difference', format="$%.0f")
            }
        )
        
        total_book = accounts['Book_Balance'].sum()
        total_bank = accounts['Bank_Balance'].sum()
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Total Book Balance", f"${total_book/1e6:.1f}M")
        with col2:
            st.metric("Total Bank Balance", f"${total_bank/1e6:.1f}M")
        with col3:
            st.metric("Total Difference", f"${(total_bank - total_book)/1e6:+.2f}M")
    
    with tab5:
        st.caption("Analyze cash trends and patterns")
        
        if st.session_state.cash_flow_data.empty:
            st.info("No cash flow data yet. Go to the Dashboard tab and click Load Sample Cash Flow Data.")
        else:
            df = st.session_state.cash_flow_data
            
            st.markdown("#### Monthly Cash Flow Summary")
            
            df['Month'] = pd.to_datetime(df['Week_Start']).dt.to_period('M')
            monthly = df.groupby('Month').agg({
                'Total_Inflows': 'sum',
                'Total_Outflows': 'sum',
                'Net_Change': 'sum',
                'Ending_Balance': 'last'
            }).reset_index()
            monthly['Month'] = monthly['Month'].astype(str)
            
            fig = go.Figure()
            fig.add_trace(go.Bar(x=monthly['Month'], y=monthly['Total_Inflows']/1e6, name='Inflows', marker_color='#22c55e'))
            fig.add_trace(go.Bar(x=monthly['Month'], y=monthly['Total_Outflows']/1e6, name='Outflows', marker_color='#ef4444'))
            fig.add_trace(go.Scatter(x=monthly['Month'], y=monthly['Ending_Balance']/1e6, name='Ending Balance', 
                                    line=dict(color='#3b82f6', width=3), yaxis='y2'))
            
            fig.update_layout(
                height=400,
                barmode='group',
                yaxis=dict(title='Inflows/Outflows ($M)'),
                yaxis2=dict(title='Balance ($M)', overlaying='y', side='right'),
                legend=dict(orientation='h', yanchor='bottom', y=1.02)
            )
            st.plotly_chart(fig, use_container_width=True)
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("#### Inflow Sources")
                inflow_cols = ['Customer_Receipts', 'NDT_Draws', 'Other_Receipts']
                inflow_totals = df[inflow_cols].sum()
                
                fig = go.Figure(go.Pie(
                    labels=['Customer Receipts', 'NDT Draws', 'Other'],
                    values=inflow_totals.values,
                    hole=0.4,
                    marker_colors=['#3b82f6', '#22c55e', '#f59e0b']
                ))
                fig.update_layout(height=300)
                st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                st.markdown("#### Outflow Categories")
                outflow_cols = ['Payroll', 'Vendor_Payments', 'Subcontractor', 'CapEx_Payments', 'Taxes', 'Other_Payments']
                outflow_totals = df[outflow_cols].sum()
                
                fig = go.Figure(go.Pie(
                    labels=['Payroll', 'Vendors', 'Subcontractors', 'CapEx', 'Taxes', 'Other'],
                    values=outflow_totals.values,
                    hole=0.4
                ))
                fig.update_layout(height=300)
                st.plotly_chart(fig, use_container_width=True)

# =============================================================================
# PAGE: VARIANCE ANALYSIS
# =============================================================================

elif page == " Variance Analysis":
    if st.session_state.budget_data.empty:
        st.info("Load data to view variance analysis")
        st.stop()
    
    df = st.session_state.budget_data
    current_month = datetime.now().month
    
    tab1, tab2, tab3 = st.tabs([" Summary", " Trend Analysis", " Detail Drill-Down"])
    
    with tab1:
        st.caption("Analyze budget vs actual performance")
        # Comparison selector
        col1, col2, col3 = st.columns(3)
        
        with col1:
            compare_type = st.selectbox("Compare", ["Budget vs Actual", "Forecast vs Actual", "Budget vs Forecast"])
        with col2:
            period_type = st.selectbox("Period", ["YTD", "Full Year", "Current Month", "Current Quarter"])
        with col3:
            group_by = st.selectbox("Group By", ["Cost Center", "Account", "Entity"])
        
        # Filter data based on period
        if period_type == "YTD":
            period_df = df[df['Month_Num'] <= current_month]
        elif period_type == "Current Month":
            period_df = df[df['Month_Num'] == current_month]
        elif period_type == "Current Quarter":
            current_q = get_quarter(current_month)
            period_df = df[df['Month'].isin(QUARTERS[current_q])]
        else:
            period_df = df
        
        # Calculate variances
        if compare_type == "Budget vs Actual":
            col_a, col_b = 'Budget', 'Actual'
        elif compare_type == "Forecast vs Actual":
            col_a, col_b = 'Forecast', 'Actual'
        else:
            col_a, col_b = 'Budget', 'Forecast'
        
        group_col = 'Cost Center Name' if group_by == 'Cost Center' else ('Account Name' if group_by == 'Account' else 'Entity')
        
        variance_df = period_df.groupby(group_col).agg({
            col_a: 'sum',
            col_b: 'sum'
        })
        
        variance_df['Variance $'] = variance_df[col_a] - variance_df[col_b]
        variance_df['Variance %'] = ((variance_df[col_a] - variance_df[col_b]) / variance_df[col_a].abs() * 100).round(1)
        variance_df = variance_df.sort_values('Variance $', ascending=True)
        
        # Variance chart
        st.markdown("### Variance by " + group_by)
        
        colors = ['#ef4444' if x < 0 else '#10b981' for x in variance_df['Variance $']]
        
        fig = go.Figure(go.Bar(
            x=variance_df['Variance $'] / 1000,
            y=variance_df.index,
            orientation='h',
            marker_color=colors
        ))
        
        fig.update_layout(
            height=max(400, len(variance_df) * 25),
            xaxis_title='Variance ($K)',
            yaxis_title='',
            plot_bgcolor='white'
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Variance table
        st.markdown("### Variance Detail")
        
        display_var = variance_df.copy()
        display_var[col_a] = display_var[col_a].apply(lambda x: f"${x:,.0f}")
        display_var[col_b] = display_var[col_b].apply(lambda x: f"${x:,.0f}")
        display_var['Variance $'] = display_var['Variance $'].apply(lambda x: f"${x:,.0f}")
        display_var['Variance %'] = display_var['Variance %'].apply(lambda x: f"{x:+.1f}%")
        
        st.dataframe(display_var, use_container_width=True)
    
    with tab2:
        st.markdown("### Monthly Variance Trend")
        
        monthly_var = df.groupby('Month').agg({
            'Budget': 'sum',
            'Actual': 'sum'
        }).reindex(MONTHS)
        
        monthly_var['Variance'] = monthly_var['Budget'] - monthly_var['Actual']
        monthly_var['Variance %'] = ((monthly_var['Variance'] / monthly_var['Budget']) * 100).round(1)
        
        # Only show months with actuals
        monthly_var_display = monthly_var.iloc[:current_month]
        
        fig = make_subplots(specs=[[{"secondary_y": True}]])
        
        fig.add_trace(
            go.Bar(name='Variance $', x=monthly_var_display.index, y=monthly_var_display['Variance'] / 1000,
                  marker_color=['#10b981' if x > 0 else '#ef4444' for x in monthly_var_display['Variance']]),
            secondary_y=False
        )
        
        fig.add_trace(
            go.Scatter(name='Variance %', x=monthly_var_display.index, y=monthly_var_display['Variance %'],
                      mode='lines+markers', line=dict(color='#6366f1')),
            secondary_y=True
        )
        
        fig.update_layout(height=400, legend=dict(orientation='h', yanchor='bottom', y=1.02))
        fig.update_yaxes(title_text="Variance ($K)", secondary_y=False)
        fig.update_yaxes(title_text="Variance %", secondary_y=True)
        
        st.plotly_chart(fig, use_container_width=True)
    
    with tab3:
        st.markdown("### Variance Drill-Down")
        
        # Select dimensions
        col1, col2 = st.columns(2)
        
        with col1:
            drill_entity = st.selectbox("Entity", ['All'] + df['Entity'].unique().tolist())
        with col2:
            drill_cc = st.selectbox("Cost Center", ['All'] + df['Cost Center Name'].unique().tolist())
        
        # Filter
        drill_df = df.copy()
        if drill_entity != 'All':
            drill_df = drill_df[drill_df['Entity'] == drill_entity]
        if drill_cc != 'All':
            drill_df = drill_df[drill_df['Cost Center Name'] == drill_cc]
        
        # Show monthly detail
        if not drill_df.empty:
            pivot = drill_df.pivot_table(
                index=['Account', 'Account Name'],
                columns='Month',
                values=['Budget', 'Actual'],
                aggfunc='sum'
            ).fillna(0)
            
            st.dataframe(pivot, use_container_width=True, height=500)



# =============================================================================
# PAGE: APPROVALS & WORKFLOWS
# =============================================================================

elif page.startswith(" Approvals"):
    # Get workflow engine
    workflow_engine = st.session_state.workflow_engine
    current_user = st.session_state.current_user
    
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        " Pending Approvals", 
        " My Submissions", 
        " New Request",
        " Workflow Status",
        " Workflow Settings"
    ])
    
    with tab1:
        st.caption("Manage budget approvals and workflow processes")
        
        # User info bar
        st.markdown(f"""
        <div style='background-color: #f0f9ff; padding: 10px 20px; border-radius: 8px; margin-bottom: 15px;'>
            <strong>Logged in as:</strong> {current_user['name']} ({current_user['email']}) | 
            <strong>Role:</strong> {current_user['role'].replace('_', ' ').title()}
        </div>
        """, unsafe_allow_html=True)
        
        # Get pending approvals for current user
        pending = workflow_engine.get_pending_approvals(
            approver_email=current_user['email'],
            approver_role=current_user['role']
        )
        
        if not pending:
            st.success(" No pending approvals! You're all caught up.")
        else:
            st.warning(f" You have **{len(pending)}** item(s) awaiting your approval")
            
            for idx, workflow in enumerate(pending):
                is_overdue = workflow.get('is_overdue', False)
                status_color = "" if is_overdue else ""
                
                with st.expander(
                    f"{status_color} {workflow['template_display_name']} - {workflow.get('metadata', {}).get('description', 'No description')} "
                    f"({'OVERDUE' if is_overdue else 'Due: ' + (workflow.get('due_date', '')[:10] if workflow.get('due_date') else 'N/A')})",
                    expanded=False
                ):
                    col1, col2, col3 = st.columns(3)
                    
                    with col1:
                        st.markdown(f"**Submitted by:** {workflow.get('submitter_name', 'Unknown')}")
                        st.markdown(f"**Entity:** {workflow.get('entity_id', 'N/A')}")
                        st.markdown(f"**Cost Center:** {workflow.get('cost_center_id', 'N/A')}")
                    
                    with col2:
                        amount = workflow.get('amount', 0)
                        st.markdown(f"**Amount:** ${amount:,.0f}" if amount else "**Amount:** N/A")
                        st.markdown(f"**Version:** {workflow.get('version_id', 'N/A')}")
                        st.markdown(f"**Created:** {workflow.get('created_at', '')[:10]}")
                    
                    with col3:
                        current_step_info = workflow.get('current_step_info', {})
                        st.markdown(f"**Current Step:** {current_step_info.get('step_name', 'Unknown')}")
                        st.markdown(f"**Step {workflow['current_step']} of {workflow['total_steps']}**")
                        
                        # Progress bar
                        progress = workflow['current_step'] / workflow['total_steps'] if workflow['total_steps'] > 0 else 0
                        st.progress(progress)
                    
                    # Comments history
                    if workflow.get('comments'):
                        st.markdown("**Comments:**")
                        for comment in workflow['comments'][-3:]:  # Show last 3 comments
                            st.markdown(f"- *{comment.get('author', 'Unknown')}* ({comment.get('timestamp', '')[:10]}): {comment.get('text', '')}")
                    
                    st.markdown("---")
                    
                    # Action buttons
                    col1, col2, col3, col4 = st.columns(4)
                    
                    comment_text = st.text_area("Add Comment (optional)", key=f"comment_{workflow['workflow_id']}")
                    
                    with col1:
                        if st.button(" Approve", key=f"approve_{workflow['workflow_id']}", type="primary"):
                            try:
                                workflow_engine.approve(
                                    workflow['workflow_id'],
                                    current_user['email'],
                                    current_user['name'],
                                    comment_text
                                )
                                st.success("Approved successfully!")
                                st.rerun()
                            except Exception as e:
                                st.error(f"Error: {e}")
                    
                    with col2:
                        if st.button(" Reject", key=f"reject_{workflow['workflow_id']}"):
                            if not comment_text:
                                st.warning("Please provide a reason for rejection")
                            else:
                                try:
                                    workflow_engine.reject(
                                        workflow['workflow_id'],
                                        current_user['email'],
                                        current_user['name'],
                                        comment_text
                                    )
                                    st.success("Rejected")
                                    st.rerun()
                                except Exception as e:
                                    st.error(f"Error: {e}")
                    
                    with col3:
                        if st.button(" Request Revision", key=f"revise_{workflow['workflow_id']}"):
                            if not comment_text:
                                st.warning("Please provide revision instructions")
                            else:
                                try:
                                    workflow_engine.request_revision(
                                        workflow['workflow_id'],
                                        current_user['email'],
                                        current_user['name'],
                                        comment_text
                                    )
                                    st.success("Revision requested")
                                    st.rerun()
                                except Exception as e:
                                    st.error(f"Error: {e}")
                    
                    with col4:
                        delegate_email = st.text_input("Delegate to (email)", key=f"delegate_email_{workflow['workflow_id']}")
                        if st.button(" Delegate", key=f"delegate_{workflow['workflow_id']}"):
                            if delegate_email:
                                try:
                                    workflow_engine.delegate(
                                        workflow['workflow_id'],
                                        current_user['email'],
                                        delegate_email,
                                        delegate_email.split('@')[0],
                                        comment_text
                                    )
                                    st.success(f"Delegated to {delegate_email}")
                                    st.rerun()
                                except Exception as e:
                                    st.error(f"Error: {e}")
    
    with tab2:
        st.markdown("### My Submissions")
        
        my_submissions = workflow_engine.get_my_submissions(current_user['email'])
        
        if not my_submissions:
            st.info("You haven't submitted any workflows yet.")
        else:
            # Summary stats
            col1, col2, col3, col4 = st.columns(4)
            
            statuses = [s['status'] for s in my_submissions]
            with col1:
                st.metric("Total Submissions", len(my_submissions))
            with col2:
                st.metric("Pending", statuses.count('pending_approval'))
            with col3:
                st.metric("Approved", statuses.count('approved'))
            with col4:
                st.metric("Rejected", statuses.count('rejected'))
            
            st.markdown("---")
            
            # Status filter
            status_filter = st.selectbox(
                "Filter by Status",
                ['All', 'draft', 'pending_approval', 'approved', 'rejected', 'revision_requested']
            )
            
            filtered_submissions = my_submissions if status_filter == 'All' else [
                s for s in my_submissions if s['status'] == status_filter
            ]
            
            for workflow in filtered_submissions:
                status_icon = {
                    'draft': '',
                    'pending_approval': '',
                    'approved': '',
                    'rejected': '',
                    'revision_requested': '',
                    'locked': ''
                }.get(workflow['status'], '')
                
                with st.expander(f"{status_icon} {workflow['template_display_name']} - {workflow['status'].replace('_', ' ').title()}"):
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.markdown(f"**Created:** {workflow.get('created_at', '')[:10]}")
                        st.markdown(f"**Status:** {workflow['status'].replace('_', ' ').title()}")
                        st.markdown(f"**Step:** {workflow['current_step']} of {workflow['total_steps']}")
                    
                    with col2:
                        amount = workflow.get('amount', 0)
                        st.markdown(f"**Amount:** ${amount:,.0f}" if amount else "")
                        if workflow.get('completed_at'):
                            st.markdown(f"**Completed:** {workflow['completed_at'][:10]}")
                    
                    # Show approval history
                    history = workflow_engine.get_workflow_history(workflow['workflow_id'])
                    if history:
                        st.markdown("**Approval History:**")
                        for record in history:
                            st.markdown(f"- {record.timestamp.strftime('%Y-%m-%d %H:%M')} | {record.action.value} by {record.actor_name}")
                    
                    # Actions for draft/revision_requested
                    if workflow['status'] in ['draft', 'revision_requested']:
                        if st.button(" Submit for Approval", key=f"submit_{workflow['workflow_id']}"):
                            try:
                                workflow_engine.submit_for_approval(
                                    workflow['workflow_id'],
                                    current_user['email'],
                                    current_user['name']
                                )
                                st.success("Submitted!")
                                st.rerun()
                            except Exception as e:
                                st.error(f"Error: {e}")
                    
                    elif workflow['status'] == 'pending_approval':
                        if st.button(" Recall Submission", key=f"recall_{workflow['workflow_id']}"):
                            try:
                                workflow_engine.recall(
                                    workflow['workflow_id'],
                                    current_user['email'],
                                    current_user['name']
                                )
                                st.success("Recalled to draft")
                                st.rerun()
                            except Exception as e:
                                st.error(f"Error: {e}")
    
    with tab3:
        st.markdown("### Create New Approval Request")
        
        col1, col2 = st.columns(2)
        
        with col1:
            workflow_type = st.selectbox(
                "Workflow Type",
                list(WorkflowEngine.WORKFLOW_TEMPLATES.keys()),
                format_func=lambda x: WorkflowEngine.WORKFLOW_TEMPLATES[x]['name']
            )
            
            template = WorkflowEngine.WORKFLOW_TEMPLATES[workflow_type]
            st.info(template['description'])
            
            entity = st.selectbox(
                "Entity",
                list(st.session_state.entities.keys()) if st.session_state.entities else ['CORP']
            )
            
            cost_center = st.selectbox(
                "Cost Center",
                list(st.session_state.cost_centers.keys()) if st.session_state.cost_centers else ['1000']
            )
        
        with col2:
            version = st.selectbox(
                "Budget Version",
                list(st.session_state.budget_versions.keys()) if st.session_state.budget_versions else ['2024-BUD-V1']
            )
            
            amount = st.number_input("Total Amount ($)", min_value=0.0, value=100000.0, step=10000.0)
            
            description = st.text_input("Description", placeholder="Brief description of this request")
            
            justification = st.text_area("Business Justification", placeholder="Explain the business need...")
        
        st.markdown("---")
        st.markdown("#### Approval Steps (based on amount)")
        
        # Show which steps will be required
        steps_preview = []
        for step in template['steps']:
            threshold = step.get('threshold_amount')
            if threshold is None or amount >= threshold:
                steps_preview.append(step)
        
        for i, step in enumerate(steps_preview):
            threshold_note = f" (required for amounts >= ${step.get('threshold_amount'):,.0f})" if step.get('threshold_amount') else ""
            st.markdown(f"{i+1}. **{step['step_name']}** - {step['approver_role'].replace('_', ' ').title()}{threshold_note}")
        
        st.markdown("---")
        
        col1, col2 = st.columns([1, 3])
        
        with col1:
            if st.button(" Save as Draft", type="secondary"):
                workflow_id = f"WF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
                workflow_engine.create_workflow(
                    workflow_id=workflow_id,
                    template_name=workflow_type,
                    entity_id=entity,
                    cost_center_id=cost_center,
                    version_id=version,
                    amount=amount,
                    submitter_email=current_user['email'],
                    submitter_name=current_user['name'],
                    metadata={'description': description, 'justification': justification}
                )
                st.success(f"Draft saved: {workflow_id}")
                st.rerun()
        
        with col2:
            if st.button(" Submit for Approval", type="primary"):
                if not description:
                    st.warning("Please provide a description")
                else:
                    workflow_id = f"WF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
                    workflow = workflow_engine.create_workflow(
                        workflow_id=workflow_id,
                        template_name=workflow_type,
                        entity_id=entity,
                        cost_center_id=cost_center,
                        version_id=version,
                        amount=amount,
                        submitter_email=current_user['email'],
                        submitter_name=current_user['name'],
                        metadata={'description': description, 'justification': justification}
                    )
                    workflow_engine.submit_for_approval(
                        workflow_id,
                        current_user['email'],
                        current_user['name'],
                        justification
                    )
                    st.success(f"Submitted for approval: {workflow_id}")
                    st.balloons()
                    st.rerun()
    
    with tab4:
        st.markdown("### Workflow Status Dashboard")
        
        # Summary metrics
        stats = workflow_engine.get_workflow_stats()
        
        col1, col2, col3, col4, col5 = st.columns(5)
        
        with col1:
            st.metric("Total Workflows", stats['total'])
        with col2:
            st.metric("Pending", stats['by_status'].get('pending_approval', 0))
        with col3:
            st.metric("Approved", stats['by_status'].get('approved', 0))
        with col4:
            st.metric("Overdue", stats['overdue'], delta_color="inverse")
        with col5:
            st.metric("Avg Cycle (days)", f"{stats['avg_cycle_time_days']:.1f}")
        
        st.markdown("---")
        
        # Status distribution chart
        if stats['by_status']:
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("#### Status Distribution")
                status_df = pd.DataFrame([
                    {'Status': k.replace('_', ' ').title(), 'Count': v}
                    for k, v in stats['by_status'].items()
                ])
                
                fig = px.pie(status_df, values='Count', names='Status', hole=0.4)
                st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                st.markdown("#### All Workflows")
                all_workflows = list(workflow_engine.workflow_instances.values())
                
                if all_workflows:
                    wf_df = pd.DataFrame([
                        {
                            'ID': wf['workflow_id'],
                            'Type': wf['template_display_name'],
                            'Status': wf['status'].replace('_', ' ').title(),
                            'Submitter': wf.get('submitter_name', 'Unknown'),
                            'Amount': f"${wf.get('amount', 0):,.0f}",
                            'Created': wf.get('created_at', '')[:10]
                        }
                        for wf in all_workflows
                    ])
                    st.dataframe(wf_df, use_container_width=True, height=300)
    
    with tab5:
        st.markdown("### Workflow Configuration")
        
        st.markdown("#### Available Workflow Templates")
        
        for template_id, template in WorkflowEngine.WORKFLOW_TEMPLATES.items():
            with st.expander(f" {template['name']}"):
                st.markdown(f"**Description:** {template['description']}")
                st.markdown("**Approval Steps:**")
                
                for step in template['steps']:
                    threshold = step.get('threshold_amount')
                    threshold_text = f" (if amount >= ${threshold:,.0f})" if threshold else ""
                    st.markdown(f"- Step {step['step_id']}: **{step['step_name']}**  {step['approver_role'].replace('_', ' ').title()}{threshold_text} ({step.get('timeout_days', 7)} day timeout)")
        
        st.markdown("---")
        st.markdown("#### Role Hierarchy")
        
        roles_df = pd.DataFrame([
            {'Role': role.replace('_', ' ').title(), 'Level': level}
            for role, level in sorted(WorkflowEngine.ROLE_HIERARCHY.items(), key=lambda x: x[1])
        ])
        st.dataframe(roles_df, use_container_width=True)
        
        st.markdown("---")
        st.markdown("#### Current User Settings")
        
        col1, col2 = st.columns(2)
        
        with col1:
            new_email = st.text_input("Your Email", value=current_user['email'])
            new_name = st.text_input("Your Name", value=current_user['name'])
        
        with col2:
            new_role = st.selectbox(
                "Your Role",
                list(WorkflowEngine.ROLE_HIERARCHY.keys()),
                index=list(WorkflowEngine.ROLE_HIERARCHY.keys()).index(current_user['role']) 
                    if current_user['role'] in WorkflowEngine.ROLE_HIERARCHY else 0,
                format_func=lambda x: x.replace('_', ' ').title()
            )
            new_dept = st.text_input("Department", value=current_user.get('department', ''))
        
        if st.button(" Update User Settings"):
            st.session_state.current_user = {
                'email': new_email,
                'name': new_name,
                'role': new_role,
                'department': new_dept,
                'can_approve': True
            }
            st.success("User settings updated!")
            st.rerun()


# =============================================================================
# PAGE: REPORTS & ANALYTICS
# =============================================================================

elif page == " Reports & Analytics":
    tab1, tab2 = st.tabs([" Financial Reports", " Export"])
    
    # =========================================================================
    # TAB 1: FINANCIAL REPORTS (P&L, Flash Report)
    # =========================================================================
    with tab1:
        st.markdown("###  Financial Reports")
        st.caption("P&L and Flash Reports with MTD/QTD/YTD views")
        
        # Initialize P&L sample data in session state
        if 'pl_sample_data' not in st.session_state:
            st.session_state.pl_sample_data = pd.DataFrame()
        
        # =====================================================
        # DATA SOURCE SELECTION
        # =====================================================
        fr_col1, fr_col2, fr_col3, fr_col4 = st.columns([1.5, 1, 1, 1])
        
        with fr_col1:
            report_type = st.selectbox("Report Type", ["P&L Statement", "Flash Report"], key="fr_report_type")
        
        with fr_col2:
            # Period type selection
            period_type = st.selectbox("Period View", ["MTD", "QTD", "YTD"], key="fr_period_type")
        
        with fr_col3:
            # Month selection for MTD/QTD/YTD calculations
            current_month = datetime.now().month
            selected_month = st.selectbox("As of Month", MONTHS, index=min(current_month-1, 11), key="fr_selected_month")
        
        with fr_col4:
            # Generate sample data button
            if st.button(" Generate Sample Data", type="primary", use_container_width=True):
                # Generate comprehensive P&L sample data
                np.random.seed(42)
                
                # Define categories and their typical ranges
                categories_config = {
                    'Revenue': {'base': 7000000, 'variance': 0.15, 'is_revenue': True},
                    'Labor & Fringe Costs': {'base': 1000000, 'variance': 0.10, 'is_revenue': False},
                    'Facilities & Equipment': {'base': 3200000, 'variance': 0.08, 'is_revenue': False},
                    'Materials & Supplies': {'base': 400000, 'variance': 0.20, 'is_revenue': False},
                    'Travel & Relocation': {'base': 60000, 'variance': 0.25, 'is_revenue': False},
                    'Professional Services': {'base': 250000, 'variance': 0.15, 'is_revenue': False},
                    'Allocations': {'base': 0, 'variance': 0.0, 'is_revenue': False},
                    'Other': {'base': 400000, 'variance': 0.30, 'is_revenue': False},
                }
                
                pl_rows = []
                for cat, config in categories_config.items():
                    base = config['base']
                    var = config['variance']
                    is_rev = config['is_revenue']
                    
                    # Generate monthly data for current year
                    monthly_budget = {}
                    monthly_actual = {}
                    for m in MONTHS:
                        # Budget with some seasonal variation
                        month_idx = MONTHS.index(m)
                        seasonal = 1.0 + 0.1 * np.sin(month_idx * np.pi / 6)  # Slight seasonal pattern
                        monthly_budget[f'Budget_{m}'] = round(base / 12 * seasonal * np.random.uniform(0.95, 1.05), 0)
                        # Actual typically slightly different from budget
                        monthly_actual[f'Actual_{m}'] = round(monthly_budget[f'Budget_{m}'] * np.random.uniform(0.92, 1.08), 0)
                    
                    # Historical annual data
                    annual_2024 = round(base * np.random.uniform(0.95, 1.05), 0)
                    annual_2023 = round(annual_2024 * np.random.uniform(0.85, 0.95), 0)
                    annual_2022 = round(annual_2023 * np.random.uniform(0.88, 0.98), 0)
                    
                    row = {
                        'Category': cat,
                        'Is_Revenue': is_rev,
                        'Annual_2024': annual_2024,
                        'Annual_2023': annual_2023,
                        'Annual_2022': annual_2022,
                        **monthly_budget,
                        **monthly_actual,
                    }
                    pl_rows.append(row)
                
                st.session_state.pl_sample_data = pd.DataFrame(pl_rows)
                st.toast(" Sample P&L data generated!")
                st.rerun()
        
        # Get available data sources
        saved_versions = st.session_state.get('saved_budget_versions', {})
        unified_versions = st.session_state.get('unified_corporate_versions', {})
        # Filter for Budget Planning corporate versions
        corporate_versions = {k: v for k, v in unified_versions.items() 
                             if v.get('page_type') == 'Budget Planning'}
        
        # Build data source options
        data_sources = ["Sample Data (P&L Format)"]
        for ver_id in saved_versions.keys():
            data_sources.append(f"Standalone: {ver_id}")
        for corp_id, corp_info in corporate_versions.items():
            corp_name = corp_info.get('name', corp_id)
            data_sources.append(f"Corporate: {corp_name}")
        
        selected_source = st.selectbox(" Data Source", data_sources, key="fr_data_source")
        
        st.markdown("---")
        
        # =====================================================
        # LOAD AND PROCESS DATA
        # =====================================================
        pl_data = pd.DataFrame()
        use_sample_format = False
        
        if selected_source == "Sample Data (P&L Format)":
            if not st.session_state.pl_sample_data.empty:
                pl_data = st.session_state.pl_sample_data.copy()
                use_sample_format = True
            else:
                st.info(" Click 'Generate Sample Data' to create P&L sample data for a department")
        
        elif selected_source.startswith("Standalone:"):
            ver_id = selected_source.replace("Standalone: ", "")
            ver_info = saved_versions.get(ver_id, {})
            ver_data = ver_info.get('data', {})
            cc_data = ver_data.get('cc_data', pd.DataFrame())
            if not cc_data.empty:
                pl_data = cc_data.copy()
        
        elif selected_source.startswith("Corporate:"):
            # Extract corp name and find the matching corp_id
            corp_name = selected_source.replace("Corporate: ", "")
            corp_id = None
            for cid, cinfo in corporate_versions.items():
                if cinfo.get('name', cid) == corp_name:
                    corp_id = cid
                    break
            
            if corp_id:
                corp_info = corporate_versions.get(corp_id, {})
                contributors = corp_info.get('contributors', {})
                all_dfs = []
                for dept_name, contrib in contributors.items():
                    # Handle both old and new data structures
                    contrib_data = contrib.get('data', pd.DataFrame())
                    if isinstance(contrib_data, dict):
                        # Old structure: data is a dict with cc_data key
                        contrib_data = contrib_data.get('cc_data', pd.DataFrame())
                    if isinstance(contrib_data, pd.DataFrame) and not contrib_data.empty:
                        contrib_data = contrib_data.copy()
                        all_dfs.append(contrib_data)
                if all_dfs:
                    pl_data = pd.concat(all_dfs, ignore_index=True)
        
        # =====================================================
        # P&L STATEMENT (New Format)
        # =====================================================
        if report_type == "P&L Statement" and not pl_data.empty:
            st.markdown(f"###  Profit & Loss Statement")
            
            # Get selected month index
            selected_month_idx = MONTHS.index(selected_month)
            
            # Calculate period months
            if period_type == "MTD":
                period_months = [selected_month]
                period_label = f"{selected_month} MTD"
            elif period_type == "QTD":
                quarter = selected_month_idx // 3
                quarter_start = quarter * 3
                period_months = MONTHS[quarter_start:selected_month_idx + 1]
                period_label = f"Q{quarter + 1} QTD"
            else:  # YTD
                period_months = MONTHS[:selected_month_idx + 1]
                period_label = f"YTD through {selected_month}"
            
            st.caption(f"Period: {period_label} | {datetime.now().year}")
            
            # Process data based on format
            if use_sample_format:
                # Use the sample data format directly
                pl_display_rows = []
                
                # P&L category order
                category_order = ['Revenue', 'Labor & Fringe Costs', 'Facilities & Equipment', 
                                  'Materials & Supplies', 'Travel & Relocation', 'Professional Services',
                                  'Allocations', 'Other']
                
                total_costs = {'Actual_MTD': 0, 'Budget_MTD': 0, 'Actual_YTD': 0, 'Budget_YTD': 0,
                               'Annual_2024': 0, 'Annual_2023': 0, 'Annual_2022': 0}
                revenue = {'Actual_MTD': 0, 'Budget_MTD': 0, 'Actual_YTD': 0, 'Budget_YTD': 0,
                           'Annual_2024': 0, 'Annual_2023': 0, 'Annual_2022': 0}
                
                for cat in category_order:
                    cat_data = pl_data[pl_data['Category'] == cat]
                    if cat_data.empty:
                        continue
                    
                    row = cat_data.iloc[0]
                    is_rev = row.get('Is_Revenue', False)
                    
                    # Calculate MTD (selected month only)
                    actual_mtd = row.get(f'Actual_{selected_month}', 0)
                    budget_mtd = row.get(f'Budget_{selected_month}', 0)
                    
                    # Calculate YTD (sum through selected month)
                    actual_ytd = sum(row.get(f'Actual_{m}', 0) for m in MONTHS[:selected_month_idx + 1])
                    budget_ytd = sum(row.get(f'Budget_{m}', 0) for m in MONTHS[:selected_month_idx + 1])
                    
                    # Get annual historical
                    annual_2024 = row.get('Annual_2024', 0)
                    annual_2023 = row.get('Annual_2023', 0)
                    annual_2022 = row.get('Annual_2022', 0)
                    
                    # Calculate variances
                    var_mtd = actual_mtd - budget_mtd
                    var_ytd = actual_ytd - budget_ytd
                    
                    # For costs, show as negative values
                    display_mult = 1 if is_rev else -1
                    
                    pl_display_rows.append({
                        'Account Category': cat,
                        'Actual MTD': actual_mtd * display_mult,
                        'Budget MTD': budget_mtd * display_mult,
                        'Variance MTD': var_mtd * display_mult,
                        'Actual YTD': actual_ytd * display_mult,
                        'Budget YTD': budget_ytd * display_mult,
                        'Variance': var_ytd * display_mult,
                        '2024': annual_2024 * display_mult,
                        '2023': annual_2023 * display_mult,
                        '2022': annual_2022 * display_mult,
                        '_is_total': False,
                        '_is_highlight': False,
                    })
                    
                    # Accumulate totals
                    if is_rev:
                        revenue['Actual_MTD'] += actual_mtd
                        revenue['Budget_MTD'] += budget_mtd
                        revenue['Actual_YTD'] += actual_ytd
                        revenue['Budget_YTD'] += budget_ytd
                        revenue['Annual_2024'] += annual_2024
                        revenue['Annual_2023'] += annual_2023
                        revenue['Annual_2022'] += annual_2022
                    else:
                        total_costs['Actual_MTD'] += actual_mtd
                        total_costs['Budget_MTD'] += budget_mtd
                        total_costs['Actual_YTD'] += actual_ytd
                        total_costs['Budget_YTD'] += budget_ytd
                        total_costs['Annual_2024'] += annual_2024
                        total_costs['Annual_2023'] += annual_2023
                        total_costs['Annual_2022'] += annual_2022
                
                # Add Total Costs row
                pl_display_rows.append({
                    'Account Category': 'Total Costs',
                    'Actual MTD': -total_costs['Actual_MTD'],
                    'Budget MTD': -total_costs['Budget_MTD'],
                    'Variance MTD': -(total_costs['Actual_MTD'] - total_costs['Budget_MTD']),
                    'Actual YTD': -total_costs['Actual_YTD'],
                    'Budget YTD': -total_costs['Budget_YTD'],
                    'Variance': -(total_costs['Actual_YTD'] - total_costs['Budget_YTD']),
                    '2024': -total_costs['Annual_2024'],
                    '2023': -total_costs['Annual_2023'],
                    '2022': -total_costs['Annual_2022'],
                    '_is_total': True,
                    '_is_highlight': False,
                })
                
                # Calculate Gross Profit
                gross_profit = {
                    'Actual_MTD': revenue['Actual_MTD'] - total_costs['Actual_MTD'],
                    'Budget_MTD': revenue['Budget_MTD'] - total_costs['Budget_MTD'],
                    'Actual_YTD': revenue['Actual_YTD'] - total_costs['Actual_YTD'],
                    'Budget_YTD': revenue['Budget_YTD'] - total_costs['Budget_YTD'],
                    'Annual_2024': revenue['Annual_2024'] - total_costs['Annual_2024'],
                    'Annual_2023': revenue['Annual_2023'] - total_costs['Annual_2023'],
                    'Annual_2022': revenue['Annual_2022'] - total_costs['Annual_2022'],
                }
                
                pl_display_rows.append({
                    'Account Category': 'Gross Profit',
                    'Actual MTD': gross_profit['Actual_MTD'],
                    'Budget MTD': gross_profit['Budget_MTD'],
                    'Variance MTD': gross_profit['Actual_MTD'] - gross_profit['Budget_MTD'],
                    'Actual YTD': gross_profit['Actual_YTD'],
                    'Budget YTD': gross_profit['Budget_YTD'],
                    'Variance': gross_profit['Actual_YTD'] - gross_profit['Budget_YTD'],
                    '2024': gross_profit['Annual_2024'],
                    '2023': gross_profit['Annual_2023'],
                    '2022': gross_profit['Annual_2022'],
                    '_is_total': True,
                    '_is_highlight': True,
                })
                
                # EBITDA (same as Gross Profit for this simplified model)
                pl_display_rows.append({
                    'Account Category': 'EBITDA',
                    'Actual MTD': gross_profit['Actual_MTD'],
                    'Budget MTD': gross_profit['Budget_MTD'],
                    'Variance MTD': gross_profit['Actual_MTD'] - gross_profit['Budget_MTD'],
                    'Actual YTD': gross_profit['Actual_YTD'],
                    'Budget YTD': gross_profit['Budget_YTD'],
                    'Variance': gross_profit['Actual_YTD'] - gross_profit['Budget_YTD'],
                    '2024': gross_profit['Annual_2024'],
                    '2023': gross_profit['Annual_2023'],
                    '2022': gross_profit['Annual_2022'],
                    '_is_total': True,
                    '_is_highlight': True,
                })
                
                # Create display DataFrame
                pl_df = pd.DataFrame(pl_display_rows)
                
                # Format for display with proper number formatting
                def format_currency(val):
                    if pd.isna(val) or val == 0:
                        return "$0"
                    if val < 0:
                        return f"(${abs(val):,.0f})"
                    return f"${val:,.0f}"
                
                # Create formatted display
                display_cols = ['Account Category', 'Actual MTD', 'Budget MTD', 'Variance MTD',
                               'Actual YTD', 'Budget YTD', 'Variance', '2024', '2023', '2022']
                
                # Apply formatting
                formatted_df = pl_df[display_cols].copy()
                for col in display_cols[1:]:  # Skip Account Category
                    formatted_df[col] = pl_df[col].apply(format_currency)
                
                # Style the dataframe
                def highlight_rows(row):
                    idx = row.name
                    if idx >= len(pl_df):
                        return [''] * len(row)
                    
                    cat = pl_df.iloc[idx]['Account Category']
                    is_highlight = pl_df.iloc[idx].get('_is_highlight', False)
                    is_total = pl_df.iloc[idx].get('_is_total', False)
                    
                    if cat in ['Gross Profit', 'EBITDA']:
                        return ['background-color: #FFF3CD; font-weight: bold'] * len(row)
                    elif cat == 'Total Costs':
                        return ['font-weight: bold'] * len(row)
                    elif cat == 'Revenue':
                        return ['background-color: #E8F5E9'] * len(row)
                    return [''] * len(row)
                
                styled_df = formatted_df.style.apply(highlight_rows, axis=1)
                styled_df = styled_df.set_properties(**{
                    'text-align': 'right'
                }, subset=display_cols[1:])
                styled_df = styled_df.set_properties(**{
                    'text-align': 'left',
                    'font-weight': 'bold'
                }, subset=['Account Category'])
                
                # Display the P&L table
                st.dataframe(styled_df, use_container_width=True, hide_index=True, height=450)
                
                # Summary metrics
                st.markdown("---")
                m1, m2, m3, m4 = st.columns(4)
                with m1:
                    st.metric("Revenue YTD", f"${revenue['Actual_YTD']:,.0f}")
                with m2:
                    st.metric("Total Costs YTD", f"${total_costs['Actual_YTD']:,.0f}")
                with m3:
                    st.metric("Gross Profit YTD", f"${gross_profit['Actual_YTD']:,.0f}")
                with m4:
                    margin_pct = (gross_profit['Actual_YTD'] / revenue['Actual_YTD'] * 100) if revenue['Actual_YTD'] != 0 else 0
                    st.metric("Margin %", f"{margin_pct:.1f}%")
            
            else:
                # Use budget version data - convert to P&L format
                st.info("Budget version data loaded. Aggregating by category...")
                
                if 'Category' in pl_data.columns:
                    # Group by category
                    cat_summary = pl_data.groupby('Category').agg({
                        col: 'sum' for col in pl_data.columns 
                        if col in MONTHS or col.startswith('PY_') or col in ['Budget_Annual', 'PY_Annual']
                    }).reset_index()
                    
                    st.dataframe(cat_summary, use_container_width=True, hide_index=True)
                else:
                    st.warning("No Category column found in data.")
        
        # =====================================================
        # FLASH REPORT
        # =====================================================
        elif report_type == "Flash Report" and not pl_data.empty:
            st.markdown(f"###  Flash Report")
            
            if use_sample_format:
                # Calculate totals from sample data
                revenue_data = pl_data[pl_data['Is_Revenue'] == True]
                cost_data = pl_data[pl_data['Is_Revenue'] == False]
                
                selected_month_idx = MONTHS.index(selected_month)
                
                # Calculate MTD
                actual_mtd_rev = revenue_data[f'Actual_{selected_month}'].sum() if f'Actual_{selected_month}' in revenue_data.columns else 0
                budget_mtd_rev = revenue_data[f'Budget_{selected_month}'].sum() if f'Budget_{selected_month}' in revenue_data.columns else 0
                actual_mtd_cost = cost_data[f'Actual_{selected_month}'].sum() if f'Actual_{selected_month}' in cost_data.columns else 0
                budget_mtd_cost = cost_data[f'Budget_{selected_month}'].sum() if f'Budget_{selected_month}' in cost_data.columns else 0
                
                # Calculate YTD
                actual_ytd_rev = sum(revenue_data[f'Actual_{m}'].sum() for m in MONTHS[:selected_month_idx + 1] if f'Actual_{m}' in revenue_data.columns)
                budget_ytd_rev = sum(revenue_data[f'Budget_{m}'].sum() for m in MONTHS[:selected_month_idx + 1] if f'Budget_{m}' in revenue_data.columns)
                actual_ytd_cost = sum(cost_data[f'Actual_{m}'].sum() for m in MONTHS[:selected_month_idx + 1] if f'Actual_{m}' in cost_data.columns)
                budget_ytd_cost = sum(cost_data[f'Budget_{m}'].sum() for m in MONTHS[:selected_month_idx + 1] if f'Budget_{m}' in cost_data.columns)
                
                # Key metrics
                st.markdown("####  Key Metrics")
                km1, km2, km3, km4 = st.columns(4)
                with km1:
                    st.metric("Revenue MTD", f"${actual_mtd_rev:,.0f}", delta=f"${actual_mtd_rev - budget_mtd_rev:,.0f} vs Budget")
                with km2:
                    st.metric("Revenue YTD", f"${actual_ytd_rev:,.0f}", delta=f"${actual_ytd_rev - budget_ytd_rev:,.0f} vs Budget")
                with km3:
                    gross_profit_ytd = actual_ytd_rev - actual_ytd_cost
                    st.metric("Gross Profit YTD", f"${gross_profit_ytd:,.0f}")
                with km4:
                    margin = (gross_profit_ytd / actual_ytd_rev * 100) if actual_ytd_rev != 0 else 0
                    st.metric("Margin %", f"{margin:.1f}%")
                
                st.markdown("---")
                
                # Category breakdown chart
                st.markdown("####  Cost Breakdown")
                
                cat_data = []
                for _, row in cost_data.iterrows():
                    actual = sum(row.get(f'Actual_{m}', 0) for m in MONTHS[:selected_month_idx + 1])
                    budget = sum(row.get(f'Budget_{m}', 0) for m in MONTHS[:selected_month_idx + 1])
                    cat_data.append({
                        'Category': row['Category'],
                        'Actual YTD': actual,
                        'Budget YTD': budget,
                        'Variance': actual - budget
                    })
                
                cat_df = pd.DataFrame(cat_data).sort_values('Actual YTD', ascending=True)
                
                fig = go.Figure()
                fig.add_trace(go.Bar(name='Actual YTD', y=cat_df['Category'], x=cat_df['Actual YTD'], 
                                     orientation='h', marker_color='#4472C4'))
                fig.add_trace(go.Bar(name='Budget YTD', y=cat_df['Category'], x=cat_df['Budget YTD'], 
                                     orientation='h', marker_color='#A5A5A5'))
                fig.update_layout(barmode='group', height=350, margin=dict(l=0, r=0, t=30, b=0),
                                 legend=dict(orientation='h', yanchor='bottom', y=1.02))
                st.plotly_chart(fig, use_container_width=True)
                
                # Table
                cat_df['Var %'] = cat_df.apply(lambda r: round((r['Variance'] / r['Budget YTD'] * 100), 1) if r['Budget YTD'] != 0 else 0, axis=1)
                st.dataframe(
                    cat_df,
                    column_config={
                        'Actual YTD': st.column_config.NumberColumn(format='$%.0f'),
                        'Budget YTD': st.column_config.NumberColumn(format='$%.0f'),
                        'Variance': st.column_config.NumberColumn(format='$%.0f'),
                        'Var %': st.column_config.NumberColumn(format='%.1f%%')
                    },
                    use_container_width=True,
                    hide_index=True
                )
            else:
                st.info("Select 'Sample Data (P&L Format)' and generate sample data for full Flash Report features.")
        
        elif pl_data.empty:
            if selected_source != "Sample Data (P&L Format)":
                st.info("No budget data found in the selected version.")
    
    with tab2:
        st.markdown("### Export Data")
        
        export_options = st.multiselect(
            "Select Data to Export",
            ["Budget Data", "Actuals", "Headcount Plan", "Variance Summary", "KPI Scorecard"]
        )
        
        export_format = st.selectbox("Export Format", ["Excel (multiple sheets)", "CSV (zip)", "JSON"])
        
        if st.button("Export Selected Data"):
            if export_options:
                st.success(f"Exporting {len(export_options)} datasets...")
                
                # Create export
                output = io.BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    if "Budget Data" in export_options and not st.session_state.budget_data.empty:
                        st.session_state.budget_data.to_excel(writer, sheet_name='Budget Data', index=False)
                    if "Headcount Plan" in export_options and not st.session_state.headcount_plan.empty:
                        st.session_state.headcount_plan.to_excel(writer, sheet_name='Headcount', index=False)
                
                output.seek(0)
                st.download_button(
                    " Download Export",
                    data=output,
                    file_name=f"budget_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )


# =============================================================================
# PAGE: BD FORECASTING
# =============================================================================

elif page == " BD Forecasting":
    st.markdown("###  Business Development Forecasting")
    st.caption("Forecast input screen - Only Forecast (F) rows are editable. Budget and Actual edits auto-revert.")
    
    # Month columns
    MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    
    # Initialize BD Forecast versions storage
    if 'bd_forecast_versions' not in st.session_state:
        st.session_state.bd_forecast_versions = {}
    
    # Initialize current loaded version tracker
    if 'bd_current_version' not in st.session_state:
        st.session_state.bd_current_version = None
    
    # ===== VERSION MANAGEMENT BAR =====
    with st.expander(" Version Management", expanded=False):
        # Initialize unified corporate versions if needed
        if 'unified_corporate_versions' not in st.session_state:
            st.session_state.unified_corporate_versions = {}
        
        ver_col1, ver_col2 = st.columns(2)
        
        with ver_col1:
            st.markdown("**Load Version**")
            
            # Get corporate versions for BD Forecasting from unified storage
            bd_corp_versions = {k: v for k, v in st.session_state.unified_corporate_versions.items() 
                              if v.get('page_type') == 'BD Forecasting'}
            
            # Get standalone versions
            bd_standalone_versions = {k: v for k, v in st.session_state.bd_forecast_versions.items() 
                                     if v.get('version_type') == 'Standalone'}
            
            # Build combined options
            load_options = ['-- Select --']
            load_mapping = {}  # Maps display name to (source, key)
            
            if bd_corp_versions:
                for k, v in bd_corp_versions.items():
                    display = f" {v['name']} ({v['status']})"
                    load_options.append(display)
                    load_mapping[display] = ('corporate', k)
            
            if bd_standalone_versions:
                for k, v in bd_standalone_versions.items():
                    display = f" {k}"
                    load_options.append(display)
                    load_mapping[display] = ('standalone', k)
            
            if len(load_options) > 1:
                selected_load = st.selectbox("Select Version", load_options, key="bd_load_version_select")
                
                if selected_load != '-- Select --':
                    source, ver_key = load_mapping[selected_load]
                    
                    lc1, lc2 = st.columns(2)
                    with lc1:
                        if st.button(" Load", key="bd_load_version_btn"):
                            if source == 'corporate':
                                # Load from unified corporate - need to combine all contributors
                                corp_ver = st.session_state.unified_corporate_versions[ver_key]
                                contributors = corp_ver.get('contributors', {})
                                if contributors:
                                    # Combine all contributor data
                                    all_dfs = [c['data'] for c in contributors.values() if 'data' in c]
                                    if all_dfs:
                                        combined_df = pd.concat(all_dfs, ignore_index=True)
                                        st.session_state.bd_forecast_input = combined_df
                                    else:
                                        st.warning("No data in this corporate version yet")
                                else:
                                    st.warning("No contributions in this corporate version yet")
                                st.session_state.bd_current_version = f"Corporate: {corp_ver['name']}"
                            else:
                                # Load from standalone
                                st.session_state.bd_forecast_input = bd_standalone_versions[ver_key]['data'].copy()
                                st.session_state.bd_current_version = ver_key
                            st.toast(f" Loaded: {selected_load}")
                            st.rerun()
                    with lc2:
                        if source == 'corporate':
                            ver_info = st.session_state.unified_corporate_versions[ver_key]
                            st.caption(f"Status: {ver_info.get('status', 'N/A')}")
                            st.caption(f"Contributors: {len(ver_info.get('contributors', {}))}")
                        else:
                            ver_info = bd_standalone_versions[ver_key]
                            st.caption(f"Type: Standalone")
                            st.caption(f"Saved: {ver_info.get('saved_at', 'N/A')}")
            else:
                st.info("No saved versions yet")
        
        with ver_col2:
            st.markdown("**Save Version**")
            
            # Save type selection
            save_type = st.radio("Save As", ["Standalone (Personal)", "To Corporate Version"], 
                                horizontal=True, key="bd_save_type")
            
            if "Standalone" in save_type:
                new_version_name = st.text_input("Version Name", key="bd_new_version_name", 
                                                 placeholder="e.g., My Q1 Draft")
                
                if st.button(" Save Standalone", key="bd_save_standalone_btn"):
                    if new_version_name.strip():
                        st.session_state.bd_forecast_versions[new_version_name.strip()] = {
                            'data': st.session_state.bd_forecast_input.copy(),
                            'version_type': 'Standalone',
                            'page_type': 'BD Forecasting',
                            'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M'),
                            'saved_by': 'User'
                        }
                        st.session_state.bd_current_version = new_version_name.strip()
                        st.toast(f" Saved: {new_version_name}")
                        st.rerun()
                    else:
                        st.warning("Please enter a version name")
            else:
                # Save to corporate version
                available_corp = {k: v for k, v in st.session_state.unified_corporate_versions.items() 
                                 if v.get('page_type') == 'BD Forecasting' and v.get('status') == 'Working'}
                
                if available_corp:
                    corp_options = list(available_corp.keys())
                    corp_display = [f"{available_corp[k]['name']} (FY{available_corp[k].get('fiscal_year', '')})" for k in corp_options]
                    
                    selected_corp_idx = st.selectbox("Select Corporate Version", range(len(corp_options)),
                                                    format_func=lambda i: corp_display[i], key="bd_corp_select")
                    selected_corp_key = corp_options[selected_corp_idx]
                    
                    contributor_name = st.text_input("Contributor Name", key="bd_contributor_name",
                                                    placeholder="e.g., Your Name or Department")
                    
                    if st.button(" Save to Corporate", key="bd_save_corp_btn"):
                        if contributor_name.strip():
                            # Calculate total for this contribution
                            df = st.session_state.bd_forecast_input
                            total_amount = df[MONTHS].sum().sum() if 'Jan' in df.columns else 0
                            
                            # Add as contributor
                            st.session_state.unified_corporate_versions[selected_corp_key]['contributors'][contributor_name.strip()] = {
                                'data': df.copy(),
                                'total': total_amount,
                                'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M'),
                                'saved_by': 'User'
                            }
                            
                            # Update total
                            new_total = sum(c.get('total', 0) for c in st.session_state.unified_corporate_versions[selected_corp_key]['contributors'].values())
                            st.session_state.unified_corporate_versions[selected_corp_key]['total_amount'] = new_total
                            
                            st.session_state.bd_current_version = f"Corporate: {available_corp[selected_corp_key]['name']} ({contributor_name.strip()})"
                            st.toast(f" Saved to corporate version: {available_corp[selected_corp_key]['name']}")
                            st.rerun()
                        else:
                            st.warning("Please enter your name or department")
                else:
                    st.warning("No Working corporate versions available for BD Forecasting. Create one in Settings  Versions.")
        
        # Show current version indicator
        if st.session_state.bd_current_version:
            st.success(f" Current: {st.session_state.bd_current_version}")
    
    # Initialize or get BD forecast data
    if 'bd_forecast_input' not in st.session_state:
        # Generate sample data matching the Excel structure
        sample_data = []
        
        # Define hierarchical structure
        divisions = {
            'BCO': {
                'B-DAW': {
                    'COMPACTION': ['Navy', 'Corporate', 'DOE', 'Utility'],
                    'DAW BULK': ['Navy', 'Industrial', 'Utility'],
                    'DAW Certification': ['Corporate', 'DOE'],
                },
                'B-Filters': {
                    'Filter Shredding': ['Utility', 'Industrial'],
                },
                'B-GIC': {
                    'GIC - LD': ['Utility', 'DOE'],
                    'GIC - MD': ['Navy', 'Utility'],
                },
                'B-Liquids': {
                    'Drum Drying': ['Industrial', 'Utility'],
                    'INCIN OIL': ['DOE', 'Utility'],
                },
                'B-Metals': {
                    'LEAD - DECON': ['Navy', 'Utility'],
                    'METAL MELT': ['Industrial', 'DOE'],
                },
                'B-Resins': {
                    'Dewatering of Resins/Filters': ['Utility', 'DOE'],
                },
            }
        }
        
        customers_by_type = {
            'Navy': ['Electric Boat Corporation', 'Naval Reactors Facility', 'Norfolk Naval Shipyard', 'Pearl Harbor Naval Shipyard', 'Portsmouth Naval Shipyard'],
            'Corporate': ['Erwin ResinSolutions', 'Corporate Account', 'XYZ Industries', 'Global Tech Corp'],
            'DOE': ['UT-Battelle, LLC-ORNL', 'Triad National Security', 'Argonne National Labs', 'Oak Ridge National Labs'],
            'Utility': ['AmerenUE Callaway', 'Arkansas Nuclear One', 'Braidwood Station', 'Byron Nuclear Station', 'Clinton Power Station'],
            'Industrial': ['General Engineering Labs', 'BWX Technologies', 'GE-Hitachi', 'Westinghouse Electric'],
        }
        
        line_id = 1
        for division, processes in divisions.items():
            for process, sub_procs in processes.items():
                for sub_proc, cust_types in sub_procs.items():
                    for cust_type in cust_types:
                        # Pick 1-3 customers of this type
                        available_custs = customers_by_type.get(cust_type, ['General Customer'])
                        num_custs = min(random.randint(1, 3), len(available_custs))
                        selected_custs = random.sample(available_custs, num_custs)
                        
                        for customer in selected_custs:
                            # Generate monthly values for each Bqfa type
                            for bqfa in ['B', 'F', 'A']:
                                row = {
                                    'Line_Id': line_id,
                                    'Division': division,
                                    'Process': process,
                                    'Sub_Process': sub_proc,
                                    'CustomerType': cust_type,
                                    'CustomerName': customer,
                                    'Bqfa': bqfa,
                                }
                                
                                # Generate monthly values
                                base = random.randint(5000, 50000)
                                py_base = base * random.uniform(0.85, 1.0)  # Prior year slightly lower
                                
                                for month in MONTHS:
                                    # Current year values
                                    if bqfa == 'A':  # Actuals - only for past months
                                        month_idx = MONTHS.index(month)
                                        current_month = datetime.now().month
                                        if month_idx < current_month:
                                            row[month] = round(base * random.uniform(0.8, 1.2), 0)
                                        else:
                                            row[month] = 0.0
                                    elif bqfa == 'B':  # Budget
                                        row[month] = round(base * random.uniform(0.9, 1.1), 0)
                                    else:  # Forecast
                                        row[month] = round(base * random.uniform(0.85, 1.15), 0)
                                    
                                    # Prior year values (full year actuals)
                                    row[f'PY_{month}'] = round(py_base * random.uniform(0.85, 1.15), 0)
                                
                                row['Version'] = '2026 Forecast'
                                row['Notes'] = ''
                                row['Modified_By'] = ''
                                
                                sample_data.append(row)
                                line_id += 1
        
        st.session_state.bd_forecast_input = pd.DataFrame(sample_data)
    
    # Check if PY columns exist - if not, regenerate data
    if 'bd_forecast_input' in st.session_state:
        if 'PY_Jan' not in st.session_state.bd_forecast_input.columns:
            del st.session_state['bd_forecast_input']
            st.rerun()
    
    bd_df = st.session_state.bd_forecast_input.copy()
    
    # Calculate totals by Bqfa type
    budget_total = bd_df[bd_df['Bqfa'] == 'B'][MONTHS].sum().sum()
    forecast_total = bd_df[bd_df['Bqfa'] == 'F'][MONTHS].sum().sum()
    actuals_total = bd_df[bd_df['Bqfa'] == 'A'][MONTHS].sum().sum()
    
    # GGI = Budget - Actuals - Forecast (the gap)
    ggi_total = budget_total - actuals_total - forecast_total
    
    variance = forecast_total - budget_total
    
    # Summary KPIs - 6 columns now
    k1, k2, k3, k4, k5, k6 = st.columns(6)
    with k1:
        st.metric("Budget", f"${budget_total/1e6:.2f}M")
    with k2:
        st.metric("Actuals YTD", f"${actuals_total/1e6:.2f}M")
    with k3:
        st.metric("Forecast", f"${forecast_total/1e6:.2f}M")
    with k4:
        var_pct = (variance / budget_total * 100) if budget_total != 0 else 0
        st.metric("Variance", f"${variance/1e6:.2f}M", delta=f"{var_pct:+.1f}%")
    with k5:
        # GGI with color indicator
        ggi_color = "" if ggi_total <= 0 else ""
        st.metric(f"GGI {ggi_color}", f"${ggi_total/1e6:.2f}M", 
                 help="Go Get It = Budget - Actuals - Forecast. Negative means on track.")
    with k6:
        f_rows = len(bd_df[bd_df['Bqfa'] == 'F'])
        st.metric("Forecast Lines", f"{f_rows}")
    
    st.markdown("---")
    
    # Filters
    with st.expander(" Filters", expanded=False):
        fc1, fc2, fc3, fc4, fc5 = st.columns(5)
        with fc1:
            divisions_list = ['All'] + sorted(bd_df['Division'].unique().tolist())
            flt_division = st.selectbox("Division", divisions_list, key="bd_flt_div")
        with fc2:
            processes_list = ['All'] + sorted(bd_df['Process'].unique().tolist())
            flt_process = st.selectbox("Process", processes_list, key="bd_flt_proc")
        with fc3:
            sub_proc_list = ['All'] + sorted(bd_df['Sub_Process'].unique().tolist())
            flt_subproc = st.selectbox("Sub Process", sub_proc_list, key="bd_flt_subproc")
        with fc4:
            cust_types = ['All'] + sorted(bd_df['CustomerType'].unique().tolist())
            flt_custtype = st.selectbox("Customer Type", cust_types, key="bd_flt_custtype")
        with fc5:
            bqfa_types = ['All', 'B', 'F', 'A']
            flt_bqfa = st.selectbox("Bqfa", bqfa_types, key="bd_flt_bqfa")
    
    # Get filter values from session state
    flt_division = st.session_state.get('bd_flt_div', 'All')
    flt_process = st.session_state.get('bd_flt_proc', 'All')
    flt_subproc = st.session_state.get('bd_flt_subproc', 'All')
    flt_custtype = st.session_state.get('bd_flt_custtype', 'All')
    flt_bqfa = st.session_state.get('bd_flt_bqfa', 'All')
    
    # Apply filters to base data
    filtered_df = bd_df.copy()
    if flt_division != 'All':
        filtered_df = filtered_df[filtered_df['Division'] == flt_division]
    if flt_process != 'All':
        filtered_df = filtered_df[filtered_df['Process'] == flt_process]
    if flt_subproc != 'All':
        filtered_df = filtered_df[filtered_df['Sub_Process'] == flt_subproc]
    if flt_custtype != 'All':
        filtered_df = filtered_df[filtered_df['CustomerType'] == flt_custtype]
    if flt_bqfa != 'All':
        filtered_df = filtered_df[filtered_df['Bqfa'] == flt_bqfa]
    
    # Prior Year Months
    PY_MONTHS = [f'PY_{m}' for m in MONTHS]
    
    # ===== SINGLE TABLE - ALL ROWS - ONLY F ROWS EDITABLE =====
    st.markdown(f"#####  Budget / Forecast / Actuals - {len(filtered_df)} rows")
    
    # Toggle for Prior Year view
    tgl_col1, tgl_col2 = st.columns([0.3, 0.7])
    with tgl_col1:
        show_prior_year = st.toggle("Show Prior Year & Variance", value=False, key="bd_show_py")
    with tgl_col2:
        st.caption(" Only **Forecast (F)** rows can be edited. Budget (B) and Actual (A) edits will auto-revert.")
    
    if len(filtered_df) > 0:
        # Calculate Annual Total for display
        filtered_df = filtered_df.copy()
        filtered_df['Annual_Total'] = filtered_df[MONTHS].sum(axis=1)
        
        # Build display columns based on toggle
        if show_prior_year:
            # Calculate PY Annual Total too
            filtered_df['PY_Annual_Total'] = filtered_df[PY_MONTHS].sum(axis=1)
            filtered_df['Annual_Var'] = filtered_df['Annual_Total'] - filtered_df['PY_Annual_Total']
            
            # Put Annual_Total right after dimension columns, before months
            display_cols = ['Bqfa', 'Division', 'Process', 'Sub_Process', 'CustomerType', 'CustomerName',
                           'Annual_Total', 'PY_Annual_Total', 'Annual_Var']
            
            # Then add monthly columns interleaved with PY and variance
            for month in MONTHS:
                py_col = f'PY_{month}'
                var_col = f'Var_{month}'
                # Calculate variance (CY - PY)
                if py_col in filtered_df.columns:
                    filtered_df[var_col] = filtered_df[month] - filtered_df[py_col]
                display_cols.extend([month, py_col, var_col])
            
            display_cols.append('Notes')
            display_cols = [c for c in display_cols if c in filtered_df.columns]
            
            # Column config with PY and Variance columns
            col_config = {
                'Bqfa': st.column_config.TextColumn('Type', width='small', help='B=Budget, F=Forecast, A=Actuals'),
                'Division': st.column_config.TextColumn('Division', width='small'),
                'Process': st.column_config.TextColumn('Process', width='small'),
                'Sub_Process': st.column_config.TextColumn('Sub Process', width='medium'),
                'CustomerType': st.column_config.TextColumn('Cust Type', width='small'),
                'CustomerName': st.column_config.TextColumn('Customer', width='large'),
                'Annual_Total': st.column_config.NumberColumn('Annual', format='$%.0f', width='small'),
                'PY_Annual_Total': st.column_config.NumberColumn('PY Ann', format='$%.0f', width='small'),
                'Annual_Var': st.column_config.NumberColumn('Ann Var', format='$%.0f', width='small'),
                'Notes': st.column_config.TextColumn('Notes', width='medium'),
            }
            for month in MONTHS:
                col_config[month] = st.column_config.NumberColumn(month, format='$%.0f', width='small')
                col_config[f'PY_{month}'] = st.column_config.NumberColumn(f'PY {month}', format='$%.0f', width='small')
                col_config[f'Var_{month}'] = st.column_config.NumberColumn(f'Var', format='$%.0f', width='small')
            
            # All PY, Variance, and Annual columns disabled, but months still editable for F rows
            disabled_cols = ['Bqfa', 'Division', 'Process', 'Sub_Process', 'CustomerType', 'CustomerName',
                            'Annual_Total', 'PY_Annual_Total', 'Annual_Var'] + PY_MONTHS + [f'Var_{m}' for m in MONTHS]
        else:
            # Standard view - Annual_Total right after dimension columns, before months
            display_cols = ['Bqfa', 'Division', 'Process', 'Sub_Process', 'CustomerType', 'CustomerName', 
                           'Annual_Total'] + MONTHS + ['Notes']
            display_cols = [c for c in display_cols if c in filtered_df.columns]
            
            # Column config for month columns
            col_config = {
                'Bqfa': st.column_config.TextColumn('Type', width='small', help='B=Budget, F=Forecast, A=Actuals'),
                'Division': st.column_config.TextColumn('Division', width='small'),
                'Process': st.column_config.TextColumn('Process', width='small'),
                'Sub_Process': st.column_config.TextColumn('Sub Process', width='medium'),
                'CustomerType': st.column_config.TextColumn('Cust Type', width='small'),
                'CustomerName': st.column_config.TextColumn('Customer', width='large'),
                'Annual_Total': st.column_config.NumberColumn('Annual', format='$%.0f', width='small'),
                'Notes': st.column_config.TextColumn('Notes', width='medium'),
            }
            for month in MONTHS:
                col_config[month] = st.column_config.NumberColumn(month, format='$%.0f', width='small')
            
            disabled_cols = ['Bqfa', 'Division', 'Process', 'Sub_Process', 'CustomerType', 'CustomerName', 'Annual_Total']
        
        # Prepare working dataframe with original index preserved
        working_df = filtered_df[display_cols].copy()
        original_indices = filtered_df.index.tolist()
        
        # Store original values for change detection
        original_values = working_df.copy()
        
        # Use dynamic key to force editor reset when invalid edits are made
        if 'bd_editor_key' not in st.session_state:
            st.session_state.bd_editor_key = 0
        
        # Show warning if we just reverted an invalid edit
        if st.session_state.get('bd_show_revert_warning', False):
            st.warning(" Only Forecast (F) rows can be edited. Budget and Actual rows are protected.")
            st.session_state.bd_show_revert_warning = False
        
        # Data editor - all columns technically editable but we'll reject non-F changes
        edited_df = st.data_editor(
            working_df,
            column_config=col_config,
            use_container_width=True,
            hide_index=True,
            height=500,
            key=f"bd_combined_editor_{st.session_state.bd_editor_key}",
            disabled=disabled_cols
        )
        
        # Detect and apply changes - ONLY for F rows, auto-revert B/A changes
        changes_made = False
        invalid_edit_attempted = False
        
        for i in range(len(edited_df)):
            if i < len(original_indices):
                orig_idx = original_indices[i]
                row_bqfa = bd_df.at[orig_idx, 'Bqfa']
                
                # Check each editable column for changes
                for col in MONTHS + ['Notes']:
                    if col in edited_df.columns:
                        old_val = original_values.iloc[i][col]
                        new_val = edited_df.iloc[i][col]
                        
                        # Simplified comparison - convert to comparable types
                        try:
                            if col in MONTHS:
                                # Numeric comparison
                                old_num = float(old_val) if pd.notna(old_val) else 0.0
                                new_num = float(new_val) if pd.notna(new_val) else 0.0
                                value_changed = abs(old_num - new_num) > 0.01
                            else:
                                # String comparison for Notes
                                old_str = str(old_val) if pd.notna(old_val) else ''
                                new_str = str(new_val) if pd.notna(new_val) else ''
                                value_changed = old_str != new_str
                        except (ValueError, TypeError):
                            value_changed = str(old_val) != str(new_val)
                        
                        if value_changed:
                            # Only apply changes to F rows
                            if row_bqfa == 'F':
                                bd_df.at[orig_idx, col] = new_val
                                if col in MONTHS:
                                    bd_df.at[orig_idx, 'Modified_By'] = 'User'
                                changes_made = True
                            else:
                                # B or A row - mark for revert
                                invalid_edit_attempted = True
        
        # If B/A rows were edited, increment key to reset the editor and show message on next render
        if invalid_edit_attempted:
            st.session_state.bd_editor_key += 1
            st.session_state.bd_show_revert_warning = True
            st.rerun()
        
        if changes_made:
            st.session_state.bd_forecast_input = bd_df
            st.rerun()
    else:
        st.info("No rows match the current filters.")
    
    # ===== GGI ANALYSIS =====
    st.markdown("---")
    st.markdown("#####  Go Get It (GGI) Analysis")
    st.caption("GGI = Budget - Actuals - Forecast | Shows the gap between budget and current trajectory. Uses filtered data above.")
    
    # Multi-select for aggregation levels
    available_dims = ['Division', 'Process', 'Sub_Process', 'CustomerType', 'CustomerName']
    ggi_dims = st.multiselect(
        "Aggregate By (select one or more)",
        available_dims,
        default=['Division'],
        key="bd_ggi_dims"
    )
    
    if not ggi_dims:
        st.warning("Please select at least one dimension to aggregate by.")
    else:
        # Use FILTERED data for GGI analysis
        budget_data = filtered_df[filtered_df['Bqfa'] == 'B'].copy()
        actuals_data = filtered_df[filtered_df['Bqfa'] == 'A'].copy()
        forecast_data = filtered_df[filtered_df['Bqfa'] == 'F'].copy()
        
        # Aggregate by selected dimensions
        if len(budget_data) > 0:
            budget_grp = budget_data.groupby(ggi_dims)[MONTHS].sum().reset_index()
            budget_grp['Total'] = budget_grp[MONTHS].sum(axis=1)
        else:
            budget_grp = pd.DataFrame(columns=ggi_dims + MONTHS + ['Total'])
        
        if len(actuals_data) > 0:
            actuals_grp = actuals_data.groupby(ggi_dims)[MONTHS].sum().reset_index()
            actuals_grp['Total'] = actuals_grp[MONTHS].sum(axis=1)
        else:
            actuals_grp = pd.DataFrame(columns=ggi_dims + MONTHS + ['Total'])
        
        if len(forecast_data) > 0:
            forecast_grp = forecast_data.groupby(ggi_dims)[MONTHS].sum().reset_index()
            forecast_grp['Total'] = forecast_grp[MONTHS].sum(axis=1)
        else:
            forecast_grp = pd.DataFrame(columns=ggi_dims + MONTHS + ['Total'])
        
        # Merge the three datasets to build GGI
        # Start with budget as base
        if len(budget_grp) > 0:
            ggi_df = budget_grp[ggi_dims + ['Total']].copy()
            ggi_df.columns = ggi_dims + ['Budget']
        else:
            ggi_df = pd.DataFrame(columns=ggi_dims + ['Budget'])
        
        # Merge actuals
        if len(actuals_grp) > 0:
            actuals_merge = actuals_grp[ggi_dims + ['Total']].copy()
            actuals_merge.columns = ggi_dims + ['Actuals']
            if len(ggi_df) > 0:
                ggi_df = ggi_df.merge(actuals_merge, on=ggi_dims, how='outer')
            else:
                ggi_df = actuals_merge.copy()
                ggi_df['Budget'] = 0
        
        # Merge forecast
        if len(forecast_grp) > 0:
            forecast_merge = forecast_grp[ggi_dims + ['Total']].copy()
            forecast_merge.columns = ggi_dims + ['Forecast']
            if len(ggi_df) > 0:
                ggi_df = ggi_df.merge(forecast_merge, on=ggi_dims, how='outer')
            else:
                ggi_df = forecast_merge.copy()
                ggi_df['Budget'] = 0
                ggi_df['Actuals'] = 0
        
        if len(ggi_df) > 0:
            # Ensure all required columns exist
            for col in ['Budget', 'Actuals', 'Forecast']:
                if col not in ggi_df.columns:
                    ggi_df[col] = 0
            
            # Fill NaN with 0
            ggi_df = ggi_df.fillna(0)
            
            # Calculate GGI
            ggi_df['GGI'] = ggi_df['Budget'] - ggi_df['Actuals'] - ggi_df['Forecast']
            ggi_df['Status'] = ggi_df['GGI'].apply(lambda x: ' On Track' if x <= 0 else ' Gap')
            
            # Build column config
            ggi_col_config = {}
            for dim in ggi_dims:
                ggi_col_config[dim] = st.column_config.TextColumn(dim)
            ggi_col_config['Budget'] = st.column_config.NumberColumn('Budget', format='$%.0f')
            ggi_col_config['Actuals'] = st.column_config.NumberColumn('Actuals', format='$%.0f')
            ggi_col_config['Forecast'] = st.column_config.NumberColumn('Forecast', format='$%.0f')
            ggi_col_config['GGI'] = st.column_config.NumberColumn('GGI', format='$%.0f')
            ggi_col_config['Status'] = st.column_config.TextColumn('Status')
            
            # Display columns order
            display_order = ggi_dims + ['Budget', 'Actuals', 'Forecast', 'GGI', 'Status']
            
            st.dataframe(
                ggi_df[display_order],
                column_config=ggi_col_config,
                use_container_width=True,
                hide_index=True
            )
        else:
            st.info("No data available for GGI analysis with current filters.")


# =============================================================================
# PAGE: CORPORATE FINANCE
# =============================================================================

elif page == " Corporate Finance":
    st.markdown("###  Corporate Finance Forecasting")
    st.caption("Company-wide financial forecasting and projections")
    
    current_year = datetime.now().year
    current_month = datetime.now().month
    
    # Get or generate corporate finance data
    if 'corp_forecast_data' not in st.session_state:
        # Generate sample corporate finance data
        categories = [
            ('Revenue', 'Product Sales', 45000000),
            ('Revenue', 'Service Revenue', 28000000),
            ('Revenue', 'Consulting', 15000000),
            ('Revenue', 'Licensing', 8000000),
            ('COGS', 'Direct Materials', -18000000),
            ('COGS', 'Direct Labor', -12000000),
            ('COGS', 'Manufacturing Overhead', -6000000),
            ('OpEx', 'Salaries & Wages', -22000000),
            ('OpEx', 'Benefits', -5500000),
            ('OpEx', 'Rent & Facilities', -3200000),
            ('OpEx', 'Technology', -2800000),
            ('OpEx', 'Marketing', -4500000),
            ('OpEx', 'Professional Services', -1800000),
            ('OpEx', 'Travel & Entertainment', -1200000),
            ('OpEx', 'Depreciation', -2000000),
            ('Other', 'Interest Income', 500000),
            ('Other', 'Interest Expense', -800000),
        ]
        
        corp_data = []
        months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
        
        for cat, line_item, annual_budget in categories:
            monthly_budget = annual_budget / 12
            
            # Create monthly breakdown
            row = {
                'Category': cat,
                'Line_Item': line_item,
                'Annual_Budget': annual_budget,
            }
            
            for i, month in enumerate(months):
                # Add seasonality
                seasonality = 1.0 + 0.1 * np.sin((i - 3) * np.pi / 6)  # Peak in summer
                budget_val = monthly_budget * seasonality
                
                # Actuals for past months
                if i < current_month:
                    actual_val = budget_val * random.uniform(0.9, 1.1)
                    forecast_val = actual_val  # Forecast = Actual for past
                else:
                    actual_val = 0
                    forecast_val = budget_val * random.uniform(0.95, 1.05)
                
                row[f'{month}_Budget'] = round(budget_val, 0)
                row[f'{month}_Actual'] = round(actual_val, 0)
                row[f'{month}_Forecast'] = round(forecast_val, 0)
            
            corp_data.append(row)
        
        st.session_state.corp_forecast_data = pd.DataFrame(corp_data)
    
    corp_df = st.session_state.corp_forecast_data.copy()
    months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    
    # Calculate summary metrics
    revenue_budget = corp_df[corp_df['Category'] == 'Revenue']['Annual_Budget'].sum()
    revenue_ytd = sum(corp_df[corp_df['Category'] == 'Revenue'][f'{m}_Actual'].sum() for m in months[:current_month])
    
    cogs_budget = abs(corp_df[corp_df['Category'] == 'COGS']['Annual_Budget'].sum())
    opex_budget = abs(corp_df[corp_df['Category'] == 'OpEx']['Annual_Budget'].sum())
    
    gross_profit = revenue_budget - cogs_budget
    operating_income = gross_profit - opex_budget
    
    # KPIs
    k1, k2, k3, k4, k5, k6 = st.columns(6)
    with k1:
        st.metric("Revenue Budget", f"${revenue_budget/1e6:.1f}M")
    with k2:
        st.metric("Gross Profit", f"${gross_profit/1e6:.1f}M")
    with k3:
        st.metric("Operating Exp", f"${opex_budget/1e6:.1f}M")
    with k4:
        st.metric("Operating Income", f"${operating_income/1e6:.1f}M")
    with k5:
        st.metric("YTD Actuals", f"${revenue_ytd/1e6:.1f}M")
    with k6:
        pct_to_budget = (revenue_ytd / (revenue_budget * current_month / 12)) * 100 if revenue_budget != 0 else 0
        st.metric("% to Budget", f"{pct_to_budget:.1f}%")
    
    st.markdown("---")
    
    # View selector
    corp_view = st.radio("View", ["P&L Summary", "Monthly Trend", "Category Detail", "Line Item Detail"], 
                        horizontal=True, key="corp_view_type")
    
    if corp_view == "P&L Summary":
        st.markdown("#####  P&L Summary")
        
        # Build P&L statement
        pl_data = []
        
        # Revenue
        rev_total = corp_df[corp_df['Category'] == 'Revenue']['Annual_Budget'].sum()
        pl_data.append({'Line': 'Revenue', 'Budget': rev_total, 'Type': 'header'})
        for _, row in corp_df[corp_df['Category'] == 'Revenue'].iterrows():
            pl_data.append({'Line': f"  {row['Line_Item']}", 'Budget': row['Annual_Budget'], 'Type': 'detail'})
        
        # COGS
        cogs_total = corp_df[corp_df['Category'] == 'COGS']['Annual_Budget'].sum()
        pl_data.append({'Line': 'Cost of Goods Sold', 'Budget': cogs_total, 'Type': 'header'})
        for _, row in corp_df[corp_df['Category'] == 'COGS'].iterrows():
            pl_data.append({'Line': f"  {row['Line_Item']}", 'Budget': row['Annual_Budget'], 'Type': 'detail'})
        
        # Gross Profit
        pl_data.append({'Line': 'Gross Profit', 'Budget': rev_total + cogs_total, 'Type': 'total'})
        
        # OpEx
        opex_total = corp_df[corp_df['Category'] == 'OpEx']['Annual_Budget'].sum()
        pl_data.append({'Line': 'Operating Expenses', 'Budget': opex_total, 'Type': 'header'})
        for _, row in corp_df[corp_df['Category'] == 'OpEx'].iterrows():
            pl_data.append({'Line': f"  {row['Line_Item']}", 'Budget': row['Annual_Budget'], 'Type': 'detail'})
        
        # Operating Income
        pl_data.append({'Line': 'Operating Income', 'Budget': rev_total + cogs_total + opex_total, 'Type': 'total'})
        
        pl_df = pd.DataFrame(pl_data)
        
        st.dataframe(
            pl_df[['Line', 'Budget']],
            column_config={
                'Line': st.column_config.TextColumn('Line Item', width='large'),
                'Budget': st.column_config.NumberColumn('Annual Budget', format='$%.0f')
            },
            use_container_width=True,
            hide_index=True,
            height=500
        )
    
    elif corp_view == "Monthly Trend":
        st.markdown("#####  Monthly Trend")
        
        # Calculate monthly totals by category
        monthly_data = []
        for month in months:
            rev = corp_df[corp_df['Category'] == 'Revenue'][f'{month}_Budget'].sum()
            cogs = abs(corp_df[corp_df['Category'] == 'COGS'][f'{month}_Budget'].sum())
            opex = abs(corp_df[corp_df['Category'] == 'OpEx'][f'{month}_Budget'].sum())
            
            monthly_data.append({
                'Month': month,
                'Revenue': rev,
                'COGS': cogs,
                'Gross_Profit': rev - cogs,
                'OpEx': opex,
                'Operating_Income': rev - cogs - opex
            })
        
        monthly_df = pd.DataFrame(monthly_data)
        
        # Chart
        st.line_chart(
            monthly_df.set_index('Month')[['Revenue', 'Gross_Profit', 'Operating_Income']],
            use_container_width=True,
            height=300
        )
        
        st.dataframe(
            monthly_df,
            column_config={
                'Month': st.column_config.TextColumn('Month'),
                'Revenue': st.column_config.NumberColumn('Revenue', format='$%.0f'),
                'COGS': st.column_config.NumberColumn('COGS', format='$%.0f'),
                'Gross_Profit': st.column_config.NumberColumn('Gross Profit', format='$%.0f'),
                'OpEx': st.column_config.NumberColumn('OpEx', format='$%.0f'),
                'Operating_Income': st.column_config.NumberColumn('Op. Income', format='$%.0f')
            },
            use_container_width=True,
            hide_index=True
        )
    
    elif corp_view == "Category Detail":
        st.markdown("#####  Category Detail")
        
        selected_cat = st.selectbox("Category", ['Revenue', 'COGS', 'OpEx', 'Other'], key="corp_cat_select")
        
        cat_df = corp_df[corp_df['Category'] == selected_cat].copy()
        
        # Calculate totals
        cat_df['YTD_Actual'] = sum(cat_df[f'{m}_Actual'] for m in months[:current_month])
        cat_df['YTD_Budget'] = sum(cat_df[f'{m}_Budget'] for m in months[:current_month])
        cat_df['Full_Year_Forecast'] = sum(cat_df[f'{m}_Forecast'] for m in months)
        cat_df['Variance'] = cat_df['Full_Year_Forecast'] - cat_df['Annual_Budget']
        cat_df['Var_%'] = (cat_df['Variance'] / abs(cat_df['Annual_Budget']) * 100).round(1)
        
        st.dataframe(
            cat_df[['Line_Item', 'Annual_Budget', 'YTD_Actual', 'YTD_Budget', 'Full_Year_Forecast', 'Variance', 'Var_%']],
            column_config={
                'Line_Item': st.column_config.TextColumn('Line Item'),
                'Annual_Budget': st.column_config.NumberColumn('Annual Budget', format='$%.0f'),
                'YTD_Actual': st.column_config.NumberColumn('YTD Actual', format='$%.0f'),
                'YTD_Budget': st.column_config.NumberColumn('YTD Budget', format='$%.0f'),
                'Full_Year_Forecast': st.column_config.NumberColumn('FY Forecast', format='$%.0f'),
                'Variance': st.column_config.NumberColumn('Variance', format='$%.0f'),
                'Var_%': st.column_config.NumberColumn('Var %', format='%.1f%%')
            },
            use_container_width=True,
            hide_index=True
        )
    
    else:  # Line Item Detail
        st.markdown("#####  Line Item Detail")
        
        # Show all line items with monthly breakdown
        detail_cols = ['Category', 'Line_Item', 'Annual_Budget']
        for month in months:
            detail_cols.extend([f'{month}_Budget', f'{month}_Actual', f'{month}_Forecast'])
        
        # Calculate variance columns
        corp_df['Total_Forecast'] = sum(corp_df[f'{m}_Forecast'] for m in months)
        corp_df['Total_Variance'] = corp_df['Total_Forecast'] - corp_df['Annual_Budget']
        corp_df['Var_%'] = (corp_df['Total_Variance'] / abs(corp_df['Annual_Budget']) * 100).round(1)
        
        st.dataframe(
            corp_df[['Category', 'Line_Item', 'Annual_Budget', 'Total_Forecast', 'Total_Variance', 'Var_%']],
            column_config={
                'Category': st.column_config.TextColumn('Category'),
                'Line_Item': st.column_config.TextColumn('Line Item'),
                'Annual_Budget': st.column_config.NumberColumn('Annual Budget', format='$%.0f'),
                'Total_Forecast': st.column_config.NumberColumn('Full Year Forecast', format='$%.0f'),
                'Total_Variance': st.column_config.NumberColumn('Variance', format='$%.0f'),
                'Var_%': st.column_config.NumberColumn('Variance %', format='%.1f%%')
            },
            use_container_width=True,
            hide_index=True,
            height=500
        )


# =============================================================================
# PAGE: AI ASSISTANT
# =============================================================================

elif page == " AI Assistant":
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        " Financial Chat", 
        " Variance Explanation",
        " Forecast Accuracy",
        " AI Insights",
        " Configuration"
    ])
    
    ai_assistant = st.session_state.ai_assistant
    
    # Default to Gemini if not configured (user needs to add their own API key)
    if not ai_assistant.is_configured():
        ai_assistant.provider = 'gemini'
        ai_assistant.model = 'gemini-1.5-flash'
    
    # Check if data is loaded
    data_loaded = (
        not st.session_state.budget_data.empty or
        not st.session_state.contract_data.empty or
        not st.session_state.capex_projects.empty or
        not st.session_state.cash_flow_data.empty
    )
    
    if not data_loaded:
        st.warning(" **No data loaded!** Go to the Home page and click ' Load Sample Data' to load comprehensive sample data for AI analysis.")
        st.info("""
        **Sample data includes:**
        - Budget data with variances by category
        - 25 contracts with performance metrics  
        - 13-week cash flow forecast
        - 20 CapEx projects
        - 50 resource records
        """)
    
    with tab1:
        st.markdown("###  AI Financial Chat")
        st.caption("Ask questions about your budget, forecasts, variances, and financial performance")
        
        if ai_assistant.is_configured():
            provider_name = AIAssistant.PROVIDERS.get(ai_assistant.provider, {}).get('name', ai_assistant.provider)
            st.success(f" Connected to {provider_name}")
        else:
            st.warning(" AI not configured. Go to Configuration tab and choose your model.")
        
        # Chat interface
        st.markdown("---")
        
        # Display chat history
        chat_container = st.container()
        
        with chat_container:
            for i, msg in enumerate(st.session_state.ai_chat_history):
                if msg['role'] == 'user':
                    st.markdown(f"""
                    <div style='background-color: #e3f2fd; padding: 10px 15px; border-radius: 10px; margin: 5px 0; margin-left: 20%;'>
                        <strong>You:</strong> {msg['content']}
                    </div>
                    """, unsafe_allow_html=True)
                else:
                    st.markdown(f"""
                    <div style='background-color: #f5f5f5; padding: 10px 15px; border-radius: 10px; margin: 5px 0; margin-right: 20%;'>
                        <strong>AI:</strong> {msg['content']}
                    </div>
                    """, unsafe_allow_html=True)
        
        # Input area
        st.markdown("---")
        
        col1, col2 = st.columns([5, 1])
        
        with col1:
            user_input = st.text_area("Ask a financial question...", key="ai_user_input", height=80,
                                      placeholder="e.g., Why is Labor over budget this quarter? What's driving the variance in Materials?")
        
        with col2:
            st.markdown("<br>", unsafe_allow_html=True)
            send_button = st.button(" Send", type="primary", use_container_width=True)
            clear_button = st.button(" Clear", use_container_width=True)
        
        if clear_button:
            st.session_state.ai_chat_history = []
            ai_assistant.clear_history()
            st.rerun()
        
        if send_button and user_input.strip():
            if not ai_assistant.is_configured():
                st.error("Please configure the AI Assistant first.")
            else:
                st.session_state.ai_chat_history.append({
                    'role': 'user',
                    'content': user_input
                })
                
                # Get data context
                context = ai_assistant.get_data_summary(st.session_state)
                
                with st.spinner("Analyzing..."):
                    response = ai_assistant.chat(user_input, context)
                
                if response['success']:
                    st.session_state.ai_chat_history.append({
                        'role': 'assistant',
                        'content': response['response']
                    })
                else:
                    st.session_state.ai_chat_history.append({
                        'role': 'assistant',
                        'content': f" Error: {response['response']}"
                    })
                
                st.rerun()
        
        # Quick financial prompts
        st.markdown("---")
        st.markdown("**Quick Financial Questions:**")
        
        col1, col2, col3, col4 = st.columns(4)
        
        quick_prompts = [
            (" Budget Status", "Give me a summary of our current budget status including total budget, actuals, and variance by category."),
            (" Top Variances", "What are the top 5 cost centers or categories with the largest unfavorable variances and why?"),
            (" Cash Forecast", "What's our projected cash position for the next 13 weeks based on current trends?"),
            (" Forecast Accuracy", "How accurate have our forecasts been compared to actuals? Where are we consistently over or under?")
        ]
        
        for i, (label, prompt) in enumerate(quick_prompts):
            with [col1, col2, col3, col4][i]:
                if st.button(label, use_container_width=True, key=f"quick_{i}"):
                    # Execute the quick prompt directly
                    st.session_state.ai_chat_history.append({
                        'role': 'user',
                        'content': prompt
                    })
                    
                    context = ai_assistant.get_data_summary(st.session_state)
                    
                    with st.spinner(f"Analyzing {label}..."):
                        response = ai_assistant.chat(prompt, context)
                    
                    if response['success']:
                        st.session_state.ai_chat_history.append({
                            'role': 'assistant',
                            'content': response['response']
                        })
                    else:
                        st.session_state.ai_chat_history.append({
                            'role': 'assistant',
                            'content': f" Error: {response['response']}"
                        })
                    st.rerun()
    
    with tab2:
        st.markdown("###  AI Variance Explanation")
        st.caption("Get AI-powered explanations for budget variances")
        
        if st.session_state.budget_data.empty:
            st.info("Load budget data to analyze variances.")
        else:
            # Variance Analysis Section
            st.markdown("#### Select Variance to Analyze")
            
            df = st.session_state.budget_data
            
            # Calculate variances by category if columns exist
            if 'Account_Category' in df.columns and 'Budget' in df.columns and 'Actual' in df.columns:
                variance_df = df.groupby('Account_Category').agg({
                    'Budget': 'sum',
                    'Actual': 'sum'
                }).reset_index()
                variance_df['Variance'] = variance_df['Actual'] - variance_df['Budget']
                variance_df['Variance_Pct'] = (variance_df['Variance'] / variance_df['Budget'] * 100).round(1)
                variance_df = variance_df.sort_values('Variance', key=abs, ascending=False)
                
                # Display variance table
                st.dataframe(
                    variance_df.style.format({
                        'Budget': '${:,.0f}',
                        'Actual': '${:,.0f}',
                        'Variance': '${:,.0f}',
                        'Variance_Pct': '{:.1f}%'
                    }).background_gradient(subset=['Variance'], cmap='RdYlGn_r'),
                    use_container_width=True,
                    hide_index=True
                )
                
                st.markdown("---")
                
                # Select category for detailed explanation
                selected_category = st.selectbox(
                    "Select category for AI explanation",
                    variance_df['Account_Category'].tolist()
                )
                
                if st.button(" Explain This Variance", type="primary"):
                    cat_data = variance_df[variance_df['Account_Category'] == selected_category].iloc[0]
                    
                    prompt = f"""Analyze and explain the variance for {selected_category}:
                    - Budget: ${cat_data['Budget']:,.0f}
                    - Actual: ${cat_data['Actual']:,.0f}
                    - Variance: ${cat_data['Variance']:,.0f} ({cat_data['Variance_Pct']:.1f}%)
                    
                    Provide:
                    1. Likely root causes for this variance
                    2. Whether this is a timing issue, scope change, or systematic problem
                    3. Recommended actions to address unfavorable variances
                    4. Risk assessment if this trend continues"""
                    
                    context = ai_assistant.get_data_summary(st.session_state)
                    
                    with st.spinner("Analyzing variance..."):
                        response = ai_assistant.chat(prompt, context)
                    
                    if response['success']:
                        st.markdown("#### AI Analysis")
                        st.markdown(response['response'])
                    else:
                        st.error(f"Error: {response['response']}")
            else:
                st.warning("Budget data needs 'Account_Category', 'Budget', and 'Actual' columns for variance analysis.")
        
        # Enhanced budget data variance if available
        if 'budget_data_enhanced' in st.session_state and not st.session_state.budget_data_enhanced.empty:
            st.markdown("---")
            st.markdown("#### Monthly Variance Trend Analysis")
            
            edf = st.session_state.budget_data_enhanced
            if 'Month' in edf.columns:
                # Ask AI to analyze monthly trends
                if st.button(" Analyze Monthly Variance Trends"):
                    monthly_summary = edf.groupby('Month').agg({
                        'Budget': 'sum',
                        'Actual': 'sum'
                    }).reset_index() if 'Actual' in edf.columns else None
                    
                    if monthly_summary is not None:
                        prompt = f"""Analyze this monthly budget vs actual trend:
                        {monthly_summary.to_string()}
                        
                        Identify:
                        1. Seasonal patterns in variances
                        2. Months with concerning variances
                        3. Whether variances are improving or worsening over time
                        4. Forecast for remaining months based on trends"""
                        
                        with st.spinner("Analyzing trends..."):
                            response = ai_assistant.chat(prompt, "")
                        
                        if response['success']:
                            st.markdown(response['response'])
    
    with tab3:
        st.markdown("###  Forecast Accuracy Analysis")
        st.caption("Measure and improve your forecasting accuracy")
        
        if st.session_state.budget_data.empty:
            st.info("Load budget data to analyze forecast accuracy.")
        else:
            df = st.session_state.budget_data
            
            # Forecast accuracy metrics
            st.markdown("#### Accuracy Metrics")
            
            if 'Budget' in df.columns and 'Actual' in df.columns:
                total_budget = df['Budget'].sum()
                total_actual = df['Actual'].sum()
                total_variance = total_actual - total_budget
                accuracy_pct = (1 - abs(total_variance) / total_budget) * 100 if total_budget > 0 else 0
                
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("Total Budget", f"${total_budget/1e6:.1f}M")
                with col2:
                    st.metric("Total Actual", f"${total_actual/1e6:.1f}M")
                with col3:
                    st.metric("Variance", f"${total_variance/1e6:.1f}M", 
                             delta=f"{(total_variance/total_budget*100):.1f}%" if total_budget > 0 else "N/A")
                with col4:
                    st.metric("Forecast Accuracy", f"{accuracy_pct:.1f}%")
                
                st.markdown("---")
                
                # Accuracy by category
                if 'Account_Category' in df.columns:
                    st.markdown("#### Accuracy by Category")
                    
                    cat_accuracy = df.groupby('Account_Category').agg({
                        'Budget': 'sum',
                        'Actual': 'sum'
                    }).reset_index()
                    cat_accuracy['Variance'] = cat_accuracy['Actual'] - cat_accuracy['Budget']
                    cat_accuracy['Accuracy'] = (1 - abs(cat_accuracy['Variance']) / cat_accuracy['Budget']) * 100
                    cat_accuracy['Accuracy'] = cat_accuracy['Accuracy'].clip(0, 100)
                    cat_accuracy = cat_accuracy.sort_values('Accuracy', ascending=True)
                    
                    # Accuracy chart
                    fig = go.Figure()
                    colors = ['#dc3545' if acc < 80 else '#ffc107' if acc < 90 else '#28a745' for acc in cat_accuracy['Accuracy']]
                    fig.add_trace(go.Bar(
                        x=cat_accuracy['Accuracy'],
                        y=cat_accuracy['Account_Category'],
                        orientation='h',
                        marker_color=colors,
                        text=cat_accuracy['Accuracy'].apply(lambda x: f"{x:.1f}%"),
                        textposition='outside'
                    ))
                    fig.update_layout(
                        title="Forecast Accuracy by Category",
                        xaxis_title="Accuracy %",
                        yaxis_title="",
                        height=300,
                        xaxis_range=[0, 110]
                    )
                    st.plotly_chart(fig, use_container_width=True)
                    
                    # AI recommendations
                    st.markdown("---")
                    if st.button(" Get AI Recommendations to Improve Accuracy", type="primary"):
                        prompt = f"""Based on this forecast accuracy data by category:
                        {cat_accuracy.to_string()}
                        
                        Overall accuracy: {accuracy_pct:.1f}%
                        
                        Provide specific recommendations to improve forecast accuracy for:
                        1. The categories with lowest accuracy
                        2. Systematic biases (are we consistently over or under-forecasting?)
                        3. Process improvements for budget planning
                        4. Key metrics to monitor going forward"""
                        
                        context = ai_assistant.get_data_summary(st.session_state)
                        
                        with st.spinner("Generating recommendations..."):
                            response = ai_assistant.chat(prompt, context)
                        
                        if response['success']:
                            st.markdown("#### AI Recommendations")
                            st.markdown(response['response'])
                        else:
                            st.error(f"Error: {response['response']}")
            else:
                st.warning("Need 'Budget' and 'Actual' columns for accuracy analysis.")
    
    with tab4:
        st.markdown("###  AI-Powered Insights")
        st.caption("Automated financial insights and anomaly detection")
        
        st.markdown("#### Data Summary")
        
        # Show current data status
        data_status = []
        
        if not st.session_state.budget_data.empty:
            bdf = st.session_state.budget_data
            data_status.append({
                'Dataset': 'Budget Data',
                'Records': len(bdf),
                'Total': f"${bdf['Budget'].sum()/1e6:.1f}M" if 'Budget' in bdf.columns else 'N/A',
                'Status': ''
            })
        
        if not st.session_state.capex_projects.empty:
            cdf = st.session_state.capex_projects
            data_status.append({
                'Dataset': 'CapEx Projects',
                'Records': len(cdf),
                'Total': f"${cdf['Budget_2025'].sum()/1e6:.1f}M" if 'Budget_2025' in cdf.columns else 'N/A',
                'Status': ''
            })
        
        if not st.session_state.contract_data.empty:
            condf = st.session_state.contract_data
            data_status.append({
                'Dataset': 'Contracts',
                'Records': len(condf),
                'Total': f"${condf['Contract_Value'].sum()/1e6:.1f}M" if 'Contract_Value' in condf.columns else 'N/A',
                'Status': ''
            })
        
        if data_status:
            st.dataframe(pd.DataFrame(data_status), use_container_width=True, hide_index=True)
        else:
            st.info("No data loaded. Use 'Load Sample Data' to get started.")
        
        st.markdown("---")
        st.markdown("#### Generate Insights")
        
        insight_type = st.selectbox(
            "Select insight type",
            ["Executive Summary", "Risk Assessment", "Cost Optimization Opportunities", "Performance Trends", "Anomaly Detection"]
        )
        
        insight_prompts = {
            "Executive Summary": "Provide an executive summary of our current financial position including budget performance, key variances, cash position, and top risks. Format for a CFO briefing.",
            "Risk Assessment": "Identify the top 5 financial risks based on current data including budget overruns, contract performance issues, cash flow concerns, and resource constraints. Rate each risk and suggest mitigation strategies.",
            "Cost Optimization Opportunities": "Analyze our spending patterns and identify the top opportunities for cost optimization. Consider vendor consolidation, process efficiency, and resource reallocation.",
            "Performance Trends": "Analyze performance trends across all data sets. Identify improving and deteriorating areas. Project forward trends for the next quarter.",
            "Anomaly Detection": "Identify any anomalies or unusual patterns in the financial data that warrant investigation. Flag any data quality issues."
        }
        
        if st.button(" Generate Insight", type="primary"):
            prompt = insight_prompts[insight_type]
            context = ai_assistant.get_data_summary(st.session_state)
            
            with st.spinner(f"Generating {insight_type}..."):
                response = ai_assistant.chat(prompt, context)
            
            if response['success']:
                st.markdown(f"#### {insight_type}")
                st.markdown(response['response'])
                
                # Option to save insight
                if st.button(" Save to Report"):
                    if 'saved_insights' not in st.session_state:
                        st.session_state.saved_insights = []
                    st.session_state.saved_insights.append({
                        'type': insight_type,
                        'content': response['response'],
                        'timestamp': datetime.now().isoformat()
                    })
                    st.success("Insight saved!")
            else:
                st.error(f"Error: {response['response']}")
    
    with tab5:
        st.markdown("###  AI Configuration")
        st.caption("Configure AI provider and API credentials")
        
        # Current status
        if ai_assistant.is_configured():
            provider_name = AIAssistant.PROVIDERS.get(ai_assistant.provider, {}).get('name', ai_assistant.provider)
            st.success(f" Currently using: {provider_name}")
            
            # Test connection button
            if st.button(" Test AI Connection"):
                with st.spinner("Testing connection..."):
                    test_response = ai_assistant.chat("Say 'Connection successful!' if you can hear me.", "")
                
                if test_response['success']:
                    st.success(f" AI Response: {test_response['response'][:200]}")
                else:
                    st.error(f" Test failed: {test_response['response']}")
                    if "Cannot connect" in test_response['response'] or "blocked" in test_response['response'].lower():
                        st.info(" **Tip:** Some network environments block external API calls. Try running the app locally.")
        else:
            st.warning(" Not configured")
        
        st.markdown("---")
        st.markdown("### Select AI Provider")
        st.info(" **Recommended:** Google Gemini offers free API access. Get your key at [ai.google.dev](https://ai.google.dev)")
        
        provider = st.selectbox(
            "AI Provider",
            options=['gemini', 'openai', 'anthropic', 'azure', 'aixplain', 'incorta'],
            format_func=lambda x: AIAssistant.PROVIDERS[x]['name']
        )
        
        st.markdown("---")
        
        # Provider-specific configuration
        with st.form("ai_config_form"):
            st.markdown(f"### Configure {AIAssistant.PROVIDERS[provider]['name']}")
            
            api_key = st.text_input("API Key", value="", type="password", 
                                   help="Your API key for the selected provider")
            
            model_options = AIAssistant.PROVIDERS[provider]['models']
            
            if provider == 'aixplain':
                model = st.text_input("Model ID", value="")
            else:
                model = st.selectbox("Model", options=model_options, index=0)
            
            # Provider-specific fields
            azure_endpoint = None
            azure_deployment = None
            incorta_url = None
            incorta_tenant = None
            
            if provider == 'azure':
                st.markdown("#### Azure-Specific Settings")
                azure_endpoint = st.text_input("Azure Endpoint", placeholder="https://your-resource.openai.azure.com")
                azure_deployment = st.text_input("Deployment Name", placeholder="your-deployment-name")
            
            elif provider == 'incorta':
                st.markdown("#### Incorta-Specific Settings")
                incorta_url = st.text_input("Incorta URL", placeholder="https://your-instance.incorta.com")
                incorta_tenant = st.text_input("Tenant Name")
            
            submitted = st.form_submit_button(" Save Configuration", type="primary")
            
            if submitted:
                if not api_key:
                    st.error("API Key is required")
                elif provider == 'azure' and (not azure_endpoint or not azure_deployment):
                    st.error("Azure endpoint and deployment name are required")
                elif provider == 'incorta' and (not incorta_url or not incorta_tenant):
                    st.error("Incorta URL and tenant are required")
                else:
                    result = ai_assistant.configure(
                        provider=provider,
                        api_key=api_key,
                        model=model,
                        azure_endpoint=azure_endpoint,
                        azure_deployment=azure_deployment,
                        incorta_url=incorta_url,
                        incorta_tenant=incorta_tenant
                    )
                    
                    if result['success']:
                        st.success(f" {result['message']}")
                        st.session_state.ai_config = {
                            'provider': provider,
                            'model': model
                        }
                    else:
                        st.error(f" {result['message']}")
        
        # Provider info
        st.markdown("---")
        st.markdown("### Provider Information")
        
        provider_info = {
            'aixplain': "AIxplain Financial AI - Pre-configured for financial analysis. API key and model ID are set by default.",
            'openai': "Get your API key from https://platform.openai.com/api-keys",
            'anthropic': "Get your API key from https://console.anthropic.com/",
            'azure': "Get credentials from your Azure OpenAI resource in Azure Portal",
            'gemini': "Get your API key from https://makersuite.google.com/app/apikey",
            'incorta': "Use your Incorta instance URL and API token from Admin settings"
        }
        
        st.info(provider_info.get(provider, ""))


# =============================================================================
# PAGE: AI AGENTS
# =============================================================================

elif page == " AI Agents":
    st.markdown("###  AI Agents")
    st.caption("Autonomous AI agents for automated business processes")
    
    # Agent tabs
    agent_tabs = st.tabs([
        " AP Agent",
        " More Agents Coming Soon"
    ])
    
    # =========================================================================
    # TAB 1: AP (ACCOUNTS PAYABLE) AGENT
    # =========================================================================
    with agent_tabs[0]:
        st.markdown("####  Accounts Payable Agent")
        st.caption("Automated invoice processing, validation, and payment scheduling")
        
        # Agent Status
        if 'ap_agent_status' not in st.session_state:
            st.session_state.ap_agent_status = 'stopped'
        if 'ap_agent_queue' not in st.session_state:
            st.session_state.ap_agent_queue = []
        if 'ap_agent_processed' not in st.session_state:
            st.session_state.ap_agent_processed = []
        
        # Status indicators
        status_col1, status_col2, status_col3, status_col4 = st.columns(4)
        
        with status_col1:
            status_icon = "" if st.session_state.ap_agent_status == 'running' else ""
            st.metric("Agent Status", f"{status_icon} {st.session_state.ap_agent_status.title()}")
        with status_col2:
            st.metric("Queue Size", len(st.session_state.ap_agent_queue))
        with status_col3:
            st.metric("Processed Today", len(st.session_state.ap_agent_processed))
        with status_col4:
            total_value = sum(inv.get('amount', 0) for inv in st.session_state.ap_agent_processed)
            st.metric("Total Processed", f"${total_value:,.0f}")
        
        st.markdown("---")
        
        # Agent Controls
        ctrl_col1, ctrl_col2, ctrl_col3 = st.columns(3)
        
        with ctrl_col1:
            if st.session_state.ap_agent_status == 'stopped':
                if st.button(" Start Agent", type="primary", key="ap_start"):
                    st.session_state.ap_agent_status = 'running'
                    st.toast(" AP Agent started")
                    st.rerun()
            else:
                if st.button(" Stop Agent", type="secondary", key="ap_stop"):
                    st.session_state.ap_agent_status = 'stopped'
                    st.toast(" AP Agent stopped")
                    st.rerun()
        
        with ctrl_col2:
            if st.button(" Process Queue", key="ap_process", disabled=st.session_state.ap_agent_status == 'stopped'):
                if st.session_state.ap_agent_queue:
                    # Process one invoice from queue
                    invoice = st.session_state.ap_agent_queue.pop(0)
                    invoice['status'] = 'processed'
                    invoice['processed_at'] = datetime.now().strftime('%Y-%m-%d %H:%M')
                    st.session_state.ap_agent_processed.append(invoice)
                    st.toast(f" Processed invoice {invoice.get('invoice_num', 'N/A')}")
                    st.rerun()
                else:
                    st.toast("Queue is empty")
        
        with ctrl_col3:
            if st.button(" Add Sample Invoices", key="ap_add_sample"):
                # Add sample invoices to queue
                vendors = ['Acme Supplies', 'Tech Parts Inc', 'Office Depot', 'Industrial Co', 'Service Pro']
                for i in range(5):
                    invoice = {
                        'invoice_num': f'INV-{datetime.now().strftime("%Y%m%d")}-{random.randint(1000, 9999)}',
                        'vendor': random.choice(vendors),
                        'amount': random.randint(500, 50000),
                        'due_date': (datetime.now() + timedelta(days=random.randint(15, 45))).strftime('%Y-%m-%d'),
                        'status': 'pending',
                        'gl_account': f'{random.randint(5000, 6999)}-{random.randint(100, 999)}',
                        'department': random.choice(['Operations', 'Engineering', 'Admin', 'Sales']),
                        'created_at': datetime.now().strftime('%Y-%m-%d %H:%M')
                    }
                    st.session_state.ap_agent_queue.append(invoice)
                st.toast(" Added 5 sample invoices to queue")
                st.rerun()
        
        st.markdown("---")
        
        # Agent Configuration (simplified)
        with st.expander(" Agent Configuration", expanded=False):
            st.markdown("**Processing Rules**")
            st.markdown("- Auto-approve limit: $5,000")
            st.markdown("- 2-way match required (PO + Invoice)")
            st.markdown("- Auto-schedule payments: Enabled")
            st.markdown("")
            st.markdown("**Validation Rules**")
            st.markdown("- Validate vendor exists in master")
            st.markdown("- Check for duplicate invoices")
            st.markdown("- Validate GL account codes")
            st.markdown("- Flag invoices over budget")
            st.caption("*Contact admin to modify configuration*")
        
        # Invoice Queue
        st.markdown("#####  Invoice Queue")
        
        if st.session_state.ap_agent_queue:
            queue_df = pd.DataFrame(st.session_state.ap_agent_queue)
            
            st.dataframe(
                queue_df,
                column_config={
                    'invoice_num': st.column_config.TextColumn('Invoice #'),
                    'vendor': st.column_config.TextColumn('Vendor'),
                    'amount': st.column_config.NumberColumn('Amount', format='$%.2f'),
                    'due_date': st.column_config.TextColumn('Due Date'),
                    'status': st.column_config.TextColumn('Status'),
                    'gl_account': st.column_config.TextColumn('GL Account'),
                    'department': st.column_config.TextColumn('Department'),
                    'created_at': st.column_config.TextColumn('Created')
                },
                use_container_width=True,
                hide_index=True,
                height=200
            )
        else:
            st.info("No invoices in queue. Click 'Add Sample Invoices' to test the agent.")
        
        # Processed Invoices
        st.markdown("#####  Recently Processed")
        
        if st.session_state.ap_agent_processed:
            processed_df = pd.DataFrame(st.session_state.ap_agent_processed)
            
            st.dataframe(
                processed_df,
                column_config={
                    'invoice_num': st.column_config.TextColumn('Invoice #'),
                    'vendor': st.column_config.TextColumn('Vendor'),
                    'amount': st.column_config.NumberColumn('Amount', format='$%.2f'),
                    'due_date': st.column_config.TextColumn('Due Date'),
                    'status': st.column_config.TextColumn('Status'),
                    'gl_account': st.column_config.TextColumn('GL Account'),
                    'department': st.column_config.TextColumn('Department'),
                    'processed_at': st.column_config.TextColumn('Processed At')
                },
                use_container_width=True,
                hide_index=True,
                height=200
            )
        else:
            st.info("No processed invoices yet.")
        
        # Agent Activity Log
        st.markdown("#####  Agent Activity Log")
        
        log_entries = [
            f"[{datetime.now().strftime('%H:%M:%S')}] AP Agent initialized",
            f"[{(datetime.now() - timedelta(minutes=5)).strftime('%H:%M:%S')}] Configuration loaded",
            f"[{(datetime.now() - timedelta(minutes=10)).strftime('%H:%M:%S')}] Connected to ERP system",
        ]
        
        if st.session_state.ap_agent_status == 'running':
            log_entries.insert(0, f"[{datetime.now().strftime('%H:%M:%S')}] Agent is running - monitoring queue...")
        
        for entry in log_entries[:10]:
            st.text(entry)
    
    # =========================================================================
    # TAB 2: PLACEHOLDER FOR MORE AGENTS
    # =========================================================================
    with agent_tabs[1]:
        st.markdown("####  Additional AI Agents")
        st.caption("Coming soon - more autonomous agents for business automation")
        
        st.markdown("---")
        
        # Placeholder cards for future agents
        future_agents = [
            {
                'name': ' AR Agent',
                'description': 'Accounts Receivable automation - invoice generation, collections, and cash application',
                'status': 'Planned'
            },
            {
                'name': ' Reporting Agent',
                'description': 'Automated financial report generation and distribution',
                'status': 'Planned'
            },
            {
                'name': ' Audit Agent',
                'description': 'Continuous monitoring and anomaly detection for financial transactions',
                'status': 'Planned'
            },
            {
                'name': ' Forecasting Agent',
                'description': 'AI-powered financial forecasting and trend analysis',
                'status': 'Planned'
            },
            {
                'name': ' Treasury Agent',
                'description': 'Cash management and bank reconciliation automation',
                'status': 'Planned'
            },
            {
                'name': ' Procurement Agent',
                'description': 'Purchase order processing and vendor management',
                'status': 'Planned'
            }
        ]
        
        # Display in 2 columns
        col1, col2 = st.columns(2)
        
        for i, agent in enumerate(future_agents):
            with col1 if i % 2 == 0 else col2:
                with st.container():
                    st.markdown(f"**{agent['name']}**")
                    st.caption(agent['description'])
                    st.markdown(f"*Status: {agent['status']}*")
                    st.markdown("---")
        
        st.info(" Have an idea for a new agent? Contact your system administrator to request new automation capabilities.")


# =============================================================================
# PAGE: TEMPLATES
# =============================================================================

elif page == " Templates":
    tab1, tab2, tab3 = st.tabs([" View Templates", " Advanced Template Builder", " Import/Export"])
    
    # Initialize template storage if needed
    if 'budget_templates' not in st.session_state:
        st.session_state.budget_templates = {}
    
    if 'advanced_templates' not in st.session_state:
        st.session_state.advanced_templates = {
            'Kewaunee Roll Up': {
                'id': 'kew_rollup_001',
                'name': 'Kewaunee Roll Up',
                'description': 'Kewaunee project budget roll-up format with monthly columns',
                'created_by': 'System',
                'created_date': datetime.now().strftime('%Y-%m-%d'),
                'sheet_name': 'Roll Up',
                'label_column': 0,
                'month_columns': {1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr', 5: 'May', 6: 'Jun', 
                                 7: 'Jul', 8: 'Aug', 9: 'Sep', 10: 'Oct', 11: 'Nov', 12: 'Dec'},
                'total_column': 13,
                'row_config': {
                    15: {'include': True, 'label': 'Labor', 'category': 'Labor', 'type': 'detail'},
                    17: {'include': True, 'label': 'Fringe', 'category': 'Labor', 'type': 'detail'},
                    24: {'include': True, 'label': 'Staff Aug - Labor', 'category': 'Subcontracts', 'type': 'detail'},
                    25: {'include': True, 'label': 'Staff Aug - Travel', 'category': 'Travel', 'type': 'detail'},
                    26: {'include': True, 'label': 'Travel', 'category': 'Travel', 'type': 'detail'},
                    28: {'include': True, 'label': 'Facilities & Equipment', 'category': 'Materials', 'type': 'detail'},
                    29: {'include': True, 'label': 'Materials & Supplies', 'category': 'Materials', 'type': 'detail'},
                    30: {'include': True, 'label': 'Professional Services', 'category': 'Subcontracts', 'type': 'detail'},
                    31: {'include': True, 'label': 'Miscellaneous Expenses', 'category': 'Other', 'type': 'detail'},
                    33: {'include': True, 'label': 'Depreciation', 'category': 'Overhead', 'type': 'detail'},
                },
                'skip_patterns': ['Total', 'Net ', 'Intercompany', 'Elimination', 'ARO', '---', 'EBITDA'],
                'project_info': {'row': 1, 'col': 1, 'field': 'Project_Code'},
                'metadata': {'project_name_row': 2, 'project_name_col': 1},
                'field_mapping': {
                    'Department': 'template_name',
                    'Account': 'row_label',
                    'Category': 'row_label',
                    'Description': 'row_label',
                    'Project': 'template_name',
                }
            }
        }
    
    with tab1:
        st.caption("Manage templates for importing budget data from messy Excel files")
        
        all_templates = {**st.session_state.budget_templates, **st.session_state.advanced_templates}
        
        if all_templates:
            st.success(f" {len(all_templates)} Templates Available")
            
            # Template list table
            templates_df = pd.DataFrame([
                {
                    'Name': name,
                    'Type': 'Advanced' if name in st.session_state.advanced_templates else 'Standard',
                    'Description': t.get('description', '')[:40],
                    'Rows': len(t.get('row_config', t.get('column_mappings', {}))),
                    'Created': t.get('created_date', 'N/A')
                }
                for name, t in all_templates.items()
            ])
            st.dataframe(templates_df, use_container_width=True, hide_index=True)
            
            st.markdown("---")
            
            # Template actions
            action_col1, action_col2 = st.columns(2)
            
            with action_col1:
                st.markdown("##### Template Actions")
                action_template = st.selectbox("Select Template", list(all_templates.keys()), key="manage_template")
                
                act_btns = st.columns(3)
                with act_btns[0]:
                    if st.button(" Duplicate", use_container_width=True):
                        orig = all_templates[action_template]
                        new_name = f"{action_template} (Copy)"
                        if action_template in st.session_state.advanced_templates:
                            st.session_state.advanced_templates[new_name] = {**orig, 'name': new_name}
                        else:
                            st.session_state.budget_templates[new_name] = {**orig, 'name': new_name}
                        st.success(f"Created '{new_name}'")
                        st.rerun()
                
                with act_btns[1]:
                    if st.button(" Export", use_container_width=True):
                        template_json = json.dumps(all_templates[action_template], indent=2, default=str)
                        st.download_button("Download JSON", data=template_json, 
                                          file_name=f"template_{action_template.replace(' ', '_')}.json",
                                          mime="application/json")
                
                with act_btns[2]:
                    if action_template != 'Kewaunee Roll Up':  # Protect sample
                        if st.button(" Delete", use_container_width=True):
                            if action_template in st.session_state.advanced_templates:
                                del st.session_state.advanced_templates[action_template]
                            elif action_template in st.session_state.budget_templates:
                                del st.session_state.budget_templates[action_template]
                            st.success("Deleted")
                            st.rerun()
            
            with action_col2:
                st.markdown("##### Template Details")
                if action_template:
                    tpl = all_templates[action_template]
                    is_advanced = action_template in st.session_state.advanced_templates
                    
                    st.markdown(f"**Type:** {'Advanced (Row Selection)' if is_advanced else 'Standard'}")
                    st.markdown(f"**Description:** {tpl.get('description', 'N/A')}")
                    
                    if is_advanced:
                        st.markdown(f"**Sheet:** {tpl.get('sheet_name', 'First sheet')}")
                        row_config = tpl.get('row_config', {})
                        st.markdown(f"**Rows Configured:** {len(row_config)}")
                        
                        if row_config:
                            with st.expander("Row Configuration"):
                                rc_df = pd.DataFrame([
                                    {'Row': r, 'Label': cfg['label'][:25], 'Category': cfg['category']}
                                    for r, cfg in row_config.items()
                                ])
                                st.dataframe(rc_df, use_container_width=True, hide_index=True, height=150)
                        
                        # Field Mapping Editor
                        with st.expander(" Field Mapping (for Budget Analysis)", expanded=True):
                            st.caption("Map template data to standard budget fields")
                            
                            current_mapping = tpl.get('field_mapping', {})
                            
                            # Standard fields
                            BUDGET_FIELDS = ['Department', 'Account', 'Category', 'Description', 'Project', 
                                           'Task', 'Vendor', 'Customer', 'PO', 'Legal_Entity']
                            MAPPING_OPTIONS = ['(Not Mapped)', '(Use Row Label)', '(Use Template/Project Name)']
                            
                            new_mapping = {}
                            
                            # Required fields
                            st.markdown("**Required (CC Level):**")
                            req_col1, req_col2, req_col3 = st.columns(3)
                            with req_col1:
                                dept_map = st.selectbox("Department", MAPPING_OPTIONS, 
                                    index=MAPPING_OPTIONS.index('(Use Template/Project Name)') if current_mapping.get('Department') == 'template_name' else (MAPPING_OPTIONS.index('(Use Row Label)') if current_mapping.get('Department') == 'row_label' else 0),
                                    key=f"fm_dept_{action_template}")
                                new_mapping['Department'] = 'template_name' if 'Template' in dept_map else ('row_label' if 'Row Label' in dept_map else None)
                            with req_col2:
                                acct_map = st.selectbox("Account", MAPPING_OPTIONS,
                                    index=MAPPING_OPTIONS.index('(Use Row Label)') if current_mapping.get('Account') == 'row_label' else (MAPPING_OPTIONS.index('(Use Template/Project Name)') if current_mapping.get('Account') == 'template_name' else 0),
                                    key=f"fm_acct_{action_template}")
                                new_mapping['Account'] = 'template_name' if 'Template' in acct_map else ('row_label' if 'Row Label' in acct_map else None)
                            with req_col3:
                                cat_map = st.selectbox("Category", MAPPING_OPTIONS + ['(From Row Config)'],
                                    index=3 if current_mapping.get('Category') in ['row_label', 'row_config'] else 0,
                                    key=f"fm_cat_{action_template}")
                                new_mapping['Category'] = 'row_config' if 'Row Config' in cat_map else ('row_label' if 'Row Label' in cat_map else ('template_name' if 'Template' in cat_map else None))
                            
                            # Optional detail fields
                            st.markdown("**Optional (Detail Level):**")
                            opt_col1, opt_col2 = st.columns(2)
                            with opt_col1:
                                for field in ['Project', 'Task', 'Vendor']:
                                    curr_val = current_mapping.get(field, None)
                                    idx = MAPPING_OPTIONS.index('(Use Template/Project Name)') if curr_val == 'template_name' else (MAPPING_OPTIONS.index('(Use Row Label)') if curr_val == 'row_label' else 0)
                                    fmap = st.selectbox(field, MAPPING_OPTIONS, index=idx, key=f"fm_{field.lower()}_{action_template}")
                                    new_mapping[field] = 'template_name' if 'Template' in fmap else ('row_label' if 'Row Label' in fmap else None)
                            with opt_col2:
                                for field in ['Customer', 'PO', 'Description']:
                                    curr_val = current_mapping.get(field, None)
                                    idx = MAPPING_OPTIONS.index('(Use Template/Project Name)') if curr_val == 'template_name' else (MAPPING_OPTIONS.index('(Use Row Label)') if curr_val == 'row_label' else 0)
                                    fmap = st.selectbox(field, MAPPING_OPTIONS, index=idx, key=f"fm_{field.lower()}_{action_template}")
                                    new_mapping[field] = 'template_name' if 'Template' in fmap else ('row_label' if 'Row Label' in fmap else None)
                            
                            # Save mapping button
                            if st.button(" Save Field Mapping", type="primary", key=f"save_fm_{action_template}"):
                                if action_template in st.session_state.advanced_templates:
                                    st.session_state.advanced_templates[action_template]['field_mapping'] = new_mapping
                                    st.success("Field mapping saved!")
                                    st.rerun()
        else:
            st.info("No templates created yet. Use the Advanced Template Builder tab to create one.")
    
    with tab2:
        st.markdown("####  Advanced Template Builder")
        st.caption("Upload a sample file, select which rows to include, and map them to categories")
        
        # Step 1: Upload sample
        st.markdown("##### Step 1: Upload Sample File")
        
        sample_col1, sample_col2 = st.columns([2, 1])
        
        with sample_col1:
            sample_file = st.file_uploader("Upload sample Excel/CSV", type=['xlsx', 'xls', 'csv'], key="adv_sample")
        
        with sample_col2:
            template_name = st.text_input("Template Name", placeholder="e.g., Kewaunee Budget", key="adv_name")
            template_desc = st.text_input("Description", placeholder="Brief description...", key="adv_desc")
        
        if sample_file:
            try:
                # Get sheet names if Excel
                if sample_file.name.endswith(('.xlsx', '.xls')):
                    xlsx = pd.ExcelFile(sample_file)
                    sheet_names = xlsx.sheet_names
                    selected_sheet = st.selectbox("Select Sheet", sheet_names, key="adv_sheet")
                    sample_df = pd.read_excel(sample_file, sheet_name=selected_sheet, header=None)
                else:
                    selected_sheet = None
                    sample_df = pd.read_csv(sample_file, header=None)
                
                st.success(f" Loaded: {sample_df.shape[0]} rows  {sample_df.shape[1]} columns")
                
                # Step 2: Configure columns
                st.markdown("---")
                st.markdown("##### Step 2: Configure Columns")
                
                col_cfg1, col_cfg2, col_cfg3, col_cfg4 = st.columns(4)
                
                with col_cfg1:
                    label_col = st.number_input("Label Column (0-indexed)", min_value=0, max_value=sample_df.shape[1]-1, value=0, key="adv_label_col")
                
                with col_cfg2:
                    month_start = st.number_input("Month Data Starts (col)", min_value=0, max_value=sample_df.shape[1]-1, value=1, key="adv_month_start")
                
                with col_cfg3:
                    month_end = st.number_input("Month Data Ends (col)", min_value=0, max_value=sample_df.shape[1]-1, value=12, key="adv_month_end")
                
                with col_cfg4:
                    total_col = st.number_input("Total Column (optional)", min_value=-1, max_value=sample_df.shape[1]-1, value=13, key="adv_total_col")
                
                # Build month column mapping
                month_columns = {}
                month_range = month_end - month_start + 1
                if month_range == 12:
                    for i, month in enumerate(MONTHS):
                        month_columns[month_start + i] = month
                elif month_range == 4:
                    quarters = ['Q1', 'Q2', 'Q3', 'Q4']
                    for i, q in enumerate(quarters):
                        month_columns[month_start + i] = q
                else:
                    for i in range(month_range):
                        month_columns[month_start + i] = f"Period_{i+1}"
                
                st.markdown(f"**Detected format:** {month_range} periods")
                
                # Step 3: Field Mapping
                st.markdown("---")
                st.markdown("##### Step 3: Map Fields to Budget Columns")
                st.caption("Map columns in your template to standard budget fields. Department, Account, and Category are required.")
                
                # Standard budget fields
                BUDGET_FIELDS = {
                    'Department': 'Cost center or department (REQUIRED)',
                    'Account': 'GL Account or expense type (REQUIRED)', 
                    'Category': 'Budget category like Labor, Materials (REQUIRED)',
                    'Legal_Entity': 'Business unit or entity',
                    'Project': 'Project code or name',
                    'Task': 'Task or work package',
                    'Vendor': 'Vendor name',
                    'Customer': 'Customer name',
                    'PO': 'Purchase order number',
                    'Description': 'Line item description',
                }
                
                # Get available columns from sample
                available_cols = ['(Not Mapped)', '(Use Row Label)', '(Use Template Name)'] + [f"Col {i}: {str(sample_df.iloc[0, i])[:30]}" if pd.notna(sample_df.iloc[0, i]) else f"Col {i}" for i in range(sample_df.shape[1])]
                
                # Initialize field mapping in session state
                if 'template_field_mapping' not in st.session_state:
                    st.session_state.template_field_mapping = {}
                
                field_map_col1, field_map_col2 = st.columns(2)
                
                field_mappings = {}
                with field_map_col1:
                    st.markdown("**Required Fields**")
                    for field in ['Department', 'Account', 'Category']:
                        default_idx = 0
                        # Try to auto-detect
                        if field == 'Category':
                            default_idx = 1  # Use row label by default for category
                        mapping = st.selectbox(
                            f"{field} *",
                            available_cols,
                            index=default_idx,
                            key=f"field_map_{field}",
                            help=BUDGET_FIELDS[field]
                        )
                        field_mappings[field] = mapping
                
                with field_map_col2:
                    st.markdown("**Optional Detail Fields**")
                    for field in ['Legal_Entity', 'Project', 'Description']:
                        mapping = st.selectbox(
                            field,
                            available_cols,
                            index=0,
                            key=f"field_map_{field}",
                            help=BUDGET_FIELDS[field]
                        )
                        field_mappings[field] = mapping
                
                # Additional optional fields in expander
                with st.expander("More Optional Fields", expanded=False):
                    more_col1, more_col2 = st.columns(2)
                    with more_col1:
                        for field in ['Task', 'Vendor', 'Customer']:
                            mapping = st.selectbox(field, available_cols, index=0, key=f"field_map_{field}", help=BUDGET_FIELDS[field])
                            field_mappings[field] = mapping
                    with more_col2:
                        for field in ['PO']:
                            mapping = st.selectbox(field, available_cols, index=0, key=f"field_map_{field}", help=BUDGET_FIELDS[field])
                            field_mappings[field] = mapping
                
                # Validate required fields
                required_mapped = all(field_mappings.get(f, '(Not Mapped)') != '(Not Mapped)' for f in ['Department', 'Account', 'Category'])
                if not required_mapped:
                    st.warning(" Map all required fields (Department, Account, Category) for Budget Analysis to work properly")
                else:
                    st.success(" Required fields mapped")
                
                # Store parsed mappings (convert display name to column index)
                parsed_mappings = {}
                for field, mapping in field_mappings.items():
                    if mapping == '(Not Mapped)':
                        parsed_mappings[field] = None
                    elif mapping == '(Use Row Label)':
                        parsed_mappings[field] = 'row_label'
                    elif mapping == '(Use Template Name)':
                        parsed_mappings[field] = 'template_name'
                    elif mapping.startswith('Col '):
                        col_idx = int(mapping.split(':')[0].replace('Col ', ''))
                        parsed_mappings[field] = col_idx
                    else:
                        parsed_mappings[field] = None
                
                st.session_state.template_field_mapping = parsed_mappings
                
                # Step 4: Select rows
                st.markdown("---")
                st.markdown("##### Step 4: Select Rows to Include")
                st.caption("Check the rows you want to include and assign categories")
                
                categories = ['Labor', 'Subcontracts', 'Materials', 'Travel', 'Overhead', 'Other', 'Revenue']
                
                # Create editable dataframe with checkboxes
                if 'row_selections' not in st.session_state:
                    st.session_state.row_selections = {}
                
                # Build selection dataframe
                selection_data = []
                for idx in range(min(60, len(sample_df))):  # Show first 60 rows
                    row_label = str(sample_df.iloc[idx, label_col])[:40] if pd.notna(sample_df.iloc[idx, label_col]) else f"Row {idx}"
                    
                    # Check if already selected
                    is_selected = idx in st.session_state.row_selections
                    current_cat = st.session_state.row_selections.get(idx, {}).get('category', 'Other')
                    
                    # Get sample values from first few data columns
                    sample_vals = []
                    for c in range(month_start, min(month_start + 3, sample_df.shape[1])):
                        val = sample_df.iloc[idx, c]
                        if pd.notna(val):
                            try:
                                sample_vals.append(f"${float(val):,.0f}")
                            except:
                                sample_vals.append(str(val)[:10])
                    
                    selection_data.append({
                        'Row': idx,
                        'Include': is_selected,
                        'Label': row_label,
                        'Category': current_cat,
                        'Sample Values': ' | '.join(sample_vals[:3])
                    })
                
                selection_df = pd.DataFrame(selection_data)
                
                # Use data_editor for interactive selection
                edited_df = st.data_editor(
                    selection_df,
                    column_config={
                        'Row': st.column_config.NumberColumn('Row #', disabled=True, width='small'),
                        'Include': st.column_config.CheckboxColumn('Include', default=False, width='small'),
                        'Label': st.column_config.TextColumn('Label', width='medium'),
                        'Category': st.column_config.SelectboxColumn('Category', options=categories, width='small'),
                        'Sample Values': st.column_config.TextColumn('Sample Data', disabled=True, width='medium')
                    },
                    hide_index=True,
                    use_container_width=True,
                    height=400,
                    key="row_selector"
                )
                
                # Update session state based on edits
                new_selections = {}
                for _, row in edited_df.iterrows():
                    if row['Include']:
                        new_selections[int(row['Row'])] = {
                            'include': True,
                            'label': row['Label'],
                            'category': row['Category'],
                            'type': 'detail'
                        }
                
                # Show selection summary
                if new_selections:
                    st.success(f" {len(new_selections)} rows selected")
                    
                    # Category breakdown
                    cat_counts = {}
                    for cfg in new_selections.values():
                        cat = cfg['category']
                        cat_counts[cat] = cat_counts.get(cat, 0) + 1
                    
                    summary_cols = st.columns(len(cat_counts))
                    for i, (cat, count) in enumerate(cat_counts.items()):
                        with summary_cols[i]:
                            st.metric(cat, count)
                else:
                    st.info("Select rows by checking the 'Include' checkbox")
                
                # Step 5: Save template
                st.markdown("---")
                st.markdown("##### Step 5: Save Template")
                
                save_col1, save_col2 = st.columns([2, 1])
                
                with save_col1:
                    if st.button(" Save Template", type="primary", disabled=not template_name or not new_selections, use_container_width=True):
                        new_template = {
                            'id': f"tpl_{datetime.now().strftime('%Y%m%d%H%M%S')}",
                            'name': template_name,
                            'description': template_desc,
                            'created_by': 'User',
                            'created_date': datetime.now().strftime('%Y-%m-%d'),
                            'sheet_name': selected_sheet if selected_sheet else 'Sheet1',
                            'label_column': label_col,
                            'month_columns': month_columns,
                            'total_column': total_col if total_col >= 0 else None,
                            'row_config': new_selections.copy(),
                            'field_mapping': st.session_state.get('template_field_mapping', {}),  # Include field mapping
                        }
                        
                        st.session_state.advanced_templates[template_name] = new_template
                        st.session_state.row_selections = {}
                        st.session_state.template_field_mapping = {}
                        st.success(f" Template '{template_name}' saved with field mappings!")
                        st.balloons()
                
                with save_col2:
                    if new_selections:
                        st.caption(f"Will save {len(new_selections)} rows")
                    if not template_name:
                        st.caption(" Enter template name")
                
            except Exception as e:
                st.error(f"Error reading file: {e}")
    
    with tab3:
        st.markdown("#### Import/Export Templates")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("##### Import Template")
            import_file = st.file_uploader("Import Template JSON", type=['json'], key="import_template_json")
            
            if import_file:
                try:
                    imported = json.load(import_file)
                    import_name = imported.get('name', 'Imported Template')
                    
                    st.info(f"Template: {import_name}")
                    st.json(imported)
                    
                    if st.button(f" Import '{import_name}'", type="primary"):
                        if imported.get('row_config'):
                            imported['row_config'] = {int(k): v for k, v in imported['row_config'].items()}
                            if imported.get('month_columns'):
                                imported['month_columns'] = {int(k): v for k, v in imported['month_columns'].items()}
                            st.session_state.advanced_templates[import_name] = imported
                        else:
                            st.session_state.budget_templates[import_name] = imported
                        st.success(f"Imported '{import_name}'!")
                        st.rerun()
                except Exception as e:
                    st.error(f"Invalid file: {e}")
        
        with col2:
            st.markdown("##### Export All Templates")
            
            all_templates = {**st.session_state.budget_templates, **st.session_state.advanced_templates}
            
            if all_templates:
                all_json = json.dumps(all_templates, indent=2, default=str)
                st.download_button(
                    " Export All Templates",
                    data=all_json,
                    file_name=f"all_templates_{datetime.now().strftime('%Y%m%d')}.json",
                    mime="application/json",
                    use_container_width=True
                )
                st.caption(f"{len(all_templates)} templates will be exported")
            else:
                st.info("No templates to export")


# =============================================================================
# PAGE: ADMINISTRATION
# =============================================================================



# =============================================================================
# PAGE: SETTINGS
# =============================================================================

elif page == " Settings":
    st.markdown("###  Settings")
    
    tab1, tab2, tab3 = st.tabs([" Organization", " Versions", " About"])
    
    with tab1:
        st.markdown("#### Organization Lookup Tables")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("**Departments**")
            dept_file = st.file_uploader("Upload ES_Departments.xlsx", type=['xlsx'], key="org_dept_upload")
            if dept_file:
                try:
                    dept_df = read_xlsx_raw(dept_file)
                    if not dept_df.empty:
                        st.session_state.org_departments = dept_df
                        st.success(f" Loaded {len(dept_df)} departments")
                except Exception as e:
                    st.error(f"Error: {e}")
            
            if not st.session_state.org_departments.empty:
                st.metric("Loaded", len(st.session_state.org_departments))
        
        with col2:
            st.markdown("**Accounts**")
            acct_file = st.file_uploader("Upload ES_Accounts.xlsx", type=['xlsx'], key="org_acct_upload")
            if acct_file:
                try:
                    acct_df = read_xlsx_raw(acct_file)
                    if not acct_df.empty:
                        st.session_state.org_accounts = acct_df
                        st.success(f" Loaded {len(acct_df)} accounts")
                except Exception as e:
                    st.error(f"Error: {e}")
            
            if not st.session_state.org_accounts.empty:
                st.metric("Loaded", len(st.session_state.org_accounts))
    
    with tab2:
        st.markdown("####  Unified Corporate Version Management")
        st.caption("Centralized management for all corporate versions across Budget Planning, BD Forecasting, and Project Controls")
        
        # Initialize unified corporate versions storage
        if 'unified_corporate_versions' not in st.session_state:
            st.session_state.unified_corporate_versions = {}
        
        corporate_versions = st.session_state.unified_corporate_versions
        
        # Status colors
        STATUS_ICONS = {'Working': '', 'Submitted': '', 'In Review': '', 
                       'Approved': '', 'Locked': ''}
        PAGE_ICONS = {'Budget Planning': '', 'BD Forecasting': '', 'Project Controls': ''}
        
        # ===== CREATE NEW CORPORATE VERSION =====
        st.markdown("#####  Create New Corporate Version")
        create_col1, create_col2, create_col3, create_col4, create_col5 = st.columns([2, 1.5, 1, 1, 1])
        
        with create_col1:
            new_ver_name = st.text_input("Version Name", placeholder="e.g., FY2026 Q1", key="ucv_new_name")
        with create_col2:
            new_ver_page_type = st.selectbox("Page Type", 
                                             ["Budget Planning", "BD Forecasting", "Project Controls"],
                                             key="ucv_page_type")
        with create_col3:
            new_ver_year = st.number_input("Fiscal Year", value=datetime.now().year, min_value=2020, max_value=2035, key="ucv_new_year")
        with create_col4:
            new_ver_desc = st.text_input("Description", placeholder="Optional", key="ucv_new_desc")
        with create_col5:
            st.markdown("")
            st.markdown("")
            if st.button(" Create", type="primary", key="ucv_create_btn", disabled=not new_ver_name, use_container_width=True):
                ver_id = f"{new_ver_name.strip().replace(' ', '_').upper()}_{new_ver_page_type.replace(' ', '_').upper()}"
                if ver_id in corporate_versions:
                    st.error(f"Version '{ver_id}' already exists")
                else:
                    st.session_state.unified_corporate_versions[ver_id] = {
                        'name': new_ver_name.strip(),
                        'page_type': new_ver_page_type,
                        'description': new_ver_desc,
                        'fiscal_year': new_ver_year,
                        'status': 'Working',
                        'created': datetime.now(),
                        'created_by': 'Admin',
                        'contributors': {},
                        'total_amount': 0
                    }
                    st.success(f" Created: {new_ver_name} ({new_ver_page_type})")
                    st.rerun()
        
        st.markdown("---")
        
        # ===== CORPORATE VERSIONS TABLE =====
        if corporate_versions:
            st.markdown("#####  Corporate Versions")
            
            # Filter by page type
            filter_col1, filter_col2 = st.columns([1, 3])
            with filter_col1:
                filter_page_type = st.selectbox("Filter by Type", 
                                                ["All", "Budget Planning", "BD Forecasting", "Project Controls"],
                                                key="ucv_filter_type")
            
            # Filter versions
            if filter_page_type == "All":
                filtered_versions = corporate_versions
            else:
                filtered_versions = {k: v for k, v in corporate_versions.items() 
                                    if v.get('page_type') == filter_page_type}
            
            if filtered_versions:
                # Build table data
                table_data = []
                for ver_key, ver_info in filtered_versions.items():
                    created_date = ver_info.get('created', datetime.now())
                    if hasattr(created_date, 'strftime'):
                        created_str = created_date.strftime('%Y-%m-%d')
                    else:
                        created_str = str(created_date)[:10]
                    
                    table_data.append({
                        'key': ver_key,
                        'Page Type': f"{PAGE_ICONS.get(ver_info.get('page_type', ''), '')} {ver_info.get('page_type', '')}",
                        'Version Name': ver_info.get('name', ''),
                        'FY': ver_info.get('fiscal_year', ''),
                        'Status': f"{STATUS_ICONS.get(ver_info.get('status', 'Working'), '')} {ver_info.get('status', 'Working')}",
                        'Contributors': len(ver_info.get('contributors', {})),
                        'Total Amount': f"${ver_info.get('total_amount', 0):,.0f}",
                        'Created': created_str
                    })
                
                # Display as a table
                table_df = pd.DataFrame(table_data)
                
                st.dataframe(
                    table_df[['Page Type', 'Version Name', 'FY', 'Status', 'Contributors', 'Total Amount', 'Created']],
                    hide_index=True,
                    use_container_width=True,
                    height=min(400, 50 + len(table_data) * 35)
                )
                
                # Version selector for actions
                st.markdown("---")
                st.markdown("#####  Version Actions")
                
                ver_options = list(filtered_versions.keys())
                ver_display = [f"{filtered_versions[k]['name']} ({filtered_versions[k]['page_type']}) - {filtered_versions[k].get('status', 'Working')}" 
                              for k in ver_options]
                
                action_col1, action_col2 = st.columns([2, 3])
                
                with action_col1:
                    selected_idx = st.selectbox("Select Version for Actions", range(len(ver_options)), 
                                               format_func=lambda i: ver_display[i], key="ucv_select_ver_action")
                    selected_ver = ver_options[selected_idx]
                    ver_info = filtered_versions[selected_ver]
                    current_status = ver_info.get('status', 'Working')
                    is_locked = current_status == 'Locked'
                    is_approved = current_status == 'Approved'
                
                with action_col2:
                    # Status workflow buttons in a row
                    st.markdown(f"**Current Status:** {STATUS_ICONS.get(current_status, '')} {current_status}")
                    
                    btn_cols = st.columns(5)
                    
                    # Show appropriate action based on status
                    with btn_cols[0]:
                        if current_status == 'Working':
                            if st.button(" Submit", key="ucv_submit", use_container_width=True, help="Submit for review"):
                                st.session_state.unified_corporate_versions[selected_ver]['status'] = 'Submitted'
                                st.toast(" Submitted for review")
                                st.rerun()
                        elif current_status == 'Submitted':
                            if st.button(" Unsubmit", key="ucv_unsubmit", use_container_width=True, help="Return to Working"):
                                st.session_state.unified_corporate_versions[selected_ver]['status'] = 'Working'
                                st.toast(" Returned to Working")
                                st.rerun()
                    
                    with btn_cols[1]:
                        if current_status == 'Submitted':
                            if st.button(" Approve", key="ucv_approve", use_container_width=True, type="primary", help="Approve this version"):
                                st.session_state.unified_corporate_versions[selected_ver]['status'] = 'Approved'
                                st.session_state.unified_corporate_versions[selected_ver]['approved_date'] = datetime.now()
                                st.toast(" Version Approved")
                                st.rerun()
                        elif current_status == 'Approved':
                            if st.button(" Unapprove", key="ucv_unapprove", use_container_width=True, help="Return to Submitted"):
                                st.session_state.unified_corporate_versions[selected_ver]['status'] = 'Submitted'
                                st.toast(" Returned to Submitted")
                                st.rerun()
                    
                    with btn_cols[2]:
                        if current_status == 'Approved':
                            if st.button(" Lock", key="ucv_lock", use_container_width=True, type="primary", help="Lock this version"):
                                st.session_state.unified_corporate_versions[selected_ver]['status'] = 'Locked'
                                st.session_state.unified_corporate_versions[selected_ver]['locked_date'] = datetime.now()
                                st.toast(" Version Locked")
                                st.rerun()
                        elif current_status == 'Locked':
                            if st.button(" Unlock", key="ucv_unlock", use_container_width=True, help="Unlock this version"):
                                st.session_state.unified_corporate_versions[selected_ver]['status'] = 'Approved'
                                st.toast(" Version Unlocked")
                                st.rerun()
                    
                    with btn_cols[3]:
                        if st.button(" View Data", key="ucv_view_data", use_container_width=True, help="View saved contributions"):
                            st.session_state.ucv_show_data_dialog = selected_ver
                            st.rerun()
                    
                    with btn_cols[4]:
                        if not is_locked:
                            if st.button(" Delete", key="ucv_delete", use_container_width=True, type="secondary", help="Delete this version"):
                                del st.session_state.unified_corporate_versions[selected_ver]
                                st.toast(" Version deleted")
                                st.rerun()
                        else:
                            st.button(" Delete", key="ucv_delete_disabled", use_container_width=True, disabled=True, help="Unlock to delete")
                
                # Show dates
                date_info = []
                if ver_info.get('approved_date'):
                    approved_date = ver_info['approved_date']
                    if hasattr(approved_date, 'strftime'):
                        date_info.append(f"Approved: {approved_date.strftime('%Y-%m-%d %H:%M')}")
                if ver_info.get('locked_date'):
                    locked_date = ver_info['locked_date']
                    if hasattr(locked_date, 'strftime'):
                        date_info.append(f"Locked: {locked_date.strftime('%Y-%m-%d %H:%M')}")
                if date_info:
                    st.caption(" | ".join(date_info))
                
                # ===== CONTRIBUTORS / VIEW DATA DIALOG =====
                @st.dialog(" Corporate Version Data", width="large")
                def show_version_data_dialog(ver_id):
                    ver_data = st.session_state.unified_corporate_versions.get(ver_id, {})
                    contributors = ver_data.get('contributors', {})
                    
                    st.markdown(f"### {ver_data.get('name', 'Unknown Version')}")
                    st.markdown(f"**Page Type:** {ver_data.get('page_type', 'N/A')} | **Status:** {STATUS_ICONS.get(ver_data.get('status', 'Working'), '')} {ver_data.get('status', 'Working')} | **Contributors:** {len(contributors)}")
                    st.markdown("---")
                    
                    if contributors:
                        for contrib_name, contrib_info in contributors.items():
                            c_col1, c_col2, c_col3, c_col4 = st.columns([2, 1.5, 1.5, 1])
                            with c_col1:
                                st.markdown(f"** {contrib_name}**")
                            with c_col2:
                                st.metric("Amount", f"${contrib_info.get('total', 0):,.0f}")
                            with c_col3:
                                st.caption(f"Saved: {contrib_info.get('saved_at', 'N/A')}")
                                st.caption(f"By: {contrib_info.get('saved_by', 'N/A')}")
                            with c_col4:
                                contrib_status = ver_data.get('status', 'Working')
                                if contrib_status not in ['Locked', 'Approved']:
                                    if st.button(" Pull Back", key=f"dlg_pull_{ver_id}_{contrib_name.replace(' ', '_').replace('.', '_')}", 
                                               help="Remove from corporate version"):
                                        page_type = ver_data.get('page_type')
                                        pullback_name = f"Pulled from {ver_data['name']} - {contrib_name}"
                                        
                                        # Create standalone copy based on page type
                                        if page_type == 'BD Forecasting':
                                            if 'bd_forecast_versions' not in st.session_state:
                                                st.session_state.bd_forecast_versions = {}
                                            st.session_state.bd_forecast_versions[pullback_name] = {
                                                'data': contrib_info.get('data', pd.DataFrame()),
                                                'version_type': 'Standalone',
                                                'page_type': page_type,
                                                'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M'),
                                                'pulled_from': ver_id
                                            }
                                        elif page_type == 'Budget Planning':
                                            if 'saved_budget_versions' not in st.session_state:
                                                st.session_state.saved_budget_versions = {}
                                            st.session_state.saved_budget_versions[pullback_name] = {
                                                'data': contrib_info.get('data', pd.DataFrame()),
                                                'version_type': 'Standalone',
                                                'page_type': page_type,
                                                'saved_at': datetime.now().strftime('%Y-%m-%d %H:%M'),
                                                'pulled_from': ver_id
                                            }
                                        elif page_type == 'Project Controls':
                                            if 'project_forecast_versions' not in st.session_state:
                                                st.session_state.project_forecast_versions = {}
                                            st.session_state.project_forecast_versions[pullback_name] = {
                                                'data': contrib_info.get('data', pd.DataFrame()),
                                                'total_revenue': contrib_info.get('total', 0),
                                                'total_cost': contrib_info.get('total', 0),
                                                'created': datetime.now().strftime('%Y-%m-%d %H:%M'),
                                                'pulled_from': ver_id
                                            }
                                        
                                        # Remove from corporate version
                                        del st.session_state.unified_corporate_versions[ver_id]['contributors'][contrib_name]
                                        # Recalculate total
                                        new_total = sum(c.get('total', 0) for c in st.session_state.unified_corporate_versions[ver_id]['contributors'].values())
                                        st.session_state.unified_corporate_versions[ver_id]['total_amount'] = new_total
                                        st.toast(f" Pulled back: {contrib_name}")
                                        st.rerun()
                            
                            # Show the actual data
                            contrib_data = contrib_info.get('data', pd.DataFrame())
                            if isinstance(contrib_data, pd.DataFrame) and not contrib_data.empty:
                                st.dataframe(contrib_data, use_container_width=True, height=150)
                            else:
                                st.caption("No detailed data available")
                            st.markdown("---")
                    else:
                        st.info("No contributions yet. Users can contribute from their respective pages (Budget Planning, BD Forecasting, or Project Controls).")
                    
                    if st.button("Close", type="primary", use_container_width=True):
                        st.session_state.ucv_show_data_dialog = None
                        st.rerun()
                
                # Show dialog if triggered
                if st.session_state.get('ucv_show_data_dialog') and st.session_state.ucv_show_data_dialog in st.session_state.unified_corporate_versions:
                    show_version_data_dialog(st.session_state.ucv_show_data_dialog)
            else:
                st.info(f"No corporate versions found for {filter_page_type}")
        else:
            st.info("No corporate versions created yet. Use the form above to create one.")
        
        st.markdown("---")
        
        # ===== STANDALONE VERSIONS BY PAGE TYPE =====
        st.markdown("#####  Standalone Versions (Personal Drafts)")
        
        standalone_tabs = st.tabs([" Budget Planning", " BD Forecasting", " Project Controls"])
        
        with standalone_tabs[0]:
            saved_versions = st.session_state.get('saved_budget_versions', {})
            if saved_versions:
                for ver_name in saved_versions.keys():
                    st.write(f" {ver_name}")
            else:
                st.caption("No standalone Budget Planning versions.")
        
        with standalone_tabs[1]:
            bd_versions = st.session_state.get('bd_forecast_versions', {})
            standalone_bd = {k: v for k, v in bd_versions.items() if v.get('version_type') == 'Standalone'}
            if standalone_bd:
                for ver_name, ver_info in standalone_bd.items():
                    sa_col1, sa_col2, sa_col3 = st.columns([3, 2, 1])
                    with sa_col1:
                        st.write(f" {ver_name}")
                    with sa_col2:
                        st.caption(f"Saved: {ver_info.get('saved_at', 'N/A')}")
                    with sa_col3:
                        if st.button("", key=f"sa_bd_del_{ver_name.replace(' ', '_')}", help="Delete"):
                            del st.session_state.bd_forecast_versions[ver_name]
                            st.rerun()
            else:
                st.caption("No standalone BD Forecasting versions.")
        
        with standalone_tabs[2]:
            proj_versions = st.session_state.get('project_forecast_versions', {})
            if proj_versions:
                for ver_name, ver_info in proj_versions.items():
                    st.write(f" **{ver_name}** - ${ver_info.get('total_revenue', 0):,.0f}")
            else:
                st.caption("No standalone Project Controls versions.")
    
    with tab3:
        st.markdown("#### XYZ Industries Budget Forecasting Platform")
        st.markdown("**Version:** 1.0")
